***
# Installing HydraLib

Hydra requires the Haskell compiler ghc and a number of related tools
and libraries.  All of these tools, as well as Hydra, are free
software, and they run on all major platforms.

1. Install the Haskell compiler ghc and make sure it is in your path.
   To check this, enter the command ghc --version.  If necessary, you
   can download Haskell from www.haskell.org.  It's best to install
   the latest version of the Haskell Platform, not the latest version
   of ghc itself, as the Platform includes many useful libraries and
   tools.

2. Open a shell window (a command line window).

3. Obtain HydraLib and copy it somewhere in your file space.  Its full
   name contains a version number of the form <1.2.3> (but use the
   real version number, not 1.2.3!).  The file is available either as
   a zip file or a tgz file.  Unpack it with <em>unzip
   HydraLib-1.2.3.zip</em> or <tar -xzf HydraLib-1.2.3.tgz>.

4. Enter the HydraLib directory.

5. (On Linux, MacOS, or Cygwin on Windows): enter <em>make build</em>
   to compile the system.

6. (On Windows Command Prompt window): enter <em>cabal install</em>,
   then <em>cabal haddock</em>.  This does not build the html
   documentation (in doc/html) from the markdown source (in doc/src).
   That doesn't matter if your distribution already contains doc/html.
   Otherwise, see the makefile for the commands needed to build the
   User Guide with pandoc.

# Tutorial

# Launching a script

Create a file named Tutorial1.hs, and use your favorite text editor to
put the following contents into it:

     module Tutorial1 where
     import Hydra
     import Hydra.StandardCircuits

Now launch the interactive Haskell system ghci, and then tell it to
load your file.  Here is what you actually type in:

     ghci
     :load Tutorial1

What you will see on the screen is something like this:

     $ ghci
     GHCi, version 6.10.1: http://www.haskell.org/ghc/  :? for help
     Loading package ghc-prim ... linking ... done.
     Loading package integer ... linking ... done.
     Loading package base ... linking ... done.
     Prelude> :load Tutorial1
     [1 of 1] Compiling Tutorial1        ( Tutorial1.hs, interpreted )
     Ok, modules loaded: Tutorial1.
     *Tutorial1> 




# Signals and gates

A *signal* is a wire.  A signal may have a name, such as x, y, sum16.
A name must begin with a lower case letter (x but not X), and it may
continue with letters, digits, underscores, and single quote
characters.  Here are some valid signal names:

     a xyz carry_sum x'



## Signals

## Logic gates


The most commonly used logic gates are

     inv   inverter
     and2  and gate with 2 inputs
     or2   inclusive or gate with 2 inputs
     xor2  exclusive or gate with 2 inputs

An equation can be used to define the output of a logic gates which is
connected to input signals.  For example, this equation says there is
an inverter with input a and output p:

     p = inv a
     q = and2 a b
     r = or2 a b
     s = xor2 a b

The behaviours of these logic gates are summarised in this truth
table:


 a    b      p    q    r    s
---  ---    ---  ---  ---  ---
 0    0      1    0    0    0
 0    1      1    0    1    1
 1    0      0    0    1    1
 1    1      0    1    1    0


## Complete list of pre-defined logic gates

Here is a complete list of the logic gates that are defined in the
Hydra libraries.


     Usage              Description
----------------   -----------------------
buf a              buffer
inv a              inverter
and2 a b           2-input and gate
and3 a b c         3-input and gate
and4 a b c d       4-input and gate
or2 a b            2-input or gate
or3 a b c          3-input or gate
or4 a b c d        4-input or gate
xor2 a b           2-input xor gate
xor3 a b c         3-input xor gate
xor4 a b c d       4-input xor gate
nand2 a b          2-input nand gate
nand3 a b c        3-input nand gate
nand4 a b c d      4-input nand gate
nor2 a b           2-input nor gate
nor3 a b c         3-input nor gate
nor4 a b c d       4-input nor gate
xnor2 a b          2-input xnor gate
xnor3 a b c        3-input xnor gate
xnor4 a b c d      4-input xnor gate



## Simulating a logic gate with Booleans

You can simulate a small combinational circuit by giving it input
values of True or False.  For example, inv True means "connect an inv
circuit to an input value of True", and the result is the output of
the logic gate, which is False.

     *Tutorial1> inv True
     False

The other logic gates can be tested in a similar way.  Be sure to give
the component the right number of inputs.

     *Tutorial1> and2 False True
     False
     *Tutorial1> xor3 True False True
     False
     *Tutorial1> 

This technique is useful for some quick experiments with a circuit,
but it has some limitations, and it is limited to combinational
circuits, i.e. circuits that do not contain any flip flops.


## Constant signals

A signal is the value on a wire.  The constant signals are written
as

     zero
     one

You can use a constant signal as an input to a circuit: inv one.  If
you do this in a top-level interaction, there will be an error
message, looking something like this:

     *Tutorial1> inv zero
     <interactive>:1:0:
         Ambiguous type variable `a' in the constraint:
           `Signal a' arising from a use of `inv' at <interactive>:1:0-7
         Probable fix: add a type signature that fixes these type variable(s)
     *Tutorial1> 

The cause of the error is that Hydra has several different ways to
represent a signal, and an expression like inv zero doesn't provide
enough context to determine which one you want (hence the ambiguous
type variable).

The normal way to prevent this error is simply to run your circuit with a
simulation driver (described below), which will specify which signal
representation to use.  If you really want to use the constants zero or one
without a simulation driver, you can specify the Bool representation
explicitly:

     *Tutorial1> inv zero :: Bool
     True
     *Tutorial1> 

However, that will only work for a combinational circuit.  To simulate
a sequential circuit, you really need to use a simulation driver.


## Generating truth tables

One way to determine fully the behaviour of a circuit is to simulate
it with all possible sets of input values, building a truth table
showing the results.  Hydra provides a set of operations to do this.
For example, truthTable21 takes a circuit from 2 inputs to 1 output,
and prints the truth table:

     *Tutorial1> truthTable21 xor2
         0 0 | 0
         0 1 | 1
         1 0 | 1
         1 1 | 0
     *Tutorial1> 

This approach is feasible only for combinational circuits that have a
small number of inputs.  The following definition runs a sequence of
truth table tests on several of the logic gates. -}

test_gates =
  do putStrLn "Buffer (buf)"
     truthTable11 buf
     putStrLn "Inverter (inv)"
     truthTable11 inv
     putStrLn "2-input and gate (and2)"
     truthTable21 and2
     putStrLn "3-input and gate (and3)"
     truthTable31 and3
     putStrLn "4-input and gate (and4)"
     truthTable41 and4

{- You can run the test_gates command by entering it at the prompt:

  *Tutorial1> test_gates
  Buffer (buf)
      0 | 0
      1 | 1
  Inverter (inv)
      0 | 1
      1 | 0
  2-input and gate (and2)
      0 0 | 0
  ...
  ...
-}


# Combinational circuits

Here is a definition of a black box circuit, named circ1, with two
inputs and one output.  Within the black box, the inputs are named x
and y, and the output is anonymous (has no name).  The first input to
the and2 gate is the output of an inverter with input x.  The second
input to the and2 gate is y.

     circ1 x y = and2 (inv x) y

     tt_circ1 = truthTable21 circ1


     mux1 :: Signal a => a -> a -> a -> a
     mux1 p a b = x
       where x = or2 (and2 (inv p) a) (and2 p b)

## Defining equation for a circuit

## Circuit type

## Defining internal signals

## Scope of names


# Signal clusters

## Tuples


     demux1 :: Signal a => a -> a -> (a,a)
     demux1 c x = (and2 (inv c) x, and2 c x)

     mux2 :: Signal a => (a,a) -> a -> a -> a -> a -> a
     mux2 (p0,p1) a b c d = x
       where x = mux1 p0 (mux1 p1 a b) (mux1 p1 c d)

     mux3 :: Signal a => (a,a,a) -> a -> a -> a -> a -> a-> a -> a -> a -> a
     mux3 (c0,c1,c2) a0 a1 a2 a3 a4 a5 a6 a7 =
       mux1 c0
         (mux1 c1
           (mux1 c2 a0 a1)
           (mux1 c2 a2 a3))
         (mux1 c1
           (mux1 c2 a4 a5)
           (mux1 c2 a6 a7))

     mux22 :: Signal a => (a,a) -> (a,a) -> (a,a) -> (a,a) -> (a,a) -> (a,a)
     mux22 (p0,p1) (a0,a1) (b0,b1) (c0,c1) (d0,d1) = (x,y)
       where x = mux2 (p0,p1) a0 b0 c0 d0
             y = mux2 (p0,p1) a1 b1 c1 d1

     demux2 :: Signal a => (a,a) -> a -> (a,a,a,a)
     demux2 (c0,c1) x = (y0,y1,y2,y3)
       where (y0,y1) = demux1 c1 (inv c0)
             (y2,y3) = demux1 c1 c0



## Words

Notation for words

-- Logic on words


     winv4 :: Signal a => [a] -> [a]
     winv4 [x0,x1,x2,x3]
       = [inv x0, inv x1, inv x2, inv x3]

     w4mux1 :: Signal a => a -> [a] -> [a] -> [a]
     w4mux1 c [x0,x1,x2,x3] [y0,y1,y2,y3] =
       [mux1 c x0 y0, mux1 c x1 y1, mux1 c x2 y2, mux1 c x3 y3]


## Word4


     rippleAdd4 :: Signal a => a -> [(a,a)] -> (a,[a])
     rippleAdd4 cin [(x0,y0),(x1,y1),(x2,y2),(x3,y3)]
       = (c0, [s0,s1,s2,s3])
       where
         (c0,s0) = fullAdd (x0,y0) c1
         (c1,s1) = fullAdd (x1,y1) c2
         (c2,s2) = fullAdd (x2,y2) c3
         (c3,s3) = fullAdd (x3,y3) cin



     -- A 4-bit shift register
     -- op:  00   no operation
     --      01   load
     --      10   shift right
     --      11   shift left



     srb :: Clocked a => (a,a) -> a -> a -> a -> a
     srb op l r x = y
       where y = dff (mux2 op y x l r)


     sr4 :: Clocked a => (a,a) -> a -> a -> [a] -> [a]
     sr4 op l r [x0,x1,x2,x3] = [a,b,c,d]
       where
          a = srb op l b x0
          b = srb op a c x1
          c = srb op b d x2
          d = srb op c r x3



## Simulation drivers


     sim_circ1 input =
       let a = getbit input 0
           b = getbit input 1
           x = circ1 a b
           simoutput :: [Format Bool]
           simoutput =
             [string "  a=", bit a, string " b=", bit b, string "  x=", bit x]
       in do putStrLn "\nSimulating circ1"
             run input simoutput

     circ1_input :: [[Int]]
     circ1_input =
       [ [0,0]
       , [0,1]
       , [1,0]
       , [1,1]
       ]




     circ2 x y z = (or2 x y, xor2 x z)
     
     -- sim_circ2 circ2_input
     
     sim_circ2 input =
       let a = getbit input 0
           b = getbit input 1
           c = getbit input 2
           (p,q) = circ2 a b c
           simoutput :: [Format Bool]
           simoutput =
             [string "  a=", bit a, string "  b=", bit b,
              string "  p=", bit p, string "  q=", bit q]
       in do putStrLn "\nSimulating circ2"
             run input simoutput
     
     circ2_input :: [[Int]]
     circ2_input =
       [[0,0,1],
        [1,1,0],
        [1,0,0],
        [1,1,1],
        [1,1,0],
        [0,1,0]]



     mux14_test :: [[Int]]
     mux14_test =
       [[0,  3 , 4],
        [1,  3,  4],
        [0, 12, 13],
        [1, 12, 13]]

     sim_mux14 input =
       let zs = w4mux1 c xs ys
           c = getbit input 0 :: Stream Bool
           xs = getbin 4 input 1
           ys = getbin 4 input 2
           simoutput :: [Format Bool]
           simoutput =
             [string "  c=", bit c,
              string "  xs = ", bits xs,
              string " (hex ", hex xs, string ") ",
              string "  ys = ", bits ys,
              string " (hex ", hex ys, string ") ",
              string "  Output zs = ", bits zs,
              string " (hex ", hex zs, string ") "]
       in do putStrLn "Simulating mux14"
             run input simoutput


## a circuit

     circuit1b x y z = (p,q)
       where p = and3 x y z
             b = or2 y z
             q = xor2 p b

Test by evaluating:
   truthTable31 circuit1b


truthTable31 circuit5

     circuit5 a b c =
       or2 (and3 (inv a) (inv b) (inv c))
           (and3 a (inv b) c)

     truthTable31 circuit5


     circuit1a a b c = inv (xor2 (and2 a b) (or2 b c))

-- truthTable31 circuit1a

     testcirc :: Signal a => a -> a -> a -> a
     testcirc a b c = or2 (and2 a b) c

     circuit1 a b c = inv (xor2 (and2 a b) (or2 b c))



     sim_circ2 input =
       let a = getbit input 0
           b = getbit input 1
           (p,q) = circ2 a b
           simoutput :: [Format Bool]
           simoutput =
             [string "  a=", bit a, string "  b=", bit b,
              string "  p=", bit p, string "  q=", bit q]
       in do putStrLn "\nSimulating circ2"
             run input simoutput


     circ2x_input :: [[Int]]
     circ2x_input =
       [[0,0],
        [1,1],
        [1,0],
        [1,1],
        [1,1],
        [0,1]]




# Synchronous circuits


##  Streams and lists: Simple sequential circuit

     circ5 a =
       let x = dff (xor2 x a)
       in x
     
     circ5_input1 =
       listStream [True, False, True, True, False, True, True]
     
     circ5_input2 = listStream (repeat True)

     -- circ5 circ1_input1
     -- circ5 circ1_input2


## A sequential circuit with several inputs and flip flops

     circ6 a b = (p,q)
       where u = and2 a q
             v = xor2 b p
             p = dff u
             q = dff v

     circ6_inputa = listStream [False, True, True,  True, True, False]
     circ6_inputb = listStream [False, True, False, True, True, True]


       [[0,0],
        [1,1],
        [1,0],
        [1,1],
        [1,1],
        [0,1]]


     -- circ2 circ2_inputa circ2_inputb
     -- fst (circ2 circ2_inputa circ2_inputb)
     -- snd (circ2 circ2_inputa circ2_inputb)


     Cycle   a  b  u  v  p  q
       0     0  0  0  0  0  0
       1     1  1  0  1  0  0
       2     1  0  1  0  0  1
       3     1  1  0  0  1  0
       4     1  1  0  1  0  0
       5     0  1  0  1  0  1
       6                 0  1





## A 1-bit register

     reg1 :: Clocked a => a -> a -> a
     reg1 ld x = r
       where r = dff (mux1 ld r x)

     reg_input_ld =
       listStream [True, False, False, True,  True, True, True,  False]
     reg_input_x =
       listStream [True, False, True,  False, True, True, False, True]



     Cycle  ld  x   reg
       0     1  1    0
       1     0  0    1
       2     0  1    1
       3     1  0    1
       4     1  1    0
       5     1  1    1
       6     1  0    1
       7     0  1    0
       8             0


-- reg1 reg_ld reg_x


     sim_reg1 input =
       let ld = getbit input 0
           x = getbit input 1
           r = reg1 ld x
           simoutput :: [Format Bool]
           simoutput =
             [string "ld=", bit ld, string " x=", bit x, string " r=", bit r]
       in do putStrLn "\nSimulating reg1"
             run input simoutput


     reg1_input :: [[Int]]
     reg1_input =
       [[1,1],
        [0,0],
        [0,1],
        [1,0],
        [1,1],
        [0,0]]


## 4-bit register


     reg4 :: Clocked a => a -> [a] -> [a]
     reg4 ld [x0,x1,x2,x3] =
       [reg1 ld x0, reg1 ld x1, reg1 ld x2, reg1 ld x3]


## 4-bit shift register


-- sim_sr4 sr4_input

     sim_sr4 input =
       let op0 = getbit input 0
           op1 = getbit input 1
           li = getbit input 2
           ri = getbit input 3
           x0 = getbit input 4
           x1 = getbit input 5
           x2 = getbit input 6
           x3 = getbit input 7
           [y0,y1,y2,y3] = sr4 (op0,op1) li ri [x0,x1,x2,x3]
           simoutput :: [Format Bool]
           simoutput =
             [string "op=", bit op0, bit op1,
              string "  li=", bit li,
              string "  ri=", bit ri,
              string "  x=", bit x0, bit x1, bit x2, bit x3,
              string "  y=", bit y0, bit y1, bit y2, bit y3]
       in do putStrLn "\nSimulating sr4y"
             run input simoutput

     sr4_input :: [[Int]]
     sr4_input =
       [[0,1,  0,0,  1,0,1,1],
        [0,0,  0,0,  0,0,0,0],
        [1,0,  1,0,  0,0,0,0],
        [1,0,  0,0,  0,0,0,0],
        [1,0,  1,0,  0,0,0,0],
        [0,0,  0,0,  0,0,0,0],
        [1,1,  0,1,  0,0,0,0],
        [1,1,  0,1,  0,0,0,0],
        [1,1,  0,0,  0,0,0,0],
        [0,1,  0,0,  0,1,0,0],
        [0,0,  0,0,  0,0,0,0]]




Working out a simulation table by hand:

         op    l r      x         y
       [[0,1,  0,0,  1,0,1,1],  0000 
        [0,0,  0,0,  0,0,0,0],  1011  result of load
        [1,0,  1,0,  0,0,0,0],  1011  result of nop
        [1,0,  0,0,  0,0,0,0],  1101  result of shift right (with 1)
        [1,0,  1,0,  0,0,0,0],  0110  result of shift right (with 0)
        [0,0,  0,0,  0,0,0,0],  1011  result of shift right (with 1)
        [1,1,  0,1,  0,0,0,0],  1011  result of nop
        [1,1,  0,1,  0,0,0,0],  0111  result of shift left (with 1)
        [1,1,  0,0,  0,0,0,0],  1111  result of shift left (with 1)
        [0,1,  0,0,  0,1,0,0],  1110  result of shift left (with 0)
        [0,0,  0,0,  0,0,0,0]]  0100  result of load
                           0100  result of nop




-- set up the simulation

     sr4_out = [y0,y1,y2,y3]
       where
         [y0,y1,y2,y3] = sr4 (op0,op1) li ri [x0, x1, x2, x3]
         op0 = input_ints [0,0,1,1,1,0,1,1,1,0,0]
         op1 = input_ints [1,0,0,0,0,0,1,1,1,1,0]
         li  = input_ints [0,0,1,0,1,0,0,0,0,0,0]
         ri  = input_ints [0,0,0,0,0,0,1,1,0,0,0]
         x0  = input_ints [1,0,0,0,0,0,0,0,0,0,0]
         x1  = input_ints [0,0,0,0,0,0,0,0,0,1,0]
         x2  = input_ints [1,0,0,0,0,0,0,0,0,0,0]
         x3  = input_ints [1,0,0,0,0,0,0,0,0,0,0]




Meaning of op:

     0 -- no state change
     1 -- load input word x
     2 -- shift right
     3 -- shift left


Several variations of the shift register, which handle the fanout
in different ways.  See the Hydra Manual section on fanout and
partial applications.

Version 1 is just the same as above.

     sr4_v1 :: Clocked a => (a,a) -> a -> a -> [a] -> [a]
     sr4_v1 op l r [x0,x1,x2,x3] = [a,b,c,d]
       where
          a = srb op l b x0
          b = srb op a c x1
          c = srb op b d x2
          d = srb op c r x3

Version 2 uses implicit fanout expressed by defining the f box as a
partial application.

     sr4_v2 :: Clocked a => (a,a) -> a -> a -> [a] -> [a]
     sr4_v2 op l r [x0,x1,x2,x3] = [a,b,c,d]
       where
          f = srb op
          a = f l b x0
          b = f a c x1
          c = f b d x2
          d = f c r x3

-- Version 3 uses explicit fanout.

     sr4_v3 :: Clocked a => (a,a) -> a -> a -> [a] -> [a]
     sr4_v3 op l r [x0,x1,x2,x3] = [a,b,c,d]
       where
          (opa,opb,opc,opd) = fanout4 op
          a = srb opa l b x0
          b = srb opb a c x1
          c = srb opc b d x2
          d = srb opd c r x3


------------------------------------------------------------------------

# Miscellaneous



# Design patterns


-- Word inverter: winv takes a word and inverts each of its bits

     winv :: Signal a => [a] -> [a]
     winv x = map inv x

And/Or over a word: Determine whether there exists a 1 in a word, or
whether all the bits are 0.  A tree fold can do this in log time, but
for simplicity this is just a linear time fold.

-- ?? any1, all1 deprecated, remove...

     any0, any1, all0, all1 :: Signal a => [a] -> a
     any1 = error "any1 replaced by orw" -- foldl or2 zero
     all1 = error "all1 replaced by andw" -- foldl and2 one
     all0 xs = inv (orw xs)
     any0 xs = inv (andw xs)

     orw, andw :: Signal a => [a] -> a
     orw = foldl or2 zero
     andw = foldl and2 one


     mux1w :: Signal a => a -> [a] -> [a] -> [a]
     mux1w c x y = map2 (mux1 c) x y


-- Ripple carry addition

     rippleAdd :: Signal a => a -> [(a,a)] -> (a,[a])
     rippleAdd = mscanr fullAdd


-- Two's complement addition and subtraction

     addSub :: Signal a => a -> [(a,a)] -> (a,[a])
     addSub sub xy = rippleAdd sub (map f xy)
       where f (x,y) = (x, xor2 sub y)







------------------------------------------------------------------------

## Registers

     reg :: Clocked a => Int -> a -> [a] -> [a]
     reg k ld x = mapn (reg1 ld) k x
     wlatch :: Clocked a => Int -> [a] -> [a]
     wlatch k x = mapn dff k x


## Register files

     regfile1 :: Clocked a => Int -> a -> [a] -> [a] -> [a] -> a -> (a,a)
     
     regfile1 0 ld d sa sb x = (r,r)
       where r = reg1 ld x
     
     {- demux1 not in scope ???
     regfile1 (k+1) ld (d:ds) (sa:sas) (sb:sbs) x = (a,b)
       where
         (a0,b0) = regfile1 k ld0 ds sas sbs x
         (a1,b1) = regfile1 k ld1 ds sas sbs x
         (ld0,ld1) = demux1 d ld
         a = mux1 sa a0 a1
         b = mux1 sb b0 b1
     -}
     
     regfile :: Clocked a => Int -> Int
       -> a -> [a] -> [a] -> [a] -> [a] -> ([a],[a])
     
     regfile n k ld d sa sb x =
        unbitslice2 [regfile1 k ld d sa sb (x!!i)  | i <- [0..n-1]]

     -- sim_regfile regfile_input1
     -- sim_regfile regfile_input2
     
     regfile_input1 :: [[Int]]
     regfile_input1 =
     -- ld  d  sa  sb   x
     -- ~~~~~~~~~~~~~~~~~~~
       [[1, 3,  5,  3,  12],
        [0, 0,  5,  3,  00],
        [1, 6,  2,  6,  35]]
     
     regfile_input2 :: [[Int]]
     regfile_input2 =
     -- ld  d  sa  sb   x
     -- ~~~~~~~~~~~~~~~~~~~
       [[1, 4,  0,  0,  29],
        [1, 3,  0,  4,  11],
        [0, 4,  4,  3,  13],
        [1, 6,  6,  3,  21],
        [1, 6,  6,  4,  15],
        [0, 1,  6,  4,  98]]
     
     
     sim_regfile input =
       let k = 4  -- there are 2^4 = 16 registers
           n = 16 -- each register contains 16 bits
           ld = getbit   input 0
           d  = getbin k input 1
           sa = getbin k input 2
           sb = getbin k input 3
           x  = getbin n input 4
           (a,b) = regfile n k ld d sa sb x
           simoutput :: [Format Bool]
           simoutput =
             [string "Input: ",
              bit ld, string " ", bindec 1 d, string " ",
              bindec 1 sa, string " ", bindec 1 sb,
              string " ", bindec 3 x,
              string "   Output: ",
              bindec 3 a, string " ", bindec 3 b]
       in do putStrLn "\nSimulating register file"
             run input simoutput


# Standard circuits

## Buffered Fanout

     fanoutbuf2 :: Signal a => a -> (a,a)
     fanoutbuf2 x = (y,y)
       where y = buf x

     fanoutbuf3 :: Signal a => a -> (a,a,a)
     fanoutbuf3 x = (y,y,y)
       where y = buf x

     fanoutbuf4 :: Signal a => a -> (a,a,a,a)
     fanoutbuf4 x = (y,y,y,y)
       where y = buf x


## Adder

Bit addition

-- myHalfAdd x y = (and2 x y, xor2 x y)

     halfAdd :: Signal a => a -> a -> (a,a)
     halfAdd x y = (and2 x y, xor2 x y)

     bsum, bcarry :: Signal a => (a,a) -> a -> a
     bsum (x,y) c = xor3 x y c
     bcarry (x,y) c = or3 (and2 x y) (and2 x c) (and2 y c)

     fullAdd :: Signal a => (a,a) -> a -> (a,a)
     fullAdd (x,y) c = (bcarry (x,y) c, bsum (x,y) c)



## Comparison


-- Bit comparison

     cmp1 :: Signal a => (a,a,a) -> (a,a) -> (a,a,a)
     cmp1 (lt,eq,gt) (x,y) =
       (or2 lt (and3 eq (inv x) y),
        and2 eq (inv (xor2 x y)),
        or2 gt (and3 eq x (inv y))
       )

-- Ripple comparison

     rippleCmp :: Signal a => [(a,a)] -> (a,a,a)
     rippleCmp = foldl cmp1 (zero,one,zero)




## Unbuffered Fanout


     fanout2 :: a -> (a,a)
     fanout2 x = (x,x)

     fanout3 :: a -> (a,a,a)
     fanout3 x = (x,x,x)

     fanout4 :: a -> (a,a,a,a)
     fanout4 x = (x,x,x,x)

Duplicating a bit to form a word: fanout takes a wordsize k and a
signal x, and produces a word of size k each of whose bits takes
the value of x.

     fanout :: Signal a => Int -> a -> [a]
     fanout k x = take k (repeat x)

***

user guide

Hydra User's Guide

This user's guide shows how to use Hydra to design digital circuits.

## level 2 Introduction

It's great

## Primitive components

Lots of them

## Combining components into circuits

Apply circuit to its inputs

.....


# old tutorial.txt


*Abstract.* This document is a tutorial introduction to Hydra, a
functional computer hardware description language (CHDL).  Hydra
allows you to describe digital circuits using a concise textual
notation, and it offers a variety of tools for assisting in the design
process.  Descriptions of circuits may include the behaviour, the
interconnection structure, or the geometric layout.  Hydra can
simulate circuits using behavioural models at several different levels
of detail.  It can generate circuit netlists, as well as perform
several analyses on the circuit structures.  There is a library of
useful building blocks, ranging from bit level to system level
circuits.  Hydra supports formal reasoning about circuits, including
correctness proofs, optimisations, and derivations.  Hydra is free
software, and is implemented by embedding in the standard functional
language Haskell.

## Introduction

Hydra is a functional computer hardware description language (CHDL).
It allows you to describe digital circuits using a concise textual
notation, and it offers a variety of tools for assisting in the design
process.  Descriptions of circuits may include the behaviour, the
interconnection structure, or the geometric layout.  Hydra can
simulate circuits using behavioural models at several different levels
of detail.  It can generate circuit netlists, as well as perform
several analyses on the circuit structures.  There is a library of
useful building blocks, ranging from bit level to system level
circuits.  Hydra supports formal reasoning about circuits, including
correctness proofs, optimisations, and derivations.  Hydra is free
software, and is implemented by embedding in the standard functional
language Haskell.

The Hydra documentation consists of this tutorial, a reference manual
and a collection of research papers.  To learn how to use the system,
this tutorial is the best starting place.  It works through a series
of examples that you can try at the computer as you read.  Each
chapter in the tutorial has a corresponding file in the examples
directory.

## Launching Hydra and loading a circuit specification


## Simulation

A circuit can be tested by fabricating it from physical electronic
devices, providing it with suitable input signals, and checking that
the output signals are correct.  Ultimately, this is the only way to
test hardware fully, but it is often more effective to use simulation
during the design process.

A circuit simulator is a program that reads in the values of the input
signals to a circuit, and predicts the outputs which the circuit would
produce.  A circuit simulator will not account for all possible
phenomina in the real circuit.  For example, a logic simulator will
model the signals as Boolean values, but will ignore electrical issues
such as capacitance.

Simulation allows for testing during development, and it speeds up
debugging a design since it's quicker to rerun a simulation than to
refabricate the hardware every time a modification is made to the
design.  Simulation is analogous to software testing. For complex
circuits it is infeasible to simulate using all possible inputs, it is
important to pick good test inputs in order to find as many problems
as possible.  Simulation tests cannot establish the correctness of a
circuit---only formal methods can do that---but they often provide the
fastest method for eliminating errors.  Simulation and formal
correctness proofs are complementary methods, and both are useful in
producing correct, robust designs.

There are several way to simulate circuits using Hydra.  This chapter
of the tutorial uses the simplest approach, where we consider only
combinational circuits, and use Booleans to model signal values.

A combinational circuit computes a pure logic function (for example,
the logical or of two Boolean inputs).  A combinational circuit cannot
have any internal state, because that could affect the output value.
Combinational circuits are restricted to contain just logic gates with
no feedback loops.  If a circuit contains feedback, or if it contains
any flip flops, then it is called sequential rather than
combinational.

There are several other forms of simulation not discussed in this
chapter.  For example, it is also possible to simulate combinational
circuits using a multi-value logic, allowing CMOS circuits to be
handled, and to use a semantic model that keeps track of gate delays,
allowing hazards to be analysed.  Sequential circuits also require
more complext techniques.  Some of the more advanced simulation
methods will be presented in later chapters.

## Applying a circuit to its inputs

Every circuit is modelled as a function.  To simulate a circuit, you
simply applying the function to suitable inputs.  This allows you to
carry out quick experiments on simple circuits, by choosing either
True or False for each input value.

There are two possible signal values: *True* and *False*.  An
expression of the form *circuit input1 input2* will calculate the
output of the circuit when its inputs are the given values.

We begin by simulating an inverter.  First, give the inverter an input
value of True, by writing the name of the circuit (i.e. inv) followed
by the value of its input (i.e. True).  The system performs the
simulation and prints the result, which is False.

    *Circ1> inv True
    False

Now try giving the inverter an input of False:

    *Circ1> inv False
    True

The 2-input logical and-gate is called and2.  To simulate it, apply
the circuit to two signal values:

    *Circ1> and2 True False
    False
    *Circ1> and2 True True
    True

Any combinational circuit can be simulated this way, not just logic
gates.  Here again is the first circuit:

    circ1 x y = and2 (inv x) y

This consists of a 2-input logical and-gate and an inverter.  We can
work out the behaviour of this circuit by simulating it on various
input values:

    *Circ1> circ1 False False
    False
    *Circ1> circ1 False True
    True
    *Circ1> circ1 True False
    False
    *Circ1> circ1 True True
    False

An expression like *circ1 False True* is called an *application*.
Applications are discussed in detail in the next chapter of the
tutorial.

## Generating Truth Tables

The behavior of a combinational circuit can be characterized precisely
by generating a truth table that shows the circuit's output for
arbitrary input values.  This is because combinational circuits lack
state, so the output is a pure function of the current input.
Naturally truth tables are useful only for circuits with a relatively
small number of inputs, since a circuit with $k$ inputs has a truth
table with $2^k$ lines.

A simple, though laborious, technique for generating a truth table
manually is to enter an expression denoting the circuit with all
possible input values, as we just did with circ1.

To make it easier to perform circuit simulations, Hydra provides a
variety of software tools that automate the task of generating truth
tables for a circuit.  One of these is the function *truthTable21*,
which generates the Boolean truth table for a 2-input, 1-output
circuit.  Just apply it to any circuit that takes two inputs and
produces one output, for example circ1:

    *Circ1> truthTable21 circ1
        0 0 | 0
        0 1 | 1
        1 0 | 0
        1 1 | 0
    *Circ1>

The signal values in the truth table are given as 0, 1 because this is
more readable and more concise than False, True.  In the Bool
simulation model, the actual calculations are still being done with
Boolean values (False or True).  The presentation with digits is just
a matter of formatting the output.

The "21" at the end of the name "truthTable21" indicates that a
circuit with two inputs and one output is expected.  A family of
similar functions can be used for circuits with various small numbers
of inputs and outputs.  These include the following:

For example, entering *truthTable31 xor3* will produce the truth table
for the three-input exclusive or gate, named *xor3*:

    *Circ1> truthTable31 xor3
        0 0 0 | 0
        0 0 1 | 1
        0 1 0 | 1
        0 1 1 | 0
        1 0 0 | 1
        1 0 1 | 0
        1 1 0 | 0
        1 1 1 | 1
    *Circ1>

The Circ1.hs file contains this definition of circ2:

    circ2 x y z = (or2 x y, xor2 x z)

This circuit takes three inputs and produces two outputs, so it can be
simulated using truthTable32.

    *Circ1> truthTable32 circ2
        0 0 0 | 0 0
        0 0 1 | 0 1
        0 1 0 | 1 0
        0 1 1 | 1 1
        1 0 0 | 1 1
        1 0 1 | 1 0
        1 1 0 | 1 1
        1 1 1 | 1 0

The second line of the file Circ1.hs ("import Hydra") causes the
Hydra circuit library to be loaded automatically.  This library
defines a half adder circuit, which also takes two inputs and produces
two outputs.  The half adder can be simulated just like the example
above:

    *Circ1> truthTable22 halfAdd
        0 0 | 0 0
        0 1 | 0 1
        1 0 | 0 1
        1 1 | 1 0

In summary, if you have a combinational circuit *circ* that takes *m*
inputs and produces *n* outputs, you can generate its truth table by
writing *truthTablemn circ*, as long as *m* and *n* are reasonably
small.

*Exercise.* Generate the following truth tables:

    truthTable21 or2
    truthTable31 nand3
    truthTable41 xor4
    truthTable22 halfAdd

*Exercise.* Produce a truth table for the xor3 logic gate.

*Exercise.* Calculate the truth table for the following circuit:

    circuit1b x y z = (a, xor2 a b)
      where a = and3 x y z
            b = or2 y z

*Exercise.* Calculate the truth table for the following circuit:

    circuit1a a b c = inv (xor2 (and2 a b) (or2 b c))


---------------------------------------------------------------------------
# Defining new circuits

## Making connections

A circuit consists of a set of components that are connected by wires.
A circuit specification says what components are present, and how they
are connected by the wires.

Each component has a name; thus and2 denotes a 2-input logical
and-gate.  When you use a component in a circuit, that component acts
as a black box: it doesn't matter whether the component is a primitive
(such as and2) or another circuit with internal components and wires
(such as circ1 or halfAdd in the previous chapter).  Indeed, the and2
gate may itself be defined using lower level components such as
transistors.

Each component has a fixed set of input ports and output ports.  Each
output port must be connected to a wire, and the component puts a
value onto that wire.  Each input port must be connected to a wire,
and the component receives the value on that wire (which will be put
there by some component)

We will often use the word *signal* to refer to a wire.  A signal is a
slightly more abstract concept, which emphasizes the value carried by
the wire but downplays the physical characteristics of the wire.  For
example, you might connect two bits of wire together to form a T
connection, but this would be thought of as just one signal.

Signals in a circuit may have names, which are ordinary identifiers
(starting with a lower case letter).  It is also possible to introduce
signals with no name; these are called anonymous signals.  Typical
signal names are x, y, z.  There are two constant signals, whose names
are zero, one.

Components and the signals that connect them are specified by writing
expressions called *applications*.  An application
consists of the component followed by its inputs. For example,

    nor3 p q r

says that there is an nor3 gate, its first input is connected to the
signal named p, its second input is the signal q, and its third input
is the signal r.

figures/xfig/nor3pqr.png

figures/xfig/nor3pinvqr.png"

Now suppose that we need to invert the second input to the nor3 gate.
This is done by introducing an inverter, and connecting its input to
q.  That is described by the application *inv q*, and the value of the
application is the output signal produced by the inverter.  This
becomes the second input to the nor3 gate:

    nor3 p (inv q) r

It was necessary to put parentheses around the second input to the
nor3 gate, because several symbols were needed to describe it.
Suppose the parentheses had been omitted, like this:

    nor3 p inv q r     -- Wrong!

This application says that the nor3 gate has its first input connected
to a signal named p, its second input connected to a signal named inv
(but there isn't a signal named inv, that's the name of a component),
and its third input connected to a signal named q.  There is an extra
dangling signal r that isn't connected to anything.  And there isn't a
signal named inv; that is the name of a component, not a signal.

figures/xfig/nor3pinvqrErr.png

Hydra uses parentheses to express grouping, just as in mathematics.
In general, if it takes just one symbol to describe a signal, don't
put it in parentheses (unless you really want to).  But if several
symbols are needed to describe one signal, you need parentheses to
indicate that this group of symbols really denotes just one value.

Some programming languages (especially older ones) require lots of
punctuation to indicate arguments to a function, so you might be
tempted to write something like

    nor3 (p,q,r);      -- Wrong!  This will give a type error message

However, Hydra does not require parentheses and commas just to
indicate the arguments to a function.  Later we will see a different
construct in Hydra where we will write expressions like (p,q,r), but
this has a different meaning.  Extra punctuation is not required when
applying a component to its inputs, apart from parentheses to indicate
when several symbols describe just one argument.

Since parentheses indicate grouping, just as in mathematics, it is
legal to put extra parentheses around a value.  But it looks silly:

    nor3 p q r         -- Right
    nor3 (p) (q) (r)   -- Legal, but looks silly
    nor3 (p,q,r)       -- Wrong

These extra punctuation symbols just make your circuit specification
look like it was written by somebody who doesn't know the language.
Side comment: if you know C or Java, consider the following statement:

    x = 2*y;

Now, the following is also valid C or Java, but the extra parentheses
don't serve any useful purpose, and are best omitted:

    x = ((2)*(y));

In the following example, there is a nor3 gate where all of the inputs
are outputs of other logic gates.  Therefore they all need
parentheses.

    nor3 (and2 p1 p1) (inv q) (or2 r s)

figures/xfig/norandinvor.png

## Signal Definition Equations

Five signals are involved in the following application:

    nor3 p (inv q) r

These are p, q, the output of the inverter, r, and the output of the
nor3 gate.  The output of the inverter and the output of the nor3 gate
are anonymous: they do not have names, but are described by
applications instead.

*Signal definition equations* are used to give names to signals. For
example, the following equation gives the name x to the output of the
nor3 gate:

    x = nor3 p (inv q) r

A signal definition equation is written in the form *lhs = rhs*, where
the left hand side lhs is a name, and the right hand side rhs is a
signal value.  Here is another example:

    q' = inv q

The right hand side can be just a signal name, so the following two
equations are ok.  The first equation says that a can be used as
another name for the signal that is already named q, whie the second
equation says that b has the constant value zero.  (Note that b = 0
would be incorrect.)

    a = q
    b = zero

The left hand side must be a signal name.  You can't write an equation
like this:

    or2 a b = and2 x y

Signal definition equations are not like arbitrary algebraic
equations; they simply say that a signal has a given name.

---------------------------------------------------------------------------
## The xml tutorial text is inserted below


Introduction


This chapter of the tutorial uses examples/Tu01int.hs.


Launching Hydra


It's convenient to set the environment variable $HYDRA to the location
of the implementation, giving you quick access to the examples and
other source files.  For example, if you're using the Bash shell in
Gnu/Linux, you could put a line similar to the following in your
.bashrc file (replace the ... with the actual location):



HYDRA=.../Hydra-0.1.7/
export HYDRA



Next, use the following shell commands to create a working directory
for your circuit specifications, and copy the sample file
<emphasis>Tut1int.hs</emphasis> (which appears in the examples
directory) into it.  Of course, the working directory doesn't have to
be named circuits, and you can put it anywhere you like in your file
space.



mkdir circuits
cd circuits
cp $HYDRA/examples/Tut1int.hs .



Now launch the Hydra system.  This is done by launching the host
compiler, ghci, with a command line argument telling it to load the
Hydra package.



ghci -package HydraCHDL



If several versions of Hydra are installed on your system, there will
be an error message saying "Error: multiple packages match HydraCHDL",
followed by a list of the versions that are installed.  If this case,
you need to give the version number that you want, for example:



ghci -package HydraCHDL-0.1.7



The Haskell system should launch and print a welcome banner:
</para>




Loading a circuit specification file


After launching the system, you need to read in a file that describes
the circuit you're currently working on.  A sample file named
Tut1int.hs is located in the directory $HYDRA/examples.  Assuming that
you have copied that file into your own working directory, as shown
above, you can load it with the following command:



:load Tu01int



The system replies that the module has been loaded, and the prompt
is changed to tell you which circuit specification file is
currently in use.



Prelude> :load Tu01int
Compiling Tu01int      ( Tu01int.hs, interpreted )
Ok, modules loaded: Tu01int.
*Tu01int>



The text of the file is:



module Tu01int where
import Hydra

circ1 x y = and2 (inv x) y

circ2 x y z = (or2 x y, xor2 x z)

figure tut1-circ1



The contents of this file are discussed in detail later.  For now,
it's useful to know that the line <emphasis>circ1 x y = and2 (inv x)
y</emphasis> specifies a circuit with name circ1, inputs x and y, and
an output produced by a 2-input logical and gate.  The first input to
the and gate is the output of an inverter with input x, and the second
input to the and gate is y.  Here is a schematic diagram of circ1:




The ghci system provides many useful interactive commands, including
:load.  You can get a complete list by entering :? and you can
terminate the system by entering :quit (or just :q).  You can also
type part of a command and press the tab key; ghci will complete the
command, if possible.  Try entering ":load Tu01" followed by tab.




Simulation


A circuit can be tested by fabricating it from physical electronic
devices, providing it with suitable input signals, and checking that
the output signals are correct.  Ultimately, this is the only way to
test hardware fully, but it is often more effective to use simulation
during the design process.



A circuit simulator is a program that reads in the values of the input
signals to a circuit, and predicts the outputs which the circuit would
produce.  A circuit simulator will not account for all possible
phenomina in the real circuit.  For example, a logic simulator will
model the signals as Boolean values, but will ignore electrical issues
such as capacitance.



Simulation allows for testing during development, and it speeds up
debugging a design since it's quicker to rerun a simulation than to
refabricate the hardware every time a modification is made to the
design.  Simulation is analogous to software testing. For complex
circuits it is infeasible to simulate using all possible inputs, it is
important to pick good test inputs in order to find as many problems
as possible.  Simulation tests cannot establish the correctness of a
circuit---only formal methods can do that---but they often provide the
fastest method for eliminating errors.  Simulation and formal
correctness proofs are complementary methods, and both are useful in
producing correct, robust designs.



There are several way to simulate circuits using Hydra.  This chapter
of the tutorial uses the simplest approach, where we consider only
combinational circuits, and use Booleans to model signal values.



A combinational circuit computes a pure logic function (for example,
the logical or of two Boolean inputs).  A combinational circuit cannot
have any internal state, because that could affect the output value.
Combinational circuits are restricted to contain just logic gates with
no feedback loops.  If a circuit contains feedback, or if it contains
any flip flops, then it is called sequential rather than
combinational.



There are several other forms of simulation not discussed in this
chapter.  For example, it is also possible to simulate combinational
circuits using a multi-value logic, allowing CMOS circuits to be
handled, and to use a semantic model that keeps track of gate delays,
allowing hazards to be analysed.  Sequential circuits also require
more complext techniques.  Some of the more advanced simulation
methods will be presented in later chapters.




Applying a Circuit to its Inputs



In Hydra, every circuit is modelled as a function.  To simulate a
circuit, you simply applying the function to suitable inputs.  This
allows you to carry out quick experiments on simple circuits, by
choosing either True or False for each input value.



There are two possible signal values: <emphasis>True</emphasis> and
<emphasis>False</emphasis>.  An expression of the form
<emphasis>circuit input1 input2</emphasis> will calculate the output
of the circuit when its inputs are the given values.



We begin by simulating an inverter.  First, give the inverter an input
value of True, by writing the name of the circuit (i.e. inv) followed
by the value of its input (i.e. True).  The system performs the
simulation and prints the result, which is False.



*Tu01int> inv True
False



Now try giving the inverter an input of False:



*Tu01int> inv False
True



The 2-input logical and-gate is called and2.  To simulate it, apply
the circuit to two signal values:



*Tu01int> and2 True False
False
*Tu01int> and2 True True
True



Any combinational circuit can be simulated this way, not just logic
gates.  Here again is the first circuit defined in the Tu01.int.hs
file:



circ1 x y = and2 (inv x) y



This consists of a 2-input logical and-gate and an inverter, connected
as follows:




We can work out the behaviour of this circuit by simulating it on
various input values:



*Tu01int> circ1 False False
False
*Tu01int> circ1 False True
True
*Tu01int> circ1 True False
False
*Tu01int> circ1 True True
False



An expression like <emphasis>circ1 False True</emphasis> is called an
<emphasis>application</emphasis>.  Applications are discussed in
detail in the next chapter of the tutorial.




Generating Truth Tables


The behavior of a combinational circuit can be characterized precisely
by generating a truth table that shows the circuit's output for
arbitrary input values.  This is because combinational circuits lack
state, so the output is a pure function of the current input.
Naturally truth tables are useful only for circuits with a relatively
small number of inputs, since a circuit with $k$ inputs has a truth
table with $2^k$> lines.



A simple, though laborious, technique for generating a truth table
manually is to enter an expression denoting the circuit with all
possible input values, as we just did with circ1.



To make it easier to perform circuit simulations, Hydra provides a
variety of software tools that automate the task of generating truth
tables for a circuit.  One of these is the function
<emphasis>truthTable21</emphasis>, which generates the Boolean truth
table for a 2-input, 1-output circuit.  Just apply it to any circuit
that takes two inputs and produces one output, for example circ1:



*Tu01int> truthTable21 circ1
    0 0 | 0
    0 1 | 1
    1 0 | 0
    1 1 | 0
*Tu01int>



The signal values in the truth table are given as 0, 1 because this is
more readable and more concise than False, True.  In the Bool
simulation model, the actual calculations are still being done with
Boolean values (False or True).  The presentation with digits is just
a matter of formatting the output.



The "21" at the end of the name "truthTable21" indicates that a
circuit with two inputs and one output is expected.  A family of
similar functions can be used for circuits with various small numbers
of inputs and outputs.  These include the following:



For example, entering <emphasis>truthTable31 xor3</emphasis> will
produce the truth table for the three-input exclusive or gate, named
<emphasis>xor3</emphasis>:



*Tu01int> truthTable31 xor3
    0 0 0 | 0
    0 0 1 | 1
    0 1 0 | 1
    0 1 1 | 0
    1 0 0 | 1
    1 0 1 | 0
    1 1 0 | 0
    1 1 1 | 1
*Tu01int>



The Tu01int.hs file contains this definition of circ2:



circ2 x y z = (or2 x y, xor2 x z)



This circuit takes three inputs and produces two outputs, so it can be
simulated using truthTable32.



*Tu01int> truthTable32 circ2
    0 0 0 | 0 0
    0 0 1 | 0 1
    0 1 0 | 1 0
    0 1 1 | 1 1
    1 0 0 | 1 1
    1 0 1 | 1 0
    1 1 0 | 1 1
    1 1 1 | 1 0



The second line of the file Tu01int.hs ("import Hydra") causes the
Hydra circuit library to be loaded automatically.  This library
defines a half adder circuit, which also takes two inputs and produces
two outputs.  The half adder can be simulated just like the example
above:



*Tu01int> truthTable22 halfAdd
    0 0 | 0 0
    0 1 | 0 1
    1 0 | 0 1
    1 1 | 1 0



In summary, if you have a combinational circuit
<emphasis>circ</emphasis> that takes <emphasis>m</emphasis> inputs and
produces <emphasis>n</emphasis> outputs, you can generate its truth
table by writing <emphasis>truthTablemn circ</emphasis>, as long as
<emphasis>m</emphasis> and <emphasis>n</emphasis> are reasonably
small.



<emphasis>Exercise.</emphasis>
Generate the following truth tables:

truthTable21 or2
truthTable31 nand3
truthTable41 xor4
truthTable22 halfAdd




<emphasis>Exercise.</emphasis>
Produce a truth table for the xor3 logic gate.



<emphasis>Exercise.</emphasis>
Calculate the truth table for the following circuit:

circuit1b x y z = (a, xor2 a b)
  where a = and3 x y z
        b = or2 y z



<emphasis>Exercise.</emphasis>
Calculate the truth table for the following circuit:

circuit1a a b c = inv (xor2 (and2 a b) (or2 b c))



Tu2def.hs: Defining new circuits

Making connections

<para>
A circuit consists of a set of components that are connected by wires.
A circuit specification says what components are present, and how they
are connected by the wires.
</para>

<para>
Each component has a name; thus and2 denotes a 2-input logical
and-gate.  When you use a component in a circuit, that component acts
as a black box: it doesn't matter whether the component is a primitive
(such as and2) or another circuit with internal components and wires
(such as circ1 or halfAdd in the previous chapter).  Indeed, the and2
gate may itself be defined using lower level components such as
transistors.
</para>

<para>
Each component has a fixed set of input ports and output ports.  Each
output port must be connected to a wire, and the component puts a
value onto that wire.  Each input port must be connected to a wire,
and the component receives the value on that wire (which will be put
there by some component)
</para>

<para>
We will often use the word <emphasis>signal</emphasis> to refer to a
wire.  A signal is a slightly more abstract concept, which emphasizes
the value carried by the wire but downplays the physical
characteristics of the wire.  For example, you might connect two bits
of wire together to form a T connection, but this would be thought of
as just one signal.
</para>

<para>
Signals in a circuit may have names, which are ordinary identifiers
(starting with a lower case letter).  As we will see later, it is also
possible to introduce signals with no name; these are called anonymous
signals.  Typical signal names are x, y, z.  There are two constant
signals, whose names are zero, one.
</para>

<para>
Components and the signals that connect them are specified by writing
expressions called <emphasis>applications</emphasis>.  An application
consists of the component followed by its inputs. For example,

<programlisting>
nor3 p q r
</programlisting>

says that there is an nor3 gate, its first input is connected to the
signal named p, its second input is the signal q, and its third input
is the signal r.
</para>


<para>
  <inlinemediaobject>
    <imageobject>
      <imagedata fileref="figures/xfig/nor3pqr.png" format="PNG" />
    </imageobject>
    <imageobject>
	<imagedata fileref="figures/xfig/nor3pqr.eps" format="EPS" />
    </imageobject>
  </inlinemediaobject>
</para>


<para>
  <inlinemediaobject>
    <imageobject>
      <imagedata fileref="figures/xfig/nor3pinvqr.png" format="PNG" />
    </imageobject>
    <imageobject>
	<imagedata fileref="figures/xfig/nor3pinvqr.eps" format="EPS" />
    </imageobject>
  </inlinemediaobject>
</para>


<para>
Now suppose that we need to invert the second input to the nor3 gate.
This is done by introducing an inverter, and connecting its input to
q.  That is described by the application <emphasis>inv q</emphasis>,
and the value of the application is the output signal produced by the
inverter.  This becomes the second input to the nor3 gate:
</para>

<programlisting>
nor3 p (inv q) r
</programlisting>


<para>
It was necessary to put parentheses around the second input to the
nor3 gate, because several symbols were needed to describe it.
Suppose the parentheses had been omitted, like this:

<programlisting>
nor3 p inv q r     -- Wrong!
</programlisting>

This application says that the nor3 gate has its first input connected
to a signal named p, its second input connected to a signal named inv
(but there isn't a signal named inv, that's the name of a component),
and its third input connected to a signal named q.  There is an extra
dangling signal r that isn't connected to anything.  And there isn't a
signal named inv; that is the name of a component, not a signal.
</para>

<para>
  <inlinemediaobject>
    <imageobject>
      <imagedata fileref="figures/xfig/nor3pinvqrErr.png" format="PNG" />
    </imageobject>
    <imageobject>
	<imagedata fileref="figures/xfig/nor3pinvqrErr.eps" format="EPS" />
    </imageobject>
  </inlinemediaobject>
</para>

<para>
Hydra uses parentheses to express grouping, just as in mathematics.
In general, if it takes just one symbol to describe a signal, don't
put it in parentheses (unless you really want to).  But if several
symbols are needed to describe one signal, you need parentheses to
indicate that this group of symbols really denotes just one value.
</para>

<para>
Some programming languages (especially older ones) require lots of
punctuation to indicate arguments to a function, so you might be
tempted to write something like

<programlisting>
nor3 (p,q,r);      -- Wrong!
</programlisting>

However, Hydra does not require parentheses and commas just to
indicate the arguments to a function.  Later we will see a different
construct in Hydra where we will write expressions like (p,q,r), but
this has a different meaning.  Extra punctuation is not required when
applying a component to its inputs, apart from parentheses to indicate
when several symbols describe just one argument.
</para>

<para>
Since parentheses indicate grouping, just as in mathematics, it is
legal to put extra parentheses around a value.  But it looks silly:
</para>

<programlisting>
nor3 p q r         -- Right
(nor3) (p) (q) (r)   -- Legal, but looks silly
(((((nor3))))) ((p)) (q) (((((((((r)))))))))   -- Still legal, still silly
</programlisting>

<para>
These extra punctuation symbols just make your circuit specification
look like it was written by somebody who doesn't know the language.
Side comment: if you know C or Java, consider the following statement:
</para>

<programlisting>
x = 2*y;
</programlisting>

<para>
Now, the following is also valid C or Java, but the extra parentheses
don't do any good at all:
</para>

<programlisting>
x = ((2)*(y));
</programlisting>

<para>
In the following example, there is a nor3 gate where all of the inputs
are outputs of other logic gates.  Therefore they all need
parentheses.
</para>

<programlisting>
nor3 (and2 p1 p1) (inv q) (or2 r s)
</programlisting>

<para>
  <inlinemediaobject>
    <imageobject>
      <imagedata fileref="figures/xfig/norandinvor.png" format="PNG" />
    </imageobject>
    <imageobject>
	<imagedata fileref="figures/xfig/norandinvor.eps" format="EPS" />
    </imageobject>
  </inlinemediaobject>
</para>

</sect1>

<sect1><title>Signal Definition Equations</title>

<para>
Five signals are involved in the following application:

<programlisting>
nor3 p (inv q) r
</programlisting>

These are p, q, the output of the inverter, r, and the output of the
nor3 gate.  The output of the inverter and the output of the nor3 gate
are anonymous: they do not have names, but are described by
applications instead.
</para>

<para>
<emphasis>Signal definition equations</emphasis> are used to give
names to signals. For example, the following equation gives the name x
to the output of the nor3 gate:
</para>

<programlisting>
x = nor3 p (inv q) r
</programlisting>

<para>
A signal definition equation is written in the form <emphasis>lhs =
rhs</emphasis>, where the left hand side lhs is a name, and the right
hand side rhs is a signal value.  Here is another example:
</para>

<programlisting>
q' = inv q
</programlisting>

<para>
The right hand side can be just a signal name, so the following two
equations are ok.  The first equation says that a can be used as
another name for the signal that is already named q, whie the second
equation says that b has the constant value zero.  (Note that b = 0
would be incorrect.)
</para>

<programlisting>
a = q
b = zero
</programlisting>

<para>
The left hand side must be a signal name.  You can't write an equation
like this:
</para>

<programlisting>
or2 a b = and2 x y
</programlisting>

<para>
Signal definition equations are not like arbitrary algebraic
equations; they simply say that a signal has a given name.
</para>

</sect1>

<sect1><title>Circuit Definition Equations</title>

<para>
A circuit is a collection of components connected together with wires.
An input to a component may be either a constant signal (zero or one),
or an output produced by some other component and transmitted by a
wire.
</para>

<para>
So far, we have been specifying circuits by mentioning every component
explicitly.  If a circuit design is useful, however, we would like to
be able to design it once and for all, and then reuse it as often as
needed.
</para>

<para>
Reusability is achieved by <emphasis>black box abstraction</emphasis>.
The idea is that a circuit is specified, its interface (how to use it)
is defined, and the specification is given a name.  The circuit can
then be reused many times, and each reuse will introduce a fresh set
of components into the circuit.
</para>

<para>
Black box abstraction in hardware design is similar to procedural or
functional abstraction in programming languages: instead of writing a
common set of statements many times, you define a procedure containing
the statements, and can then call the procedure as often as necessary.
</para>


<para>
The simplest form of a circuit definition equation is <emphasis>lhs =
rhs</emphasis>, where the right hand side is a signal value, and the
left hand side is an application of the circuit's names to the
internal names of its inputs.  Here is an example:
</para>

<programlisting>
circ1 p q r = nor3 p (inv q) r
</programlisting>

<para>
  <inlinemediaobject>
    <imageobject>
      <imagedata fileref="figures/xfig/bboxnorpinvqr.png" format="PNG" />
    </imageobject>
    <imageobject>
	<imagedata fileref="figures/xfig/bboxnorpinvqr.eps" format="EPS" />
    </imageobject>
  </inlinemediaobject>
</para>

<para>
This equation defines the circuit named <emphasis>circ1</emphasis>.
It gives local names p, q, r to the input signals (which could have
different names elsewhere in the circuit).  The output of the circuit
is the value on the right hand side of the equation, i.e. the output
of the nor3 gate.  The expression giving the circuit's output can use
p, q, r to refer to the values of the input signals.
</para>

<para>
Now that circ1 has been defined, it can be simulated just like any
other component:
</para>

<programlisting>
truthTable31 circ1
</programlisting>

<para>
Defining new circuits allows us to build up a set of useful building
blocks. A typical example is the multiplexor, called mux1, which takes
a control bit c and two data bits x, y.  The multiplexor uses c to
determine which of the data bits to output.  Its behavior can be
described informally as
</para>

<programlisting>
output = if c=zero then x else y
</programlisting>

<para>
It is straightforward to verify that this circuit implements a
multiplexor correctly:
</para>

<programlisting>
mux1 c x y = or2 (and2 (inv c) x) (and2 c y)
</programlisting>

<para>
The defining equation has given the name mux1 to the circuit, and we
can use it just like any other component:
</para>

<programlisting>
mux1 (and2 a b) x (inv y)
</programlisting>

<para>
Hydra provides a library of common circuits, including mux1, and a
later chapter in the tutorial shows how to use them.
</para>

<para>
Some of the circuits we have defined contain internal signals, but
these have all been anonymous.  Sometimes it is helpful to give names
to some of the internal signals, using signal defining equations.
This is done using a more general form of the circuit defining
equation:
</para>

<programlisting>
circuit_name inputs = output
  where signal_equation
        signal_equation
        ...
        signal_equation
</programlisting>

<para>
For example, suppose that we wanted to give names to a couple of the
internal signals in the definition of the multiplexor.  This could be
done using a "where" clause:
</para>

<programlisting>
mux1 c x y = or2 p q
  where p = and2 (inv c) x
        q = and2 c y
</programlisting>

<para>
This second version of the multiplexor describes exactly the same
circuit; there is no difference in the hardware, and there is no
difference in how the circuit is used.  The only difference is in the
notation.  The first version is shorter, while the second provides
names p and q that could be used in documentation to help explain how
the circuit works.  Names are not part of the hardware; they are just
part of the notation.
</para>

<para>
Internal signal names can be used to specify that one signal is to be
shared (this is called fanout).  Compare the following two
specifications:
</para>

<programlisting>
circ5 a b c = xor2 q r
  where a' = inv a
        q = and2 a' b
        r = and2 a' c

circ6 a b c = xor2 q r
  where q = and2 (inv a) b
        r = and2 (inv a) c
</programlisting>

<para>
In circ5 there is just one inverter, and its output goes to both and2
gates.  In circ6 there are two inverters, and the input a goes to both
of those.  Thus circ6 requires the input signal a to drive two gates,
while in circ 5 the inverter has to drive two gates.
</para>

</sect1>

<sect1><title>Groups of Signals</title>

<para>
Circuits often contain groups of signals that belong together.  It is
often possible to make a circuit design clearer, more concise, and
more readable by giving a name to a group of signals and to treat it
as a single entity, rather than naming all the individual signals.  In
the physical circuit the signals comprising a group actually
correspond to completely independent wires, but the designer may
prefer to think of them more abstractly as a single value, such as a
binary number.
</para>

<para>
Hydra provides two mechanisms for grouping signals together: tuples
and words.  Tuples are used to group signals together when the
individual components have different purposes, while words are used to
represent binary numbers, addresses, and so on.
</para>

<para>
There are a number of operations that can be applied to tuples and
words, such as extracting individual signals from a group.  It is
important to remember that operations on signal groups are purely
notational techniques, but they do not correspond to actualy
components in a circuit.
</para>

<sect2><title>Tuples</title>

<para>
Tuples are used to group together signals that are related to each
other, but which do not represent the bits in a number.  The syntax
for tuples requires the signals to be separated by commas, and the
entire tuple is surrounded by parentheses (round brackets).  For
example, if x and y are signals, then (x,y) is a tuple containing them
both.
</para>

<para>
Tuples are useful when a circuit has several outputs.  A circuit
defining equation specifies just one output, but that output can be a
tuple comprising several bits.  For example, the half adder circuit,
halfAdd, computes the sum of two bits x and y.  The sum could be 0, 1,
or 2, so it takes two bits to represent the result.  A standard
solution is to use two bits called carry and sum, or just c and s, so
that the numeric value of the result is 2 * c + s.  Since the half
adder's output is two bits, but the defining equation has just one
right hand side, we need to gather the output bits into a tuple
(carry, sum):
</para>

<programlisting>
halfAdd x y = (and2 x y, xor2 x y)
</programlisting>

<para>
An alternative way to define this is to give internal names to the two
result bits:
</para>

<programlisting>
halfAdd x y = (c,s)
  where c = and2 x y
        s = xor2 x y
</programlisting>

<para>
Both definitions yield the same circuit; the difference is just a
matter of style.
</para>

<para>
A tuple may have any number of components.  Thus (a,b) is a 2-tuple,
or pair, (a,b,c) is a 3-tuple or triple, and so on.  A tuple cannot
have just one element; if you write (a) this means just the signal
$a$.  (This is because anything written in parentheses
<emphasis>without</emphasis> commas inside is just an expression.)
However, the empty 0-tuple (), which is a group containing no signals,
is allowed, and later we will see some situations where it is useful.
</para>

<para>
The half adder definition used a tuple to gather several results into
one value.  We can give a name to the tuple produced by a half adder
with a signal definition equation:
</para>

<programlisting>
result = halfadd x y
</programlisting>

<para>
This equation says that result is a pair of signals, and they can be
connected to a circuit that requires a pair of signals using an
ordinary application:
</para>

<programlisting>
circ result
</programlisting>

<para>
Alternatively, we can use a tuple pattern in a signal defining
equation in order to give names to the components of the tuple, rather
than to the whole tuple:
</para>

<programlisting>
(p,q) = halfadd x y
</programlisting>

<para>
Using this equation, p is the name of the carry output, and q is the
name of the sum output.
</para>

</sect2>

<sect2><title>Words</title>

<para>
A word is a group of bits that can be accessed by index.  Words are
used to represent binary numbers, twos complement numbers, addresses,
fields of floating point numbers, and so on.
</para>

<para>
In Hydra, a word is written by separating the individual bits with
commas, and enclosing the whole word in square brackets [ ].  For
example, suppose that a, b, c and d are ordinary bit signals.  Then a
4-bit word could be written as
</para>

<programlisting>
[a, b, c, d]
</programlisting>

<para>
Typically, there is no need for distinctive names for the bits in a
word, so we will often use names that contain the index:
</para>

<programlisting>
[x0, x1, x2, x3]
</programlisting>

<para>
Usually we will use a single name for an entire word.  You can give a
name to a word using a signal defining equation:
</para>

<programlisting>
w = [x0, x1, x2, x3]
</programlisting>

<para>
Now w can be provided as an input to a circuit, without having to
mention every bit individually.  This is a big time saver, especially
for words with 32 or 64 bits.

wiring patterns

Indexing !!

w !! 2 => x2


lsb gives the least significant (rightmost) bit of a word, and msb
gives the most significant (leftmost) bit.



Concatenation ++

head, tail

Attaching an element :

Pattern matching [a,b,c]

Pattern matching :
</para>


<para>
Shift a word to the right (shr) or to the left (shl).  In both
cases, this is just a wiring pattern.  A 0 is brought in on one
side, and the bit on the other side is just thrown away.
</para>

<programlisting>
> shr x = zero : [x!!i | i FROM- [0..k-2]]
>   where k = length x
> shl x = [x!!i | i FRM [1..k-1]] ++ [zero]
>   where k = length x
</programlisting>


<programlisting>

</programlisting>

<para>


\item \textbf{msb} Most significant bit\\
  Type: $\mathit{msb} :: [a] \rightarrow a$ \\
  Usage: $y = \mathit{msb}\ \mathit{xs}$ \\
  This is a wiring pattern that gives the most significant (leftmost)
  position of a word.  If $\mathit{xs} = [x_0, \ldots, x_{k-1}]$ then
  $\mathit{msb}\ \mathit{xs} = x_0$ It is an error to take the least
  significant position of an empty word: $\mathit{msb}\ []$ will
  produce an error.

\item \textbf{(:)} \\
  Type: $(:) :: a \rightarrow [a] \rightarrow [a]$ \\
  Usage: $\mathit{ys} = x : \mathit{xs}$ \\
  This wiring pattern produces the word obtained by attaching the
  singleton element $x$ onto the front of the word $\mathit{xs}$.  The
  element type of $x$ must be the same as the types of the elements of
  $\mathit{xs}$.  For example, \[(a,b) : [(x_0,y_0), (x_1,y_1),
  (x_2,y_2)] = [(a,b), (x_0,y_0), (x_1,y_1), (x_2,y_2)].\]

\item \textbf{(!!)} \\
  Type: $(!!) :: [a] \rightarrow a$ \\
  Usage: $x = \mathit{xs}!!i$ \\
  This wiring pattern gives the $i$th signal in a word, where the
  leftmost bit has index 0.  If $\mathit{xs} = [x_0, x_1, \ldots,
  x_{k-1}]$, then $\mathit{xs}!!i = x_i$ provided that $0 \leq i LT k$.

\item \textbf{(\plusplus)} \\
  Type: $(\plusplus) :: [a] \rightarrow [a] \rightarrow [a]$ \\
  Usage: $\mathit{xs} \plusplus \mathit{ys}$ \\
  This operator is written as two consecutive + symbols, and it
  denotes a wiring pattern that concatenates two words to form one
  larger word. \[[x_0, \ldots, x_{j-1}] \plusplus [y_0, \ldots,
  y_{k-1}] = [x_0, \ldots, x_{j-1}, y_0, \ldots, y_{k-1}].\]

\item \textbf{field} \\
  Type: $\mathit{field} :: [a] \rightarrow Int \rightarrow Int
  \rightarrow [a]$ \\
  Usage: $\mathit{ys} = \mathit{field}\ \mathit{xs}\ j\ k$ \\
  The wiring pattern extracts a subfield from $\mathit{xs}$, starting
  at bit position $j$ (where the leftmost bit has index 0) and with
  length $k$.  Provided that $\mathit{xs}$ is long enough, the value
  of $\mathit{ys}$ is $[x_j, x_{j+1}, \ldots, x_{j+k-1}]$.  For
  example, if $\mathit{xs} = [x_0, x_1, \ldots, x_{15}]$, then
  $\mathit{field}\ \mathit{xs}\ 8\ 4 = [x_8, x_9, x_{10}, x_{11}]$.
\item $winv :: Signal a \Rightarrow [a] \rightarrow [a]$
\end{itemize}


\item $boolword :: Signal a \Rightarrow Int \rightarrow a \rightarrow [a]$ \\
  Representing a boolean bit as a word: boolword takes a bit x, and
  pads it to the left with 0s to form a word.  If the input x is False
  (0), the result is the integer 0 (i.e. n 0-bits), and if x is True
  (1) the result is the integer 1 (rightmost bit is 1, all others are
  0).


Determine whether there exists a 1 in a word, or whether all the bits
are 0.  A tree fold can do this in log time, but for simplicity this
is just a linear time fold.

\item $any1, all0 :: Signal a \Rightarrow [a] \rightarrow a$

</para>
</sect2>
</sect1>

<sect1><title>Types</title>

<para>
It is important to provide the correct number of inputs to any
component.  You cannot provide three inputs to a logic gate with only
two input ports, and you should always ensure that all inputs to a
logic gate are connected to a signal.
</para>

<para>
Sometimes it's quicker to copy and paste a simulation expression than
to type it in manually.  For example, use the mouse to select the
expression <emphasis>nand2 (or2 True False) (xor2 False True)</emphasis>
and then use your web browser to copy the text.  Paste the text into
the shell window where Hydra is running, and press return.  The result
should look like this:
</para>

<programlisting>*BoolModel> nand2 (or2 True False) (xor2 False True)
False
</programlisting>

<para>
The copy and paste technique can save retyping complex expressions,
and is often useful for running some quick examples or test cases that
are embedded in a documentation file.
</para>



<para>
A specification consists of two parts: (1) the type specification,
which is optional, and (2) the behaviour specification, which is
required.  For example, the first line of the following specification
gives the type of circ and the second defines its internal structure:
</para>

<programlisting>
circ :: Signal a => a -> a
circ x = inv x
</programlisting>

</sect1>



<sect1><title>Some Useful Techniques</title>


<para>
The definition of a circuit consists of two parts:



-- A <emphasis>type declaration</emphasis>, which describes the
<emphasis>interface</emphasis> of the circuit.  This includes a precise
description of the input and output ports.

--  A <emphasis>defining equation</emphasis>, which describes the internal
structure of the circuit.  This gives names to some or all of the
signals, states what internal components are used, and how they are
connected.
</para>


<para>
Running quick experiments by entering expressions like "inv True" can
be helpful, but it's also a good idea to include suitable test cases
as permanent definitions in a circuit specification module.  One way
to do this is to define a test case by a top-level equation, like
this:
</para>

<programlisting>
> test_inv_1 = inv True   -- should be False
> test_inv_2 = inv False  -- should be True
</programlisting>

<para>
Now you can run these test cases any time by entering the name
interactively:
</para>

<programlisting>
*Tutorial1> test_inv_1
  False
</programlisting>

<para>
Although these examples are trivial, as you develop larger designs it
is helpful to have a collection of test cases, with the expected
results in comments.  These serve as examples of how to use the
circuits, and if a change to the file somewhere causes everything to
go wrong, you can easily run all the tests again to find out what is
working.
</para>

<para>
Many circuits cannot be handled directly using either
\textit{truthTable} or the \textit{truthTableij} family.  These
include circuits with too many inputs or outputs, and ones that have
signals with special grouping.  It is still straightforward to
generate their truth tables; you just need to make a temporary
definition of an equivalent circuit with the inputs all in one word,
and the outputs all in another.  For example, the full adder circuit
(module \textit{BitComb}) has type
\begin{equation}
  \label{eq:3}
  \mathit{fullAdd}\ ::\ \mathit{Signal}\ a\ \Rightarrow\
    (a,a) \rightarrow a \rightarrow (a,a)
\end{equation}
Even though this has only 3 inputs and 2 outputs, we can't use
\textit{truthTable32} because the first two inputs are grouped in a
tuple.  However, we can test it by using a \textbf{let} expression to
define an equivalent circuit \textit{f} which is compatible with
\textit{truthTable}:
</para>

<programlisting>
>      let f [x,y,c] =
>            let (c',s) = fullAdd (x,y) c
>              in [c',s]
>        in truthTable 3 f
</programlisting>


<para>
Port Specifications


Multiple Inputs


Multiple Outputs


Fanout and Partial Applications
</para>

<para>
Suppose you have a circuit $f$ that takes two inputs, an opcode
\textit{op} and a data input $x$.  Often one needs to apply such a
circuit to every bit in a word, but where each bit position receives
the same opcode.  That is, given input $[x_0, x_1, \ldots, x_{k-1}]$,
we want the output to be \[[f op x_0, f op x_1, \ldots, f op
x_{k-1}.\]
</para>

<para>
One way to express this is by writing out all the applications
explicitly:
</para>

<programlisting>
circ_v1 op [x0,x1,x2,x3] =
  [f op x0, f op x1, f op x2, f op x3]
</programlisting>

<para>
A more concise way to write it is to define locally a special version
of $f$ that is already connected to the shared signal \textit{op}.
Calling this specialized circuit $g$, we have a second version of the
circuit:
</para>

<programlisting>
circ_v2 op [x0,x1,x2,x3] = [g x0, g x1, g x2, g x3]
  where g x = f op x
</programlisting>

<para>
It is straightforward to see that the two circuits are equivalent.
For the first bit position, we can use the definition of g to
calculate $g x0 = f op x0$.  An equivalent way to write this
definition is to omit that last $x$ on both sides of the equation
defining $g$, leading to a third version:
</para>

<programlisting>
circ_v3 op [x0,x1,x2,x3] = [g x0, g x1, g x2, g x3]
  where g = f op
</programlisting>

<para>
The choice between versions 2 and 3 is entirely stylistic; it's just a
matter of personal taste.  Version 2 may seem more straightforward at
first, but version 3 is more concise, as it allows you to define the
specialized circuit just by writing $(f\ \mathit{op})$ as an
expression, without even requiring an equation.
</para>

<para>
A definition like $g$ is called a \textit{partial application},
because it is an $f$ box applied to a partial set of its inputs, but
not all of them.  Partial applications are frequently useful in
conjunction with design patterns.  For example, we could generalize
the circuit defined above to work on words of arbitrary size using a
\textit{map} pattern, as follows:
</para>

<programlisting>
circ op xs = map (f op) xs
</programlisting>

<para>
Note that we cannot write $\mathit{map2}\ f\ \mathit{op}\ \mathit{xs}$
because \textit{op} is not a word.  For another example of the use of
partial applications, see the shift register definitions in Section
??.
</para>

<programlisting>
circ :: Signal a => a -> a -> (a,a)
circ a b = (y,z)
  where
    p = inv a
    y = and2 p b
    z = or2 p b
</programlisting>


<programlisting>
> mux1 :: Signal a => a -> a -> a -> a
> mux1 c x y = or2 (and2 (inv c) x) (and2 c y)
</programlisting>

<programlisting>
> mux2 :: Signal a => (a,a) -> a -> a -> a -> a -> a
> mux2 (c,d) p q w r =
>   mux1 c (mux1 d p q) (mux1 d w r)
</programlisting>

<programlisting>
> winv4 :: Signal a => [a] -> [a]
> winv4 [x0,x1,x2,x3]
>   = [inv x0, inv x1, inv x2, inv x3]
</programlisting>

<para>
If a circuit takes an input word and produces an output word, then its
truth table can be generated using the \textit{truthTable} function.
This takes two arguments: the size $k$ of the input word, and the
circuit.  For example, we can define a circuit \textit{inv4} that
inverts a 4-bit word:
</para>

<programlisting>
> winv4 :: Signal a => [a] -> [a]
> winv4 [x0,x1,x2,x3]
>   = [inv x0, inv x1, inv x2, inv x3]
</programlisting>

<para>
Now its truth table can be generated by entering
</para>

<programlisting>
truthTable 4 winv4
</programlisting>



<programlisting>
> halfAdd :: Signal a => a -> a -> (a,a)
> halfAdd x y = (and2 x y, xor2 x y)
</programlisting>

<programlisting>
> bsum, bcarry :: Signal a => (a,a) -> a -> a
> bsum (x,y) c = xor3 x y c
> bcarry (x,y) c = or3 (and2 x y) (and2 x c) (and2 y c)
</programlisting>

<programlisting>
> fullAdd :: Signal a => (a,a) -> a -> (a,a)
> fullAdd (x,y) c = (bcarry (x,y) c, bsum (x,y) c)
</programlisting>

<programlisting>
> rippleAdd4 :: Signal a => a -> [(a,a)] -> (a,[a])
> rippleAdd4 c [(x0,y0),(x1,y1),(x2,y2),(x3,y3)]
>   = (c0, [s0,s1,s2,s3])
>   where
>     (c0,s0) = fullAdd (x0,y0) c1
>     (c1,s1) = fullAdd (x1,y1) c2
>     (c2,s2) = fullAdd (x2,y2) c3
>     (c3,s3) = fullAdd (x3,y3) cin
</programlisting>

<para>
\begin{exercise}
  Produce a truth table for the 4-bit ripple carry adder,
  \textit{rippleAdd4}.  Choose randomly a few of the lines of this
  rather lengthy table, and verify that the circuit's outputs are
  correct.
\end{exercise}
</para>

<programlisting>
\begin{figure}[htbp]
  \begin{center}
    \includegraphics{../figures/xfig/rippleAdd4.eps}
    \caption{4-Bit Ripple Carry Adder}
    \label{fig:rippleAdd4}
  \end{center}
\end{figure}
</programlisting>


</sect1>

</chapter>

<chapter><title>Tu3seq.hs: Sequential Circuits</title>

<para>
foo
</para>

<sect1><title>Clocked signals</title>

<para>
A sequential circuit has behavior that changes over time.  We will use
synchronous circuits, which require (1) every flip flop receives a
clock tick simultaneously, and (2) every feedback loop must go through
a flip flop.
</para>

<para>
Clocked signals
</para>

<para>
Any circuit that contains a flip flop requires the synchronous model
to specify its behavior.  This, in turn, requires that the
representation of signals must be able to handle the system clock.  We
express that by the notation "Clocked a =>" in the circuit's type.
</para>

<programlisting>
> seqcirc :: Clocked a => a -> a
> seqcirc x = y
>   where y = dff z
>         z = xor2 x y
</programlisting>

<para>
Now the value of a Clocked signal is not simply True or False; it has
a value during every clock cycle.  A sequence of values over time is
called a stream.  The input data for seqcirc must therefore have a
type Stream Bool.  We can construct the signal by writing a list of
values, where the i'th element of the list is the input during clock
cycle i, and then converting the list to a stream with the listStream
function:
</para>

<programlisting>
> test_input_1 :: Stream Bool
> test_input_1 =
>   listStream
>     [True,  False, True,  True,
>      False, True,  False, False,
>      True,  True,  True,  False]
</programlisting>

<para>
The definition above says that the signal has value True during cycle
0, False during cycle 1, and so on.  Strictly speaking, the list
should be infinitely long because the clock runs -- at least in
principle -- forever.
</para>

</sect1>


<sect1><title>Sequential Circuits</title>

<sect2><title>Feedback</title>

<programlisting>
> reg1 :: Clocked a => a -> a -> a
> reg1 ld x = r
>   where r = dff (mux1 ld r x)
</programlisting>

<programlisting>
\begin{figure}[htbp]
  \begin{center}
    \includegraphics{../figures/xfig/reg1.eps}
    \caption{Register Bit}
    \label{fig:reg1}
  \end{center}
\end{figure}
</programlisting>

<programlisting>
> reg4 :: Clocked a => a -> [a] -> [a]
> reg4 ld [x0,x1,x2,x3] =
>   [reg1 ld x0, reg1 ld x1, reg1 ld x2, reg1 ld x3]
</programlisting>

</sect2>
</sect1>


<sect1><title>Sequential simulation</title>

<para>
Now we can simulate the circuit by applying it to its input signal.
but it's a good idea first to work out by hand the expected results.
Do this by making a table, where each column is a signal value and
each row is a clock cycle.  It's helpful to break the columns into
several categories: the clock cycle, the input signals, the flip flop
states, the outputs, and other internal signals.  For seqcirc, y is
both a flip flop state and an output of the circuit.  The table has
the form:
</para>

<programlisting>
                  Output
  Cycle | Input | State | Signals
        |   x   |   y   |   z
  -------------------------------
    0   |   1       0
    1   |   0
    2   |   1
    3   |   1
   ...  |   0
</programlisting>

<para>
Now initialize the table by setting the initial state of each flip
flop (i.e. its output during Cycle 0) to the flip flop power-up value,
and filling in some of the inputs.  For the Stream Bool model, the
initial flip flop state (and output value) is False (thus we assume
that the flip flop has a 0 when you first turn on power to the
circuit; in some of the other circuit models we will not make that
assumption).  To save space, We'll write 0 for False and 1 for True.
So the initial table is
</para>

<programlisting>
                  Output
  Cycle | Input | State | Signals
        |   x   |   y   |   z
  -------------------------------
    0   |   1       0
    1   |   0
    2   |   1
    3   |   1
   ...  |   0
</programlisting>

<para>
Now for each cycle, do the following:
</para>

<para>


(1) Simulate the settling down of the combinational logic by working
    out all the signal values.  Notice that when you work out the value
    of a combinational logic signal in a certain row of the table, you
    always use existing values from that same row.

    For Cycle 0, note that z = xor2 x y = xor2 1 0 = 1, giving:
</para>

<programlisting>
                  Output
  Cycle | Input | State | Signals
        |   x   |   y   |   z
  -------------------------------
    0   |   1       0       1
    1   |   0
    2   |   1
    3   |   1
   ...  |   0
</programlisting>

<para>
(2) Simulate the clock tick that ends the cycle: find the value of the
    input to a flip flop, and write it down as the flip flop's state
    for the *next* cycle.  Now the input to the flip flop y is the
    signal z, and z=1 in Cycle 0, so write down 1 as the flip flop
    state  y in the next row of the table:
</para>

<programlisting>
                  Output
  Cycle | Input | State | Signals
        |   x   |   y   |   z
  -------------------------------
    0   |   1       0       1
    1   |   0       1
    2   |   1
    3   |   1
   ...  |   0
</programlisting>

<para>
Continue the simulation, row by row.  You will alternately simulate a
clock cycle followed by a tick, then the next cycle, and so on, and as
time passes you'll fill the table from top to bottom.  After a few
cycles the table should look like this:
</para>

<programlisting>
                  Output
  Cycle | Input | State | Signals
        |   x   |   y   |   z
  -------------------------------
    0   |   1       0       1
    1   |   0       1       1
    2   |   1       1       0
    3   |   1       0       1
    4   |   0       1       1
    5   |   1       1       0
    6   |   0       0       0
    7   |   0       0       0
    8   |   1       0       1
    9   |   1       1       0
   10   |   1       0       1
   11   |   0       1       1
</programlisting>

<para>
Now, after simulating some test data by hand, enter the following
expression into Hydra:
</para>

<programlisting>
seqcirc test_input_1
</programlisting>

<para>
Hydra performs the simulation and produces the following result:
</para>

<programlisting>
*Tutorial1> seqcirc test_input_1
0,1,1,0,1,1,0,0,0,1,0,1,1,*** Exception: no more stream data from list
</programlisting>

<para>
The output matches the results of the manual simulation.  The output
uses 1 and 0 rather than True and False; Hydra is still using True and
False to represent the signal values during a clock cycle, but it has
converted the Booleans to 0/1 automatically.  Since the input data
terminated after twelve cycles, an exception was thrown indicating
that there is no input data for cycle 12.  This message can be
ignored.
</para>

</sect1>





</chapter>

<chapter><title>Tu4sim.ha: Simulation Drivers</title>

<sect1><title>foo</title>


<para>

 Hydra: Simulation Drivers

Introduction
</para>

<para>
The subject of this tutorial is simulation drivers: software tools
that make it easier to write down the inputs and to read and
understand the outputs when you're simulating a circuit.
</para>

<para>
Small circuits can be simulated by providing the values of all the
individual input bits, and reading the resulting output bits.  For
larger scale designs, there are just too many bits for this to be
feasible.  To simulate a processor, there are likely to be several
input words and a dozen of more output words; this would require the
user to read through hundreds of 0s and 1s, and to do that again and
again for each clock cycle.
</para>

<para>
A simulation driver is a piece of software that takes input in a
readable form, runs the simulation, and formats the output signals.
We will use a simulation driver for each of our main circuits. 
We'll provide inputs to sequential circuits by making a list, where
each line of the list corresponds to a clock cycle, and it contains
the input signal values for that cycle (expressed in decimal).
</para>

<para>
Since any clocked signal is a signal, there is no problem with doing a
synchronous simulation of a combinational circuit.
</para>

<para>
The simulation driver for a synchronous circuit contains four main
pieces:



Choices for the circuit parameters, if any; these typically
include word size and address size.

An equation that applies the circuit to its inputs, defining names
for the outputs.

Tools that take the inputs expressed in a form easy for the user
to write and convert them to the proper input signal representation.

Tools that take the output signals from the circuit and format
them readably.

</para>

<para>

Simulation driver for the adder</para>

<para>
To show how to write a simulation driver, this section will work
through an example in detail: a driver for the ripple carry adder,
with type
</para>

<para>
  Clocked a => a -> [(a,a)] -> (a,[a])
</para>

<para>
The adder has one circuit parameter, its wordsize, since our ripple
carry adders may be defined using design patterns that work for
arbitrary size!  Here we use 8-bit words.
</para>

<para>
n = 8

The heart of the simulation driver is an equation that uses the
circuit.  Here, we define the carry output co and the sum word s to be
the outputs of an adder with input words x and y; these are
represented in bit slice form as a single word z :: [(a,a)].
</para>

<programlisting>
    (co,s) = rippleAdd ci z
</programlisting>

<para>
The bit slice word z is formed by the bitslice2 wiring pattern:
</para>

<programlisting>
    z = bitslice2 x y
</programlisting>

<para>
We could also omit this equation, and write the circuit application as
</para>

<programlisting>
    (co,s) = rippleAdd ci (bitslice2 x y)
</programlisting>

<para>
The inputs to the circuit can be provided interactively, but sometimes
it's more convenient to define a set of inputs as a constant
definition in the simulation module.  This allows us to run a
simulation repeatedly, without having to keep typing the same inputs
over and over again.  That approach will be taken here; later we will
introduce tools that support interactive simulations.
</para>

<para>
There are three values to be supplied for each clock cycle: the carry
input, and the two words x and y.  These will be written in a list of
lists; here's an example definition of test input:
</para>

<programlisting>
> add_input1 :: [[Int]]

> add_input1 =
>   [[0,  2,  3],
>    [0,  1,  8],
>    [0, 10,  5],
>    [0, 11,  2],
>    [1,  4,  5]]
</programlisting>

<para>
This says that in clock cycle 0, the carry input is 0, x is 3, and y
is 8; in clock cycle 1 x=5 and y=-9, and so on.  Note that the words
can be written in decimal in the test data.
</para>

<para>
The simulation driver is called \texttt{sim\_adder}, and you give it three arguments:
  -- the name of the adder circuit you want to use
  -- the wordsize
  -- the input data
For example,
</para>

<programlisting>
sim_adder rippleAdd4  4 add_input1
</programlisting>

<para>
says to use the 4-bit ripple carry adder (the same one presented in
lecture) with the data above.  Go ahead and enter that line at the
prompt, and you should see output something like this...
</para>

<programlisting>
Tutorial1> sim_adder rippleAdd4 4 add_input1

..................................................
   Simulating ripple carry adder
      0.   ci=0 x=   2 y=   3   Output: 0   5
      1.   ci=0 x=   1 y=   8   Output: 0   9
      2.   ci=0 x=  10 y=   5   Output: 0  15
      3.   ci=0 x=  11 y=   2   Output: 0  13
      4.   ci=1 x=   4 y=   5   Output: 0  10
..................................................
</programlisting>

<para>
Now you can try some other experiments, for example by using the
general n-bit adder (rippleAdd) or by varying the wordsize.  Of course
you can also modify the input test data.  To run the experiments,
enter the following expressions:
</para>

<programlisting>
   sim_adder rippleAdd4  4 add_input1
   sim_adder rippleAdd   4 add_input1
   sim_adder rippleAdd  16 add_input1
</programlisting>


<para>Writing a Simulation Driver for the Ripple Carry Adder</para>

<para>
Now we need to use the tools for converting the test input to the
correct signal representations:
</para>

<programlisting>
   ci = getbit   input 0 :: Stream Bool 
   x  = getbin n input 1
   y  = getbin n input 2
</programlisting>

<para>
The first equation says that ci is obtained from the 0'th column of
the test input, using a bit conversion (getbit).  The second equation
says that x comes from column 1 in the test input, and it's converted
using a binary conversion (getbin n), where n is the wordsize.  The
last equation converts y from column 2 of the input data.
</para>

<para>
The final step is to format the output.  First, we specify the
underlying signal representation that is being used:
</para>

<programlisting>
   simoutput :: [Format Bool]
</programlisting>

<para>
This is necessary, because Hydra supports a large number of signal
representations, and it needs to know which one to use here.
</para>

<para>
Now we define the simulation output by formatting the various signals
that should be printed.  The format consists of a list of fields
separated by commas.  For every clock cycle, Hydra will print a line
comprising all these fields.  The field format specifications are
</para>

<programlisting>
  string "abc"  prints the literal string on each line
  bit x         prints the value of the bit signal x, as 0 or 1
  bindec k x    converts the binary word x to a 4-digit decimal integer
  tcdec k x     converts the two's complement word x to a 4-digit
                decimal integer
</programlisting>

<para>
The following format prints the adder's inputs and outputs, along with
some labels:
</para>

<programlisting>
    simoutput =
      [bit ci,
       string " x= ", bindec 4 x, tcdec 4 x,
       string " y= ", bindec 4 y, tcdec 4 y,
       string " Output: ", bit co,
       string " sum= ", bindec 4 s, tcdec 4 s]
</programlisting>

<para>
Putting all the pieces together, here is the simulation driver for the
ripple carry adder:
</para>

<programlisting>
> sim_adder add_circuit n input =
>   let (co,s) = add_circuit ci (bitslice2 x y)
>       ci = getbit   input 0
>       x  = getbin n input 1
>       y  = getbin n input 2
>       simoutput :: [Format Bool]
>       simoutput =
>         [string " ci=", bit ci,
>          string " x= ", bindec 3 x,
>          string " y= ", bindec 3 y,
>          string "   Output: ", bit co, bindec 4 s]
>   in do putStrLn "\nSimulating ripple carry adder"
>         run input simoutput
</programlisting>

<para>
A simulation driver for the comparitor

The ripple comparitor for binary numbers can be simulated by entering
the following:
</para>

<programlisting>
   sim_comparitor rippleCmp 16 cmp_input1
</programlisting>

<para>
Here is some test data for the comparitor...
</para>

<programlisting>
> cmp_input1 :: [[Int]]
> cmp_input1 =
>   [[2, 3],
>    [3, 2],
>    [3, 3],
>    [1, 8],
>    [8, 1],
>    [9, 9],
>    [0, 5],
>    [7, 5]]
</programlisting>

<para>
The simulation driver is similar to the adder driver.
</para>

<programlisting>
> sim_comparitor circuit n input =
>   let (lt,eq,gt) = circuit (bitslice2 x y)
>       x = getbin n input 0
>       y = getbin n input 1
>       simoutput :: [Format Bool]
>       simoutput =
>         [string " x= ", bindec 4 x,
>          string "   y= ", bindec 4 y,
>          string "  (lt,eq,gt) = ",
>          bit lt, bit eq, bit gt]
>   in do putStrLn "\nSimulating comparitor"
>         run input simoutput
</programlisting>


<para>
The simulation driver for a synchronous circuit contains four main
pieces:
</para>

<para>
\begin{itemize}
\item Definitions of the circuit parameters, if any; these typically
  include word size and address size.
\item An equation that applies the circuit to its inputs, defining
  names for the outputs.
\item Tools that take the inputs expressed in a form easy for the user
  to write and convert them to the proper input signal representation.
\item Tools that take the output signals from the circuit and format
  them readably.
\end{itemize}
</para>

<para>
The simulation is performed by executing the IO operation \textit{run
  input simoutput}, where $\textit{input} :: [[\textit{Int}]]$ is the
input data specified by the user.  Thus the form of a typical simulation
  driver is
\begin{align*}
   \mathit{simoutput}\ ::\ [\mathit{Format}\ \mathit{Bool}] \\
   \mathit{simoutput}\ =\ [\ldots\ \textit{list of format specifiers}\ \ldots]
\end{align*}
</para>

<sect2><title>Number System Conversions</title>

<para>
There are functions for converting between natural numbers (using
binary representation), integers (using two's complement
representation) bit strings, and hexadecimal.
</para>

<para>
The functions most useful for generating input signals are: intbit
intbin inttc hexbin hextc.
</para>

<para>
The functions most useful for interpreting output signals are: bitint
binint tcint binhex tchex.

\textit{more later...}
</para>

</sect2>

<sect2><title>Sequential Simulation</title>

<para>
Circuits often have large numbers of input and output signals. It can
be difficult and error prone to set up the inputs for a simulation, as
well as to interrpret the outputs.  For example, it is straightforward
but tedious to convert decimal numbers to binary or two's complement
representations.  Furthermore, an actual simulation requires the
inputs to be expressed in a signal class instance.  This is
essentially a data structure intended for internal use only, and the
circuit designer should not need to delve into Hydra's internal data
structures.
</para>

<para>
solution: a software interface to the simulation, called a simulation
driver. It allows input to be provided in a readable form, and
translates this to the actual signal inputs required by the
circuit. Conversely, it takes the cirucuit's output signals, converts
them to a convenient notation, and formats them neatly for output.
</para>

<para>
It's important to be clear about what is software and what is
hardware--especially when the hardware isn't really hard, but is
actually being created virtually via simulation!
</para>
</sect2>

</sect1>


<sect1><title>Example: A Simple Simulation Driver</title>

<para>
The tools for writing simulation drivers are illustrated in this
section by a simple standalone driver, which reads some signals and
then just outputs them directly, without processing them with a circuit.
</para>

<para>
In this experiment, there are three inputs: a bit $x$, an 8-bit binary
number $y$, and an 8-bit two's complement number $z$.  Each line of
the input will be specified with integers for $x$, $y$, ans $z$ in
order.  A particular input data set \textit{test\_input} is defined
below.  It's a good idea to line up the elements neatly, so that any
signal can be followed through time by reading down a column.
Comments are used to label each column with the signal name, and to
say what the representation for that signal is.  In this example, the
cycle numbers are labelled as well.  Normally this is unnecessary, but
in a test case that runs for only a few cycles it may be helpful.
</para>

<programlisting>
> test_input :: [[Int]]
> test_input =
> --  x    y     z
> -- bit  bin   tc
> -- ~~~~~~~~~~~~~~~
>   [[0,    5,    5],     -- cycle 0
>    [1,  255,   -1],     -- cycle 1
>    [1,    0,  127],     -- cycle 2
>    [0,   42, -128],     -- cycle 3
>    [1,  195,  -37]      -- cycle 4
>   ]
</programlisting>

<programlisting>
> standalone_driver :: [[Int]] -> IO ()
> standalone_driver input = do run input simoutput
>   where
>
> -- Size parameters
>     n = 8
>
> -- Input formatting
>     x = getbit   input 0 :: Stream Bool
>     y = getbin n input 1
>     z = gettc  n input 2
>
> -- Output formatting
>     simoutput :: [Format Bool]
>     simoutput =
>       [string "x = ", bit x,
>        string "      y = ", hex y, bindec 5 y, tcdec 5 y,
>        string "      z = ", hex z, string " ", bits z,
>          bindec 5 z, tcdec 5 z]
</programlisting>

<para>
The simulation can now be performed by running the driver with an
input data set.  One way is to enter the expression

<programlisting>
standalone_driver test_input
</programlisting>

at the interactive prompt.  With larger design projects, it's useful
to define a batch script \texttt{main} which executes the test.  This
allows many test cases to be run together.  It is a good idea to run
such batch tests regularly as a design is developed, to ensure that
any changes haven't introduced bugs.
</para>

<programlisting>
> main :: IO ()
> main =
>   do standalone_driver test_input
</programlisting>

<para>
The output from executing \texttt{main} is shown below.  From the
output it's easy to see that $x$ is the same values as were specified
in the input.  The second signal, $y$, is an 8-bit word which is
displayed three ways: as a hexadecimal, as an integer using binary
representation, and as an integer using two's complement
representation.  Note that $y$ was input using a binary format
specifier, and the binary output gives exactly the same values.
Naturally, the two's complement output for $y$ is different; for
example, the word consisting of all 1s represents 255 in binary but -1
in two's complement.  Since $z$ was input using a two's complement
format, the two's complement output column shows the same values,
while the binary output column may be different.
</para>

<programlisting>
*FormatTest> main
   0.  x = 0      y = 05    5    5      z = 05 00000101    5    5
   1.  x = 1      y = ff  255   -1      z = ff 11111111  255   -1
   2.  x = 1      y = 00    0    0      z = 7f 01111111  127  127
   3.  x = 0      y = 2a   42   42      z = 80 10000000  128 -128
   4.  x = 1      y = c3  195  -61      z = db 11011011  219  -37
</programlisting>
</sect1>

<sect1><title>Batch Testing</title>

<para>
This is a single operation that runs the various examples above as one
large batch.  You can run it by just launching Hydra, loading this
file, and entering "main" at the prompt.
</para>

<programlisting>
main =
  do putStrLn "Hydra: running Tutorial1 batch"
     sim_adder rippleAdd 16 add_input1
     sim_sr4 sr4_input
     sim_regfile
     sim_regfile_dec
     sim_rtm
     sim_mult
     putStrLn "Examples1 finished"
</programlisting>

<itemizedlist>
<listitem><para>truthTable11</para></listitem>
<listitem><para>truthTable12</para></listitem>
<listitem><para>truthTable21</para></listitem>
<listitem><para>truthTable22</para></listitem>
<listitem><para>truthTable23</para></listitem>
<listitem><para>truthTable31</para></listitem>
<listitem><para>truthTable32</para></listitem>
<listitem><para>truthTable33</para></listitem>
<listitem><para>truthTable41</para></listitem>
<listitem><para>truthTable42</para></listitem>
<listitem><para>truthTable43</para></listitem>
</itemizedlist>

</sect1>


<sect1><title>from ref man</title>
<para> foo </para>
</sect1>

<sect1><title>Formatting input and output signals</title>

<para>
A "simulation driver" is a piece of software that takes input in a
readable form, runs the simulation, and formats the output signals.
We will use a simulation driver for each of our main circuits. 
We'll provide inputs to sequential circuits by making a list, where
each line of the list corresponds to a clock cycle, and it contains
the input signal values for that cycle (expressed in decimal).
</para>


<sect2><title>Providing Input to a Circuit</title>

<para>
The inputs for a simulation are written as lists of integers, and the
simulation driver contains format specifiers that say how to obtain
the signals from these integers.
</para>

<para>
The simulation input is a value of type $[[\textit{Int}]]$, and is
typically given the name \textit{input}.  The $i$th element of
\textit{input} specifies all the circuit inputs for clock cycle $i$,
and is a list of elements that define the input signal values during
cycle $i$.
</para>

<para>
Each clock cycle input is a list of integers.  The signals are
calculated from those integers using \emph{input format specifiers.}
Generally, each signal comes from one element of the list.  Each
signal is defined by an equation of the form
\begin{equation}
  \label{eq:1}
  \mathit{signal}\ =\ \mathit{format}\ \mathit{input}\ i
\end{equation}
where $i$ is an index within the list of integers for the cycle.  For
example, the equation
\begin{equation}
  \label{eq:2}
  x\ =\ \mathit{getbit}\ \mathit{input}\ 3
\end{equation}
says that the signal $x$ is a bit whose value is given in the third
element of \textit{input}.
</para>

<para>
A variety of input formats are provided, allowing you to extract bits
and words, using either binary or two's complement representation.
The most frequently used input formats are:
</para>

<para>
\begin{itemize}
\item $b\ =\ \mathit{getbit}\ \mathit{input}\ i$ defines $b$ as a bit
  signal representing the $i$th element of the input list.  The value
  of $b$ during a clock cycle is \textit{zero} if the corresponding
  input integer is 0, and \textit{one} if the integer is 1.
\item $w\ =\ \mathit{getbin}\ k\ \mathit{input}\ i$ defines $w$ to be
  a $k$-bit word whose binary interpretation is the $i$th integer in
  the input list.
\item $w\ =\ \mathit{gettc}\ k\ \mathit{input}\ i$ defines $w$ to be a
  $k$-bit word whose two's complement interpretation is the $i$th
  integer in the input list.
\end{itemize}
</para>

</sect2>

<sect2><title>Interpreting the Output from a Circuit</title>

<para>
The output signals produced by a circuit may be hard to read directly,
partly because there are likely to be too many bits to grasp easily,
and partly because the data structures that Hydra uses to represent
clocked signals contain a lot of detail.
</para>

<para>
To make the outputs more readable, a simulation driver uses a format
specification to construct neat textual output.  A complete format is
a list of individual specifiers, each of which produces one or more
characters of output. The output specification can be given a name
like \textit{simoutput}, and defined as follows
\begin{align*}
   \mathit{simoutput}\ ::\ [\mathit{Format}\ \mathit{Bool}] \\
   \mathit{simoutput}\ =\ [\ldots\ \textit{list of format specifiers}\ \ldots]
\end{align*}
</para>

<para>
The format specifiers are:
</para>

<para>
\begin{itemize}
\item $\mathit{bit}\ b$ outputs the bit $b$ in one character, which
  will be either \texttt{0} or \texttt{1}.
\item $\mathit{bits}\ w$ outputs the word $w$ in a string of length
  $k$ consisting of \texttt{0}s and \texttt{1}s, where $k$ is the size
  of $w$.
\item $\mathit{hex}\ w$ outputs the word $w$ as a hexadecimal string.
  The size of the string is the $\lceil k/4 \rceil$ ($k/4$ rounded up
  to an integer), which is the minimal size needed to represent $w$.
\item $\mathit{bindec}\ k\ w$ interprets the word $w$ as a binary
  representation, and converts it to a decimal number $k$ characters
  wide.  Leading spaces are attached if necessary to fill the field.
\item $\mathit{tcdec}\ k\ w$ interprets the word $w$ as a two's
  complement representation, and converts it to a decimal number $k$
  characters wide.
\item $\mathit{string}\ s$ outputs the character string $s$, which is
  useful for labelling signals, inserting newlines, etc.
\end{itemize}
</para>

</sect2>
</sect1>

<sect1><title>foo</title>

<para>
Design examples
</para>

<para>Bidirectional shift register
</para>

<para>
The bidirectional shift register takes an operation code that
determines the behavior:
</para>

<programlisting>
  0 -- no state change
  1 -- load input word x
  2 -- shift right
  3 -- shift left
</programlisting>

<para>
The following test data contains comments showing the expected output.
This is a useful technique for documenting a circuit, and it provides
a good permanent test case.  You can run the simulation by copying the
following expression, and pasting it into a Hydra dialogue:
</para>

<programlisting>
  sim_sr4 sr4_testdata_1

> sr4_testdata_1 :: [[Int]]
> sr4_testdata_1 =
> --      op  l  r  x        op    produce  state
> --      ~~~~~~~~~~~       ~~~~~~~~~~~~~~~~~~~~~
>        [[1, 0, 0, 9],  -- load     1001    0000
>         [0, 0, 0, 3],  -- nop      1001    1001
>         [2, 1, 0, 4],  -- right 1  1100    1001
>         [2, 0, 0, 2],  -- right 0  0110    1100
>         [3, 0, 1, 7],  -- left  1  1101    0110
>         [1, 0, 0, 5],  -- load     0101    1101
>         [0, 0, 0, 0]]  -- nop      0101    0101
</programlisting>

<para>
Here is a simulation driver intended specifically for the 4-bit
version of the circuit.
</para>

<programlisting>
> sim_sr4 input =
>   let op = getbit2  input 0
>       l =  getbit   input 1
>       r =  getbit   input 2
>       x =  getbin 4 input 3
>       (op0,op1) = op
>       y = sr4 op l r x
>       simoutput :: [Format Bool]
>       simoutput = [string "Input: ",
>               bit op0, bit op1, string " ",
>               bit l, string " ", bit r, string " ", bits x,
>               string "    Output: ", bits y]
>   in do putStrLn "\nSimulate 4-bit shift register"
>         run input simoutput
</programlisting>

<para>The register file
</para>

<para>
Now we'll simulate a register file with 16 registers, each containing
16 bits.  This is the circuit used within the ITM!  The circuit
definition appears in WordSeq.lhs, and here is the test data:
</para>

<programlisting>
> regfile_input1 :: [[Int]]
> regfile_input1 =
> --      ld  d sa sb  x
> --      ~~~~~~~~~~~~~~~
>        [[1, 4, 0, 0,  25],  -- R4 :=  25    R0 =   0, R0 =   0
>         [1, 7, 4, 7, 255],  -- R7 := 255    R4 =  25, R7 =   0
>         [1, 1, 4, 7,  31],  -- R1 :=  31    R4 =  25, R7 = 255
>         [0, 1, 0, 1,  50],  --              R0 =   0, R1 =  31
>         [1, 2, 1, 7, 100],  -- R2 := 100,   R1 =  31, R7 = 255
>         [0, 0, 0, 2,   0]]  --              R0 =   0  R2 = 100
</programlisting>

<para>
This means, for example, that in the initial clock cycle ld=1, so x
(which is 25) will be loaded into reg[4] (because the destination
address d is 4).  On the next clock cycle, the source address sa is 4,
so the circuit will output the contents of reg[4], which by then will
be 25.  You should work through this input data in detail.
</para>

<para>
Run the simulation by entering
</para>

<programlisting>
  sim_regfile regfile_input1
</programlisting>

<para>
You can see that the long binary numbers are hard to read.  There is
another simulation driver which converts the numbers to decimal;
exactly the same circuit is simulated, but the output is more
readable.  You can try it by entering
</para>

<programlisting>
  sim_regfile_dec regfile_input1
</programlisting>

<para>
It's a good idea to make up your own example: work out a sequence of
operations for the register file to perform, figure out what input
signals are needed to achieve it, edit \texttt{regfile\_input1}, and run the
simulation.
</para>

<programlisting>
> sim_regfile =
>   let k = 3  -- there are 2^3 = 8 registers
>       n = 8  -- each register contains 8 bits
>       input =
> --      ld  d sa sb  x
> --      ~~~~~~~~~~~~~~~
>        [[1, 4, 0, 0,  25],  -- R4 :=  25    R0 =   0, R0 =   0
>         [1, 7, 4, 7, 255],  -- R7 := 255    R4 =  25, R7 =   0
>         [1, 1, 4, 7,  31],  -- R1 :=  31    R4 =  25, R7 = 255
>         [0, 1, 0, 1,  50],  --              R0 =   0, R1 =  31
>         [1, 2, 1, 7, 100],  -- R2 := 100,   R1 =  31, R7 = 255
>         [0, 0, 0, 2,   0]]  --              R0 =   0  R2 = 100
>       ld = getbit   input 0
>       d  = getbin k input 1
>       sa = getbin k input 2
>       sb = getbin k input 3
>       x  = getbin n input 4
>       (a,b) = regfile n k ld d sa sb x
>       simoutput :: [Format Bool]
>       simoutput =
>         [string "Input: ",
>          bit ld, string " ", bits d, string " ",
>          bits sa, string " ", bits sb, string " ", bits x,
>          string "   Output: ", bits a, string " ", bits b]
>   in do putStrLn "\nSimulating register file (format output as binary)"
>         run input simoutput
</programlisting>

<para>
The following is the same as \texttt{sim\_regfile}, but it prints the output
using decimal representations.  The only difference appears in
simoutput, where bindec is used instead of bits for printing the binary
numbers in decimal notation.
</para>

<programlisting>
> sim_regfile_dec =
>   let k = 3  -- there are 2^3 = 8 registers
>       n = 8  -- each register contains 8 bits
>       input =
> --      ld  d sa sb  x
> --      ~~~~~~~~~~~~~~~
>        [[1, 4, 0, 0,  25],  -- R4 :=  25    R0 =   0, R0 =   0
>         [1, 7, 4, 7, 255],  -- R7 := 255    R4 =  25, R7 =   0
>         [1, 1, 4, 7,  31],  -- R1 :=  31    R4 =  25, R7 = 255
>         [0, 1, 0, 1,  50],  --              R0 =   0, R1 =  31
>         [1, 2, 1, 7, 100],  -- R2 := 100,   R1 =  31, R7 = 255
>         [0, 0, 0, 2,   0]]  --              R0 =   0  R2 = 100
>       ld = getbit   input 0
>       d  = getbin k input 1
>       sa = getbin k input 2
>       sb = getbin k input 3
>       x  = getbin n input 4
>       (a,b) = regfile n k ld d sa sb x
>       simoutput :: [Format Bool]
>       simoutput =
>         [string "Input: ",
>          bit ld, string " ", bindec 1 d, string " ",
>          bindec 1 sa, string " ", bindec 1 sb,
>          string " ", bindec 3 x,
>          string "   Output: ",
>          bindec 3 a, string " ", bindec 3 b]
>   in do putStrLn "\nSimulating register file (format output as decimal)"
>         run input simoutput
</programlisting>

<para>
Simulate the Register File
</para>

<para>
You don't need to read the simulation driver, which just handles the
formatting of the input and output signals.
</para>

<programlisting>
> sim_regfile2 input =
>   let k =  4  -- there are 2^4 = 16 registers
>       n = 16  -- each register contains 16 bits
>       ld = getbit   input 0
>       d  = getbin k input 1
>       sa = getbin k input 2
>       sb = getbin k input 3
>       x  = getbin n input 4
>       (a,b) = regfile n k ld d sa sb x
>       simoutput :: [Format Bool]
>       simoutput =
>         [string "Input: ",
>          bit ld, string " ", bits d, string " ",
>          bits sa, string " ", bits sb, string " ", bits x,
>          string "\n       Output: ", bits a, string " ", bits b]
>   in do putStrLn "\nSimulating register file (format output as binary)"
>         run input simoutput
</programlisting>

<para>
The following is the same as \texttt{sim\_regfile}, but it prints the output
using decimal representations.  The only difference appears in
simoutput, where bindec is used instead of bits for printing the binary
numbers in decimal notation.
</para>

<programlisting>
> sim_regfile_dec2 input =
>   let k =  4  -- there are 2^4 = 16 registers
>       n = 16  -- each register contains 16 bits
>       ld = getbit   input 0
>       d  = getbin k input 1
>       sa = getbin k input 2
>       sb = getbin k input 3
>       x  = getbin n input 4
>       (a,b) = regfile n k ld d sa sb x
>       simoutput :: [Format Bool]
>       simoutput =
>         [string "Input: ",
>          bit ld, string " ", bindec 1 d, string " ",
>          bindec 1 sa, string " ", bindec 1 sb,
>          string " ", bindec 3 x,
>          string "   Output: ",
>          bindec 3 a, string " ", bindec 3 b]
>   in do putStrLn "\nSimulating register file (format output as decimal)"
>         run input simoutput
</programlisting>

<para>
Sequential multiplier

Simulating the Multiplier
</para>

<programlisting>
> sim_mult =
>   let k = 8
>       input =
> --     start  x    y
> --     ~~~~~~~~~~~~~~
>        [[1,  50,  75],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [1, 100, 100],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [1, 100, 100],
>         [0,   0,   0],
>         [0,   0,   0],
>         [1,   2,   3],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0]]
>       start = getbit   input 0
>       x     = getbin k input 1
>       y     = getbin k input 2
>       (rdy,prod,rx,ry,s) = mult k start x y
>       spec :: [Format Bool]
>       spec =
>         [string "Input: ",
>          bit start, bindec 4 x, bindec 4 y,
>          string "  Output: ",
>          bit rdy, bindec 6 prod, bindec 4 rx, bindec 6 ry,
>          bindec 6 s]
>     in do putStrLn "\nSimulate sequential multiplier"
>           run input spec
</programlisting>

<para>
The Register Transfer Machine
</para>

<para>
Simulating the Register File

Now we'll simulate a register file with 16 registers, each containing
16 bits.  This is the circuit used within the ITM!  The circuit
definition appears in WordSeq.lhs, and here is the test data:
</para>

<programlisting>
> regfile_input1 :: [[Int]]
> regfile_input1 =
> --      ld  d sa sb  x
> --      ~~~~~~~~~~~~~~~
>        [[1, 4, 0, 0,  25],  -- R4 :=  25    R0 =   0, R0 =   0
>         [1, 7, 4, 7, 255],  -- R7 := 255    R4 =  25, R7 =   0
>         [1, 1, 4, 7,  31],  -- R1 :=  31    R4 =  25, R7 = 255
>         [0, 1, 0, 1,  50],  --              R0 =   0, R1 =  31
>         [1, 2, 1, 7, 100],  -- R2 := 100,   R1 =  31, R7 = 255
>         [0, 0, 0, 2,   0]]  --              R0 =   0  R2 = 100

</programlisting>

<para>
This means, for example, that in the initial clock cycle ld=1, so x
(which is 25) will be loaded into reg[4] (because the destination
address d is 4).  On the next clock cycle, the source address sa is 4,
so the circuit will output the contents of reg[4], which by then will
be 25.  You should work through this input data in detail.
</para>

<para>
Run the simulation by entering
</para>

<programlisting>
sim_regfile regfile_input1
  
</programlisting>

<para>
You can see that the long binary numbers are hard to read.  There is
another simulation driver which converts the numbers to decimal;
exactly the same circuit is simulated, but the output is more
readable.  You can try it by entering
</para>

<programlisting>
sim_regfile_dec regfile_input1
  
</programlisting>

<para>
It's a good idea to make up your own example: work out a sequence of
operations for the register file to perform, figure out what input
signals are needed to achieve it, edit \texttt{regfile\_input1}, and run the
simulation.
</para>

<programlisting>
> sim_regfile =
>   let k = 3  -- there are 2^3 = 8 registers
>       n = 8  -- each register contains 8 bits
>       input =
> --      ld  d sa sb  x
> --      ~~~~~~~~~~~~~~~
>        [[1, 4, 0, 0,  25],  -- R4 :=  25    R0 =   0, R0 =   0
>         [1, 7, 4, 7, 255],  -- R7 := 255    R4 =  25, R7 =   0
>         [1, 1, 4, 7,  31],  -- R1 :=  31    R4 =  25, R7 = 255
>         [0, 1, 0, 1,  50],  --              R0 =   0, R1 =  31
>         [1, 2, 1, 7, 100],  -- R2 := 100,   R1 =  31, R7 = 255
>         [0, 0, 0, 2,   0]]  --              R0 =   0  R2 = 100
>       ld = getbit   input 0
>       d  = getbin k input 1
>       sa = getbin k input 2
>       sb = getbin k input 3
>       x  = getbin n input 4
>       (a,b) = regfile n k ld d sa sb x
>       simoutput :: [Format Bool]
>       simoutput =
>         [string "Input: ",
>          bit ld, string " ", bits d, string " ",
>          bits sa, string " ", bits sb, string " ", bits x,
>          string "   Output: ", bits a, string " ", bits b]
>   in do putStrLn "\nSimulating register file (format output as binary)"
>         run input simoutput

</programlisting>

<para>
The following is the same as \texttt{sim\_regfile}, but it prints the output
using decimal representations.  The only difference appears in
simoutput, where bindec is used instead of bits for printing the binary
numbers in decimal notation.
</para>

<programlisting>
> sim_regfile_dec =
>   let k = 3  -- there are 2^3 = 8 registers
>       n = 8  -- each register contains 8 bits
>       input =
> --      ld  d sa sb  x
> --      ~~~~~~~~~~~~~~~
>        [[1, 4, 0, 0,  25],  -- R4 :=  25    R0 =   0, R0 =   0
>         [1, 7, 4, 7, 255],  -- R7 := 255    R4 =  25, R7 =   0
>         [1, 1, 4, 7,  31],  -- R1 :=  31    R4 =  25, R7 = 255
>         [0, 1, 0, 1,  50],  --              R0 =   0, R1 =  31
>         [1, 2, 1, 7, 100],  -- R2 := 100,   R1 =  31, R7 = 255
>         [0, 0, 0, 2,   0]]  --              R0 =   0  R2 = 100
>       ld = getbit   input 0
>       d  = getbin k input 1
>       sa = getbin k input 2
>       sb = getbin k input 3
>       x  = getbin n input 4
>       (a,b) = regfile n k ld d sa sb x
>       simoutput :: [Format Bool]
>       simoutput =
>         [string "Input: ",
>          bit ld, string " ", bindec 1 d, string " ",
>          bindec 1 sa, string " ", bindec 1 sb,
>          string " ", bindec 3 x,
>          string "   Output: ",
>          bindec 3 a, string " ", bindec 3 b]
>   in do putStrLn "\nSimulating register file (format output as decimal)"
>         run input simoutput
</programlisting>

<para>
Simulate the Register File
</para>

<para>
You don't need to read the simulation driver, which just handles the
formatting of the input and output signals.
</para>

<programlisting>
> sim_regfile2 input =
>   let k =  4  -- there are 2^4 = 16 registers
>       n = 16  -- each register contains 16 bits
>       ld = getbit   input 0
>       d  = getbin k input 1
>       sa = getbin k input 2
>       sb = getbin k input 3
>       x  = getbin n input 4
>       (a,b) = regfile n k ld d sa sb x
>       simoutput :: [Format Bool]
>       simoutput =
>         [string "Input: ",
>          bit ld, string " ", bits d, string " ",
>          bits sa, string " ", bits sb, string " ", bits x,
>          string "\n       Output: ", bits a, string " ", bits b]
>   in do putStrLn "\nSimulating register file (format output as binary)"
>         run input simoutput
</programlisting>

<para>
The following is the same as \texttt{sim\_regfile}, but it prints the output
using decimal representations.  The only difference appears in
simoutput, where bindec is used instead of bits for printing the binary
numbers in decimal notation.
</para>

<programlisting>
> sim_regfile_dec2 input =
>   let k =  4  -- there are 2^4 = 16 registers
>       n = 16  -- each register contains 16 bits
>       ld = getbit   input 0
>       d  = getbin k input 1
>       sa = getbin k input 2
>       sb = getbin k input 3
>       x  = getbin n input 4
>       (a,b) = regfile n k ld d sa sb x
>       simoutput :: [Format Bool]
>       simoutput =
>         [string "Input: ",
>          bit ld, string " ", bindec 1 d, string " ",
>          bindec 1 sa, string " ", bindec 1 sb,
>          string " ", bindec 3 x,
>          string "   Output: ",
>          bindec 3 a, string " ", bindec 3 b]
>   in do putStrLn "\nSimulating register file (format output as decimal)"
>         run input simoutput
</programlisting>

<para>
Simulating the Register Transfer Machine
</para>

<para>
On each clock cycle, the register transfer machine can read out two
registers (specified by the sa, sb addresses), calculate a data value,
and load that data value into reg[d] if the load control ld=1.  The
data value can be either the data input x, or the sum produced by the
adder, and the add control signal determines which value is chosen.
If add=1 then the adder's output is selected and otherwise x is used.
Here is some sample input data, along with comments that describe what
is going on.
</para>

<programlisting>
> rtm_input1 :: [[Int]]
> rtm_input1 =
> --      ld add d sa sb   x
> --      ~~~~~~~~~~~~~~~~~~~
>        [[1, 0, 3, 0, 0, 125], -- R3 :=   x   = 125. R0=  0 R0=  0
>         [1, 0, 6, 3, 0,  10], -- R6 :=   x   =  10. R3=125 R0=  0
>         [1, 1, 2, 3, 6,   0], -- R2 := R3+R6 = 135. R3=125 R6= 10
>         [1, 0, 1, 1, 2,  75], -- R1 :=   x   =  75. R1=  0 R2=135
>         [1, 1, 1, 1, 2,   0], -- R1 := R1+R2 = 210. R1= 75 R2=135
>         [0, 0, 0, 1, 2,   0], -- nop                R1=210 R2=135
>         [0, 0, 0, 0, 0,   0]] -- nop                R0=  0 R0=  0
</programlisting>

<para>
The simulation driver will print the input values for each clock
cycle, and then it will show the outputs produced by the register
transfer machine:
  -- reg[sa], the register addressed by sa
  -- reg[sb], the register addressed by sb
  -- the selected data value,
        which will either be reg[sa]+reg[sb] or x,
        and which *might* get loaded into a register
  -- the sum produced by the adder
       (this is the value of  reg[sa] + reg[sb]

You can run it by entering
</para>

<programlisting>
sim_rtm rtm_input1
  
</programlisting>

<para>
Here's the simulation driver, which you can ignore.  It just takes
care of formatting and number conversions.
</para>

<programlisting>
> sim_rtm input =
>   let n = 16  -- each register contains 16 bits
>       k =  4  -- there are 2^4 = 16 registers
>       ld  = getbit   input 0
>       add = getbit   input 1
>       d   = getbin k input 2
>       sa  = getbin k input 3
>       sb  = getbin k input 4
>       x   = getbin n input 5
>       (a,b,y,c,s) = rtm n k ld add d sa sb x
>       simoutput :: [Format Bool]
>       simoutput =
>         [string "Input: ",
>          bit ld, bit add, bindec 2 d, bindec 2 sa, bindec 2 sb,
>          bindec 4 x,
>          string "  Output: ",
>          bindec 4 a, bindec 4 b, bindec 4 y, bindec 4 s]
>   in do putStrLn "\nSimulate register transfer machine"
>         run input simoutput
</programlisting>

<para>
Simulating the Register Transfer Machine
</para>

<programlisting>
> sim_rtm2 =
>   let n = 30
>       k = 5
>       input =
> --      ld add d sa sb   x
> --      ~~~~~~~~~~~~~~~~~~~
>        [[1, 0, 3, 0, 0, 125], -- R3 :=   x   = 125. R0=  0 R0=  0
>         [1, 0, 6, 3, 0,  10], -- R6 :=   x   =  10. R3=125 R0=  0
>         [1, 1, 2, 3, 6,   0], -- R2 := R3+R6 = 135. R3=125 R6= 10
>         [1, 0, 1, 1, 2,  75], -- R1 :=   x   =  75. R1=  0 R2=135
>         [1, 1, 1, 1, 2,   0], -- R1 := R1+R2 = 210. R1= 75 R2=135
>         [0, 0, 0, 1, 2,   0], -- nop                R1=210 R2=135
>         [0, 0, 0, 0, 0,   0]]
>       ld  = getbit   input 0
>       add = getbit   input 1
>       d   = getbin k input 2
>       sa  = getbin k input 3
>       sb  = getbin k input 4
>       x   = getbin n input 5
>       (a,b,y,c,s) = rtm n k ld add d sa sb x
>       simoutput :: [Format Bool]
>       simoutput =
>         [string "Input: ",
>          bit ld, bit add, bindec 2 d, bindec 2 sa, bindec 2 sb,
>          bindec 4 x,
>          string "  Output: ",
>          bindec 4 a, bindec 4 b, bindec 4 y, bindec 4 s]
>   in do putStrLn "\nSimulate register transfer machine"
>         run input simoutput

</programlisting>

<para>
Simulating the Multiplier
</para>

<programlisting>
> sim_mult =
>   let k = 8
>       input =
> --     start  x    y
> --     ~~~~~~~~~~~~~~
>        [[1,  50,  75],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [1, 100, 100],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [1, 100, 100],
>         [0,   0,   0],
>         [0,   0,   0],
>         [1,   2,   3],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0]]
>       start = getbit   input 0
>       x     = getbin k input 1
>       y     = getbin k input 2
>       (rdy,prod,rx,ry,s) = mult k start x y
>       spec :: [Format Bool]
>       spec =
>         [string "Input: ",
>          bit start, bindec 4 x, bindec 4 y,
>          string "  Output: ",
>          bit rdy, bindec 6 prod, bindec 4 rx, bindec 6 ry,
>          bindec 6 s]
>     in do putStrLn "\nSimulate sequential multiplier"
>           run input spec

</programlisting>

<para>
Running the simulations as batch job
</para>

<para>
This is a single operation that runs the various examples above as one
large batch.  You can run it by just launching Hydra, loading this
file, and entering "main" at the prompt.
</para>

<programlisting>
> main =
>   do putStrLn "Hydra: running Tutorial1 batch"
>      sim_adder rippleAdd 16 add_input1
>      sim_sr4 sr4_testdata_1
>      sim_regfile
>      sim_regfile_dec
>      sim_rtm2
>      sim_mult
>      putStrLn "Examples1 finished"
</programlisting>


<para>
Simulating the Register Transfer Machine
</para>

<para>
On each clock cycle, the register transfer machine can read out two
registers (specified by the sa, sb addresses), calculate a data value,
and load that data value into reg[d] if the load control ld=1.  The
data value can be either the data input x, or the sum produced by the
adder, and the add control signal determines which value is chosen.
If add=1 then the adder's output is selected and otherwise x is used.
Here is some sample input data, along with comments that describe what
is going on.
</para>

<programlisting>
> rtm_input1 :: [[Int]]
> rtm_input1 =
> --      ld add d sa sb   x
> --      ~~~~~~~~~~~~~~~~~~~
>        [[1, 0, 3, 0, 0, 125], -- R3 :=   x   = 125. R0=  0 R0=  0
>         [1, 0, 6, 3, 0,  10], -- R6 :=   x   =  10. R3=125 R0=  0
>         [1, 1, 2, 3, 6,   0], -- R2 := R3+R6 = 135. R3=125 R6= 10
>         [1, 0, 1, 1, 2,  75], -- R1 :=   x   =  75. R1=  0 R2=135
>         [1, 1, 1, 1, 2,   0], -- R1 := R1+R2 = 210. R1= 75 R2=135
>         [0, 0, 0, 1, 2,   0], -- nop                R1=210 R2=135
>         [0, 0, 0, 0, 0,   0]] -- nop                R0=  0 R0=  0
</programlisting>

<para>
The simulation driver will print the input values for each clock
cycle, and then it will show the outputs produced by the register
transfer machine:
  -- reg[sa], the register addressed by sa
  -- reg[sb], the register addressed by sb
  -- the selected data value,
        which will either be reg[sa]+reg[sb] or x,
        and which *might* get loaded into a register
  -- the sum produced by the adder
       (this is the value of  reg[sa] + reg[sb]

You can run it by entering
</para>

<programlisting>
sim_rtm rtm_input1
</programlisting>

<para>
Here's the simulation driver, which you can ignore.  It just takes
care of formatting and number conversions.
</para>

<programlisting>
> sim_rtm input =
>   let n = 16  -- each register contains 16 bits
>       k =  4  -- there are 2^4 = 16 registers
>       ld  = getbit   input 0
>       add = getbit   input 1
>       d   = getbin k input 2
>       sa  = getbin k input 3
>       sb  = getbin k input 4
>       x   = getbin n input 5
>       (a,b,y,c,s) = rtm n k ld add d sa sb x
>       simoutput :: [Format Bool]
>       simoutput =
>         [string "Input: ",
>          bit ld, bit add, bindec 2 d, bindec 2 sa, bindec 2 sb,
>          bindec 4 x,
>          string "  Output: ",
>          bindec 4 a, bindec 4 b, bindec 4 y, bindec 4 s]
>   in do putStrLn "\nSimulate register transfer machine"
>         run input simoutput

</programlisting>

<para>
Simulating the Register Transfer Machine
</para>

<programlisting>
> sim_rtm2 =
>   let n = 30
>       k = 5
>       input =
> --      ld add d sa sb   x
> --      ~~~~~~~~~~~~~~~~~~~
>        [[1, 0, 3, 0, 0, 125], -- R3 :=   x   = 125. R0=  0 R0=  0
>         [1, 0, 6, 3, 0,  10], -- R6 :=   x   =  10. R3=125 R0=  0
>         [1, 1, 2, 3, 6,   0], -- R2 := R3+R6 = 135. R3=125 R6= 10
>         [1, 0, 1, 1, 2,  75], -- R1 :=   x   =  75. R1=  0 R2=135
>         [1, 1, 1, 1, 2,   0], -- R1 := R1+R2 = 210. R1= 75 R2=135
>         [0, 0, 0, 1, 2,   0], -- nop                R1=210 R2=135
>         [0, 0, 0, 0, 0,   0]]
>       ld  = getbit   input 0
>       add = getbit   input 1
>       d   = getbin k input 2
>       sa  = getbin k input 3
>       sb  = getbin k input 4
>       x   = getbin n input 5
>       (a,b,y,c,s) = rtm n k ld add d sa sb x
>       simoutput :: [Format Bool]
>       simoutput =
>         [string "Input: ",
>          bit ld, bit add, bindec 2 d, bindec 2 sa, bindec 2 sb,
>          bindec 4 x,
>          string "  Output: ",
>          bindec 4 a, bindec 4 b, bindec 4 y, bindec 4 s]
>   in do putStrLn "\nSimulate register transfer machine"
>         run input simoutput
</programlisting>

<para>
 A Simple CPU 
</para>

<para>
fragments
</para>


<para>
The truth table functions used so far default labels for the columns,
which can sometimes make the tables confusing.  There are alternative
versions of the functions that let you specify strings for the column
headings.  These functions have an underscore at the ends of their
names, and they take the appropriate number of String arguments.
</para>

<programlisting>
truthTable21_ "input1" "input2" "output" xor2
</programlisting>

<para>
4. Simulate a circuit in your working directory
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To test the circuit definition in your working directory, do the
following:

1. Launch the system by entering the shell command
      hydra

2. Load your module TestCirc, and a Hydra module named BoolModel, by
   entering after the prompt
      :load TestCirc BoolModel

3. Place these modules in scope by entering
      :module + MyCircuit BoolModel

4. Try a test simulation by entering
      truthTable31 my_circ

This should produce output similar to the following:

...........................................................................
[jtod@localhost ~/testinghydra]$ hydra
   ___         ___ _
  / _ \ /\  /\/ __(_)
 / /_\// /_/ / /  | |      GHC Interactive, version 6.2.1, for Haskell 98.
/ /_\\/ __  / /___| |      http://www.haskell.org/ghc/
\____/\/ /_/\____/|_|      Type :? for help.
 
Loading package base ... linking ... done.
Loading package haskell98 ... linking ... done.
Loading package haskell-src ... linking ... done.
Prelude> :load TestCirc BoolModel
Compiling Signal  ...

{... more messages appear ...}

*BoolModel> :module + MyCircuit BoolModel
*BoolModel MyCircuit> truthTable31 my_circ
    0 0 0 | 0
    0 0 1 | 1
    0 1 0 | 0
    0 1 1 | 1
    1 0 0 | 0
    1 0 1 | 1
    1 1 0 | 1
    1 1 1 | 1
*BoolModel MyCircuit>
...........................................................................
</para>


</sect1>


</chapter>

<chapter><title>Tu5pat.hs: Design patterns</title>

<para>
foo
</para>

<sect1><title>Design Patterns</title>

<sect2><title>Mapping</title>

<para>
Often we need to process a word by running each bit through a circuit.
For example, this circuit inverts each bit in a 4-bit word:
</para>

<para>
  <inlinemediaobject>
    <imageobject>
      <imagedata fileref="figures/xfig/map4inv.png" format="PNG" />
    </imageobject>
    <imageobject>
	<imagedata fileref="figures/xfig/map4inv.eps" format="EPS" />
    </imageobject>
    <textobject>
	<phrase>[y0,y1,y2,y3] = map f [x0,x1,x2,x3]</phrase>
    </textobject>
  </inlinemediaobject>
</para>

<para>
It is straightforward to design a circuit inv4 to do the job:
</para>

<programlisting>
inv4 [x0,x1,x2,x3] = [y0,y1,y2,y3]
  where y0 = inv x0
        y1 = inv x1
        y2 = inv x2
        y3 = inv x3
</programlisting>

<para>
Now the inv4 circuit can be used to define the output signals y0,
etc.:
</para>

<programlisting>
[y0,y1,y2,y3] = inv4 [x0,x1,x2,x3]
</programlisting>

<para>
The diagram can be simplified by treating the group of inverters as a
black box called inv4, which takes a 4-bit input and produces a 4-bit
output.  This was the diagram shows words rather than bits, making it
considerably more concise.
</para>

<para>
  <inlinemediaobject>
    <imageobject>
      <imagedata fileref="figures/xfig/map4invbox.png" format="PNG" />
    </imageobject>
    <imageobject>
	<imagedata fileref="figures/xfig/map4invbox.eps" format="EPS" />
    </imageobject>
    <textobject>
	<phrase>[y0,y1,y2,y3] = map f [x0,x1,x2,x3]</phrase>
    </textobject>
  </inlinemediaobject>
</para>

<para>
The inv4 circuit works just fine, but there are two disadvantages with
the way we defined it.
</para>

<itemizedlist>
<listitem>
<para>
We might also need an 8-bit version of the circuit, and perhaps yet
more versions at various word sizes.  All of these definitions will be
quite similar to the definition above of inv4, but we'll keep having
to define new ones.
</para>
</listitem>
<listitem>
<para>
Even worse, consider what happens at large word sizes.  If you write a
64-bit version, inv64, there will be 64 equations within the
definition.  This is tedious and unreliable. A typographical error in
any of the equation would be easy to make and hard to spot.
</para>
</listitem>
</itemizedlist>

<para>
When you see the 4-bit version of the circuit, the pattern becomes
obvious, and a human can easily design a version for an arbitrary word
size just by following the pattern.
</para>

<para>
Design patterns allow computers to understand and use regular
circuits, like the examples above.  Hydra provides a design pattern,
called <emphasis>map</emphasis>, for defining circuits that have the
same structure as inv4.  Instead of making an explicit definition of
the inv4 circuit, you can just replace an application of inv4 by the
expression <emphasis>map inv</emphasis>.  Thus an equation

<programlisting>
[y0,y1,y2,y3] = inv4 [x0,x1,x2,x3]
</programlisting>

can be rewritten,  replacing inv4 by map inv, as follows:

<programlisting>
[y0,y1,y2,y3] = map inv [x0,x1,x2,x3]
</programlisting>
</para>

<para>
The previous example shows how you can use map to avoid defining inv4.
If you still would like to have the inv4 circuit, however, you can
define it with the following equation:

<programlisting>
inv4 = map inv
</programlisting>

This equation says that "inv4" and "map inv" are the same, which
justifies the comment above that you can replace inv4 by map inv.
</para>

<para>
In general, the map pattern is used whenever a circuit has the
following structure, where f can denote any circuit that takes an
input and produces an output.
</para>

<para>
  <inlinemediaobject>
    <imageobject>
      <imagedata fileref="figures/xfig/map4.png" format="PNG" />
    </imageobject>
    <imageobject>
	<imagedata fileref="figures/xfig/map4.eps" format="EPS" />
    </imageobject>
    <textobject>
	<phrase>[y0,y1,y2,y3] = map f [x0,x1,x2,x3]</phrase>
    </textobject>
  </inlinemediaobject>
</para>

<para>
To generate the set of f-boxes, and the necessary wiring, you just
write map f.  This gives you a circuit that has an instance of the f
circuit for every element of the input list.
</para>

<para>
  <inlinemediaobject>
    <imageobject>
      <imagedata fileref="figures/xfig/map4box.png" format="PNG" />
    </imageobject>
    <imageobject>
	<imagedata fileref="figures/xfig/map4box.eps" format="EPS" />
    </imageobject>
    <textobject>
	<phrase>[y0,y1,y2,y3] = map f [x0,x1,x2,x3]</phrase>
    </textobject>
  </inlinemediaobject>
</para>

<para>
To invert all the bits of a 4-bit word, we can write:

<programlisting>
[y0,y1,y2,y3] = map inv [x0,x1,x2,x3]
</programlisting>
</para>

<para>
This works for any word size:
<programlisting>
[p,q] = map inv [x,y]
[a,b,c,d,e] = map inv [u,v,w,x,y]
</programlisting>

</para>

<para>
How does map know how many inverters to use?  The answer is that at
compile time, the map pattern inspects the input word and generates
an instance of the inverter for every element of the input word.  Thus
if we write

<programlisting>
[y0,y1,y2] = winv [x0,x1,x2]
</programlisting>

the map pattern sees that the input word contains three elements, so
it generates three inverters, does the necessary wiring, and defines
the three output signals.
</para>

<para>
A general word inverter can be defined using map:

<programlisting>
winv :: Signal a => [a] -> [a]
winv x = map inv x
</programlisting>

This winv is not a specific circuit; it is a
<emphasis>family</emphasis> of circuits, all with the same structure,
corresponding to every word size 0, 1, 2, ...  That is, winv can
invert a word of size n, for any natural number n.
</para>

<para>
Naturally, the map pattern can be used with any building block
circuit; it doesn't need to be an inverter.  We can amplify all the
signals in a word using buffers:
<programlisting>
[a',b',c',d'] = map buf [a,b,c,d]
</programlisting>
</para>




<programlisting>
map :: (a->b) -> [a] -> [b]
</programlisting>


<programlisting>
> map2 :: (a->b->c) -> [a] -> [b] -> [c]
</programlisting>

<para>
Explicitly Sized Map
</para>

<programlisting>
> mapn :: (a->b) -> Int -> [a] -> [b]
</programlisting>

<programlisting>
> reg :: Clocked a => Int -> a -> [a] -> [a]
> reg n ld x = mapn (reg1 ld) n x
</programlisting>

<programlisting>
> mux1w :: Signal a => a -> [a] -> [a] -> [a]
> mux1w c x y = map2 (mux1 c) x y
</programlisting>

</sect2>

<sect2><title>Bit Slice Organization</title>

<programlisting>
> bitslice2 :: [a] -> [a] -> [(a,a)]
> bitslice2 = zip
</programlisting>

<programlisting>
> unbitslice2 :: [(a,b)] -> ([a],[b])
> unbitslice2 [] = ([],[])
> unbitslice2 ((x,y):zs) =
>   let (xs,ys) = unbitslice2 zs
>   in (x:xs, y:ys)
</programlisting>

<programlisting>
> zipn :: Int -> [a] -> [b] -> [(a,b)]
> zipn n x y =
>   [(x!!i,y!!i) | i FROM- [0..n-1]]
</programlisting>

<programlisting>
> unzipn n xs =
>   ([fst (xs!!i) | i FROM- [0..n-1]],
>    [snd (xs!!i) | i FROM- [0..n-1]])
</programlisting>

</sect2>

<sect2><title>Folding</title>

<para>
z= foldl f a [x0, x1, x2, x3]
</para>

<para>
  <inlinemediaobject>
    <imageobject>
      <imagedata fileref="figures/xfig/foldl4.png" format="PNG" />
    </imageobject>
    <imageobject>
	<imagedata fileref="figures/xfig/foldl.eps" format="EPS" />
    </imageobject>
    <textobject>
	<phrase>[y0,y1,y2,y3] = map f [x0,x1,x2,x3]</phrase>
    </textobject>
  </inlinemediaobject>
</para>

<para>
The following figure shows the same circuit a little more abstractly,
treating the internal f boxes and wires as a black box circuit.  The
inputs are the word of x bits and the singleton a, and the output is
the singleton z, and the circuit itself is described as "foldl f".
</para>

<para>
  <inlinemediaobject>
    <imageobject>
      <imagedata fileref="figures/xfig/foldl4box.png" format="PNG" />
    </imageobject>
    <imageobject>
	<imagedata fileref="figures/xfig/foldl4box.eps" format="EPS" />
    </imageobject>
    <textobject>
	<phrase>[y0,y1,y2,y3] = map f [x0,x1,x2,x3]</phrase>
    </textobject>
  </inlinemediaobject>
</para>

<programlisting>
foldr :: (b->a->a) -> a -> [b] -> a
foldr f a [] = a
foldr f a (x:xs) = f x (foldr f a xs)
</programlisting>

<para>
z= foldr f a [x0, x1, x2, x3]
</para>

<para>
  <inlinemediaobject>
    <imageobject>
      <imagedata fileref="figures/xfig/foldr4.png" format="PNG" />
    </imageobject>
    <imageobject>
	<imagedata fileref="figures/xfig/foldr4.eps" format="EPS" />
    </imageobject>
    <textobject>
	<phrase>[y0,y1,y2,y3] = map f [x0,x1,x2,x3]</phrase>
    </textobject>
  </inlinemediaobject>
</para>

<para>
The following figure shows the same circuit a little more abstractly,
treating the internal f boxes and wires as a black box circuit.  The
inputs are the word of x bits and the singleton a, and the output is
the singleton z, and the circuit itself is described as "foldr f".
</para>

<para>
  <inlinemediaobject>
    <imageobject>
      <imagedata fileref="figures/xfig/foldr4box.png" format="PNG" />
    </imageobject>
    <imageobject>
	<imagedata fileref="figures/xfig/foldr4box.eps" format="EPS" />
    </imageobject>
    <textobject>
	<phrase>[y0,y1,y2,y3] = map f [x0,x1,x2,x3]</phrase>
    </textobject>
  </inlinemediaobject>
</para>

<para>
Binary comparitor
</para>

<programlisting>
> cmp1 :: Signal a => (a,a,a) -> (a,a) -> (a,a,a)
> cmp1 (lt,eq,gt) (x,y) =
>   (or2 lt (and3 eq (inv x) y),
>    and2 eq (inv (xor2 x y)),
>    or2 gt (and3 eq x (inv y))
>   )
</programlisting>

<programlisting>
> rippleCmp :: Signal a => [(a,a)] -> (a,a,a)
> rippleCmp = foldl cmp1 (zero,one,zero)
</programlisting>

</sect2>

<sect2><title>Scanning</title>

<programlisting>
> wscanr :: (b->a->a) -> a -> [b] -> [a]
> wscanr f a xs =
>   [foldr f a (drop (i+1) xs) | i FROM- [0 .. length xs -1]]
</programlisting>

<programlisting>
> ascanr ::  (b->a->a) -> a -> [b] -> (a,[a])
> ascanr f a [] = (a,[])
> ascanr f a (x:xs) =
>   let (a',xs') = ascanr f a xs
>       a'' = f x a'
>   in (a'', a':xs')
</programlisting>

<para>
Inclusive Scans

Mapping Scans


Bidirectional Scans

Shift register
</para>

<programlisting>
> sr :: (Signal a, Clocked a)
>   => (a,a) -> a -> a -> [a] -> (a,a,[a])
> sr op l r xs = mscan (srb' op) l r xs
>   where srb' a b c d = fanout3 (srb a b c d)
</programlisting>

</sect2>

<sect2><title>Tree Patterns</title>

<para>
Tree Expansion: Downsweep


Tree Reduction: Upsweep

And/Or over a word
</para>

<para>
Determine whether there exists a 1 in a word, or whether all the
bits are 0.  A tree fold can do this in log time, but for
simplicity this is just a linear time fold.
</para>

<programlisting>
> any1, all0 :: Signal a => [a] -> a
> any1 = foldl or2 zero
> all0 = foldl and2 one
</programlisting>

<programlisting>
> orw :: Signal a => [a] -> a
> orw = foldl or2 zero
</programlisting>

<para>

Bidirectional Tree Sweep
</para>

</sect2>

<sect2><title>Explicit Recursion</title>

<para>
See Section \ref{sec:register-file}, which uses a recursive pattern to
define the register file circuit.
</para>

</sect2>
</sect1>



</chapter>

<chapter><title>Tu6lib.hs: Modules and libraries</title>

<sect1><title>Organizing large specifications</title>
<para>
A Hydra file, like this one, begins with a statement that gives a name
to the module; this one is named Tutorial1.
</para>

<programlisting>
> module Tutorial1 where
</programlisting>

<para>
The file name should be Tutorial1.lhs, where Tutorial1 is the name of
the module.
</para>

<para>
After the "module" statement there should be one or more "import"
statements saying which other library modules need to be loaded.  The
first line, "import Hydra", loads all the Hydra software tools, and
the second one, "import CircuitLib", loads a collection of standard
basic circuits.  There are many other combinations of modules that can
be imported, depending on what you want to do; these will be explored
in subsequent tutorials.
</para>

<programlisting>
> import Hydra        -- The basic system
> import CircuitLib   -- Library of basic circuits

</programlisting>

<para>
Commands begin with :, and :load says to load a file.  (You can also
write it as :l, as in ":l Tutorial1").  The system will print a number
of messages as it loads the libraries, and then it will give another
prompt, which should look like this:
</para>

<programlisting>
Tutorial1> 
</programlisting>




<para>
Structure of a specification file
</para>

<para>
If a circuits has several inputs, just separate them by spaces.
For example, the two-input logical and gate can be simulated as follows.
</para>

<para>
A circuit with several inputs, like the two-input and gate
<emphasis>and2</emphasis>, and the three-input exclusive or gate
<emphasis>xor3</emphasis>, is handled the same way.  Just write the
inputs after the circuit, separated by spaces; don't put in any
extraneous punctuation.
</para
>
<para>
Using existing circuits
</para>

<para>
To use a black box circuit specification, you need to (1) load the
file, and the simulation model you want to use; and (2) add these
definitions to the set of definitions that are in scope.  For example,
the file <emphasis>Example1.hs</emphasis>, located in the
<emphasis>doc/examples</emphasis> directory, contains some simple
circuit definitions which we would like to simulate using the Boolean
model.
</para>

<para>
To run the examples, we need to compile and load both the circuit
definitions (Example1) and the Boolean simulation model (BoolModel).
This is done using the <emphasis>:load</emphasis> command.
Furthermore, the definitions in both of these files need to be brought
into scope so they can be used; that is done with the
<emphasis>:module</emphasis> command.  The complete commands to enter
are as follows:
</para>

<programlisting>:load Example1 BoolModel
:module + Example1 BoolModel
</programlisting>

<para>
Now the prompt will change to <emphasis>*BoolModel
Example1></emphasis>, which shows exactly which definitions will
actually be used.  Now the truth table for
<emphasis>circuit1</emphasis> can be generated by entering
<emphasis>truthTable31 circuit1</emphasis>.
</para>

<programlisting>
Prelude> :load Example1 BoolModel
Compiling ...
Ok, modules loaded: ...
*BoolModel> :module + Example1 BoolModel
*BoolModel Example1> truthTable31 circuit1
    0 0 0 | 1
    0 0 1 | 0
    0 1 0 | 0
    0 1 1 | 0
    1 0 0 | 1
    1 0 1 | 0
    1 1 0 | 1
    1 1 1 | 1
*BoolModel Example1>
</programlisting>

<para>
A variety of useful circuits are defined in the Hydra file
directories.  It is worth becoming familiar with them, both because it
can save time to reuse them, and also because they provide plenty of
examples of circuit designs.
</para>


<sect2><title>Files</title>

<para>
A Hydra file, like this one, begins with a statement that gives a name
to the module (this module is named Tutorial1).
</para>

<programlisting>
module LogicGates where
</programlisting>

<para>
After the "module" statement there should be one or more "import"
statements saying which other library modules need to be loaded.  The
first line, "import Hydra", loads all the Hydra software tools, and
the second one, "import StdCircuit", loads the standard library of
circuits provided by Hydra.  There are many other combinations of
modules that can be imported, depending on what you want to do, but
usually it's most convenient to import just these two.
</para>

<programlisting>
import Hydra
import CircuitLib
</programlisting>

<para>
Here's a definition of a new circuit, named `circ1'.
</para>

<programlisting>
circ1 :: Signal a => a -> a -> a
circ1 x y = and2 (inv x) y
</programlisting>

<para>
It can be tested by checking its truth table:
</para>

<programlisting>
truthTable21 circ1
</programlisting>

<para>
Commands begin with :, and :l says to load a file (you can also write
it as :load).  The Haskell interpreter will load various Hydra files,
and then give another prompt, which should look like
</para>

<programlisting>
Tutorial1> 
</programlisting>

<para>
This means you can do simulations using all the definitions contained
in this file, as well as the standard Hydra definitions (those are
available because of the import statements near the beginning of this
file).
</para>
</sect2>

<sect2><title>Importing modules</title>

<para>
foo
</para>
</sect2>

<sect2><title>The Hydra circuit library</title>

<para>
foo
</para>
</sect2>

</sect1>

<sect1><title>Basic combinational circuits</title>

<sect2><title>Constant signals</title>

<para>
There are two constant signal values, which are written as
<emphasis>zero</emphasis> and <emphasis>one</emphasis>.
</para>

<para>
For example, if you want to make the first input to an and3 gate a
signal named x, the second input a constant one, and the third input a
signal named y, you can write <programlisting>and3 x one
y</programlisting>.
</para>

<para>
Do <emphasis>not</emphasis> write 0 or 1 to denote a constant signal.
These are numbers, and numbers are used in Hydra to describe sizes of
circuits (for example, how many bits are in a word).  Numbers are
never used as signal values in Hydra.
</para>

<para>
It is possible to write False or True to denote constant signals, but
normally this is not a good idea.  The reason is that False and True
are usable only when the Bool model for signals is being used, and
that means that you are limited to performing simple untimed boolean
simulations.  Normally you will want to use a circuit specification
for several different purposes, and that will require using
alternative signal models that are incompatible with False and True.
In contrast, the constant signals, zero and one, are valid for all
signal models.
</para>

<para>
To summarize, always write constant signals as either
<emphasis>zero</emphasis> or <emphasis>one</emphasis>.
</para>

</sect2>

<sect2><title>Logic gates</title>

<para>
The commonly used logic gates are described in this section.  There
are two logic gates that take one input: the inverter and the buffer.
</para>

<para>
The most commonly used logic gates are shown in Tables
\ref{tab:1-input-gates} and \ref{tab:n-input-gates}.
</para>

<programlisting>
\begin{table}[htbp]
  \begin{center}
    \caption{Logic gates with one input}
    \label{tab:1-input-gates}
\begin{tabular}[c]{ll}
\textit{buf}    buffer: output = input \\
\textit{inv}    inverter: logical negation \\
\end{tabular}
  \end{center}
\end{table}

\begin{table}[htbp]
\begin{center}
\caption{Families of Logic Gates}
\label{tab:n-input-gates}
\begin{tabular}[c]{llll}
\textit{and2}   and3   and4   logical and \\
or2    or3    or4    inclusive or \\
xor2   xor3   xor4   exclusive or \\
nand2  nand3  nand4  not-and \\
nor2   nor3   nor4   not-or
\end{tabular}
\end{center}
\end{table}
</programlisting>

<para>
The simplest way to simulate a logic gate is to give it input signals
of type Bool, which has the values True and False.  Try the following
examples by entering each expression after the prompt and pressing
enter:
</para>

<programlisting>
  inv True
  inv False
  and2 False True
  and2 True True
</programlisting>

<para>
A convenient way to run such examples is to select (Copy) the text in
this file, and then paste it into the window where you're executing
Hydra.
</para>
</sect2>

<sect2><title>more</title>

<para>
The inverter logic gate, called <emphasis>inv</emphasis>, outputs the
logical negation of its input.
</para>

<programlisting>
*Tu01int> truthTable11 inv
    0 | 1
    1 | 0
*Tu01int>
</programlisting>

<para>
Recall that to provide inputs to a circuit, you apply it to the corresponding
values.  This is expressed by writing the name of the circuit,
followed by the input values, separated by spaces.  For example, to
say that in inverter is given the input of False, you write
<emphasis>inv False</emphasis>.  The result of this expression is the
output value produced by the circuit, and you can simulate the circuit
by entering the expression interactively.  For example, enter the
expression <emphasis>inv False</emphasis> and the result is:
</para>

<programlisting>
*Tu01int> inv True
False
*Tu01int> inv False
True
</programlisting>

<para>
The buffer, called <emphasis>buf</emphasis>, outputs the same value
that it receives on its input; it performs the identity function.
</para>

<programlisting>
*Tu01int> truthTable11 buf
    0 | 0
    1 | 1
*Tu01int>
</programlisting>

<para>
There are several logical and-gates in the standard Hydra libraries,
and their names reflect the number of inputs.  Thus
<emphasis>and2</emphasis> is the 2-input and gate,
<emphasis>and3</emphasis> takes three inputs, and
<emphasis>and4</emphasis> takes four inputs.  The truth tables for the
family of and gates are generated as follows:
</para>


<programlisting>
*Tu01int> truthTable21 and2
    0 0 | 0
    0 1 | 0
    1 0 | 0
    1 1 | 1
*Tu01int> truthTable31 and3
    0 0 0 | 0
    0 0 1 | 0
    0 1 0 | 0
    0 1 1 | 0
    1 0 0 | 0
    1 0 1 | 0
    1 1 0 | 0
    1 1 1 | 1
*Tu01int> truthTable41 and4
    0 0 0 0 | 0
    0 0 0 1 | 0
    0 0 1 0 | 0
    0 0 1 1 | 0
    0 1 0 0 | 0
    0 1 0 1 | 0
    0 1 1 0 | 0
    0 1 1 1 | 0
    1 0 0 0 | 0
    1 0 0 1 | 0
    1 0 1 0 | 0
    1 0 1 1 | 0
    1 1 0 0 | 0
    1 1 0 1 | 0
    1 1 1 0 | 0
    1 1 1 1 | 1
*Tu01int>
</programlisting>

<para>
There is, of course, a close mathematical relationship among the
various and gates, but it is important to recognise that they are
distinct hardware devices, and they are not interchangeable. Informal
terminology is commonly used for describing digital circuits.  For
example, many authors refer to an <emphasis>and gate</emphasis> as the
logic gate that outputs True if all its inputs are True, and they use
and gates with two inputs, three inputs, or however many are required,
all under the same name "and gate".  Nonetheless, the 2-input gate
<emphasis>and2</emphasis> and the 3-input gate
<emphasis>and2</emphasis> are different electronic components: they
have different interfaces (different numbers of ports that must be
connected to wires), and they have different internal structures.
Informal terminology may be adequate for describing circuits to
humans, who can be expected to figure out the ambiguities.  Precise
notation is better when writing formal circuit descriptions that will
be used by automated software tools, such as simulators.  Therefore
Hydra uses a unique name for every logic gate: thus the and gates with
two or three inputs are called <emphasis>and2</emphasis> and
<emphasis>and3</emphasis> respectively.
</para>

<para>
There is a family of logical inclusive or gates, called
<emphasis>or2</emphasis>, <emphasis>or2</emphasis>, and
<emphasis>or4</emphasis>, and a family of logical exclusive or gates,
called <emphasis>xor2</emphasis>, <emphasis>xor3</emphasis>, and
<emphasis>xor4</emphasis>.  Here are some examples:</para>

<programlisting>
*Tu01int> truthTable21 or2
    0 0 | 0
    0 1 | 1
    1 0 | 1
    1 1 | 1
*Tu01int> truthTable21 xor2
    0 0 | 0
    0 1 | 1
    1 0 | 1
    1 1 | 0
*Tu01int> truthTable31 xor3
    0 0 0 | 0
    0 0 1 | 1
    0 1 0 | 1
    0 1 1 | 0
    1 0 0 | 1
    1 0 1 | 0
    1 1 0 | 0
    1 1 1 | 1
*Tu01int>
</programlisting>

<para>
The standard logic components supported by Hydra are listed below.
The language is case-sensitive; that is, upper and lower case letters
are considered to be different.  Therefore you must use these names
exactly as written: write <emphasis>and2</emphasis>, never
<emphasis>And2</emphasis>.
</para>

<para>
There are two constant signals, called <emphasis>zero</emphasis> and
<emphasis>one</emphasis>.  When you're using the Boolean model,
<emphasis>False</emphasis> can be used in place of
<emphasis>zero</emphasis> and <emphasis>True</emphasis> can be used in
place of <emphasis>one</emphasis>.  The reason for making these
distictions will be discussed later.
</para>





<para>
Hydra provides many logic gates, which are listed below.
</para>


<itemizedlist>

  <listitem>
    <para>1-input logic gates</para>
    <itemizedlist>
      <listitem>
	<para>buf :: Signal a => a -> a.  A buffer amplifies the input
	signal but doesn't change it; the output has the same value as
	the input.
	</para>
      </listitem>
      <listitem>
	<para>inv :: Signal a => a -> a.  An inverter outputs the
	logical negation of its input.
	</para>
      </listitem>
    </itemizedlist>
  </listitem>
  <listitem>
    <para>Logical and gates
    </para>
    <itemizedlist>
      <listitem><para>and2 -- a 2-input and gate:</para></listitem>
      <listitem><para>and3 -- a 3-input and gate:</para></listitem>
      <listitem><para>and4 -- 4-input and gate:</para></listitem>
    </itemizedlist>
  </listitem>
  <listitem><para>Logical not-and gates</para>
  <itemizedlist>
    <listitem><para>nand2 -- a 2-input not-and gate:</para></listitem>
    <listitem><para>nand3 -- a 3-input not-and gate:</para></listitem>
    <listitem><para>nand4 -- 4-input not-and gate:</para></listitem>
  </itemizedlist>
  </listitem>
  <listitem><para>Logical inclusive or gates</para>
  <itemizedlist>
    <listitem><para>or2 -- a 2-input or gate:</para></listitem>
    <listitem><para>or3 -- a 3-input or gate:</para></listitem>
    <listitem><para>or4 -- 4-input or gate:</para></listitem>
  </itemizedlist>
  </listitem>
  <listitem><para>Logical inclusive not-or gates</para>
  <itemizedlist>
    <listitem><para>nor2 -- a 2-input not-or gate:</para></listitem>
    <listitem><para>nor3 -- a 3-input not-or gate:</para></listitem>
    <listitem><para>nor4 -- 4-input not-or gate:</para></listitem>
  </itemizedlist>
  </listitem>
  <listitem><para>Logical exclusive or gates</para>
  <itemizedlist>
    <listitem><para>xor2 -- a 2-input exclusive or gate:</para></listitem>
    <listitem><para>xor3 -- a 3-input exclusive or gate:</para></listitem>
    <listitem><para>xor4 -- 4-input exclusive or gate:</para></listitem>
  </itemizedlist>
  </listitem>
</itemizedlist>

<para>
It is important to note that gates with similar functions but
different numbers of inputs (e.g. or2, or3, or4) are considered to be
different components.  In physical hardware, they are different
circuits, with different numbers of wires connected to them.  You
can't just interchange one circuit with another that has a different
number of physical connections.  This is reflected in Hydra by giving
different names to distinct components.  In common usage, the or2, or3
and or4 components are often just called "or gates", but you have to
use the right one in a circuit specification.
</para>

</sect2>

<sect2><title>Fanout</title>

<para>
While designing combinational circuits, it is often necessary to make
one or more duplicate copies of a signal $x$.  This is called
\textit{fanout}, because a wire splits and ``fans out'' to several
destinations.
</para>

<para>
Fanout can be specified implicitly simply by using a signal in several
places.  For example, in the following definition the signal $x$ is
defined in one place, but used in several places, so the wire carrying
$x$ must fan out to each of the points where it is used.
</para>

<programlisting>
circ a = ...
  where x = ...
        y = ... x ...
        z = ... x ...
</programlisting>

<para>
The fanout is implicit because the specification does not directly
mention it.
</para>

<para>
Sometimes it is better to specify fanout explicitly.  There are many
reasons for this.  Excessive fanout may cause delays or capacitance
problems in the circuit.  Since these issues belong at the electronic
level of abstraction, they are not apparent when simulating a circuit
at the logical level.  Such problems can be controlled by specifying
fanout explicitly.  Furthermore, fanouts must sometimes be requested
explicitly in order to use a design pattern.
</para>

<para>
The following circuits take a signal $x$ and fan it out into a tuple
containing several copies of $x$.  These circuits are pure wiring
patterns; they contain no logic gates.
</para>

<programlisting>
> fanout2 :: a -> (a,a)
> fanout2 x = (x,x)

> fanout3 :: a -> (a,a,a)
> fanout3 x = (x,x,x)

> fanout4 :: a -> (a,a,a,a)
> fanout4 x = (x,x,x,x)
</programlisting>

<para>
When it is important to limit the degree of fanout, in order to avoid
problems at the electronic level, it is better to use buffered
fanouts.  These circuits are similar to the wiring patterns above, but
they use a buffer logic gate to bring the signal $x$ up to full
strength.
</para>

<programlisting>
> fanoutbuf2 :: Signal a => a -> (a,a)
> fanoutbuf2 x = (y,y)
>   where y = buf x

> fanoutbuf3 :: Signal a => a -> (a,a,a)
> fanoutbuf2 x = (y,y,y)
>   where y = buf x

> fanoutbuf4 :: Signal a => a -> (a,a,a,a)
> fanoutbuf2 x = (y,y,y,y)
>   where y = buf x
</programlisting>

<para>
The next problem is to generalise fanout, so that a bit $x$ is
duplicated in order to form a $k$-bit word, for arbitrary $k$.  This
is performed by the \textit{fanout} circuit, which is a pure wiring
pattern, and \textit{fanoutbuf}, which uses buffered fanouts.
Normally it is better to use \textit{fanoutbuf}.
</para>

<programlisting>
> fanout, fanoutbuf :: Signal a => Int -> a -> [a]
</programlisting>

<para>
For example, $\mathit{fanoutbuf}\ 6\ x$ produces a word whose value is
$[x,x,x,x]$, but it introduces buffers as needed to prevent any logic
gate from having to drive too many wires.
</para>

<para>
In RISC processors, the Boolean result $x$ of a comparison is usually
represented as an integer, where False is represented by 0 and True is
represented by 1.  In both cases, these will be $k$-bit binary
integers, so the rightmost bit should be the Boolean $x$, while all
the leading bits should be 0.  This task is performed by the
\textit{boolword} circuit, which uses a buffered fanout to produce the
leading zeros.
</para>

<programlisting>
> boolword :: Signal a => Int -> a -> [a]
> boolword n x = fanoutbuf (n-1) zero ++ [x]
</programlisting>

<para>
\section{Fanout}


\begin{itemize}
\item $\mathit{fanout2} :: a \rightarrow (a,a)$ \\
  $(x,y) = \mathit{fanout2}\ a$ \\
  Unbuffered 2-way fanout.  The wire carrying $a$ is split, putting
  the value onto both $x$ and $y$.
\item $\mathit{fanout3} :: a \rightarrow (a,a,a)$
\item $\mathit{fanout4} :: a \rightarrow (a,a,a,a)$
\item $\mathit{fanout} :: \mathit{Signal} a \Rightarrow Int
  \rightarrow a \rightarrow [a]$
\item $\mathit{fanoutbuf} :: \mathit{Signal} a \Rightarrow Int
  \rightarrow a \rightarrow [a]$ \\
  Duplicating a bit to form a word: fanoutbuf takes a wordsize n and a
  signal x, and produces a word of size n each of whose bits takes the
  value of x.
\item $\mathit{fanoutbuf2} :: \mathit{Signal} a \Rightarrow a
  \rightarrow (a,a)$
\item $\mathit{fanoutbuf3} :: \mathit{Signal} a \Rightarrow a
  \rightarrow (a,a,a)$
\item $\mathit{fanoutbuf4} :: Signal a \Rightarrow a \rightarrow
  (a,a,a,a)$
\end{itemize}

\section{Bit Slice Organization}
\label{sec:app-bit-slice}
\begin{itemize}
\item $bitslice2 :: [a] \rightarrow [a] \rightarrow [(a,a)]$
\item $zipn :: Int \rightarrow [a] \rightarrow [b] \rightarrow [(a,b)]$
\item $unzipn :: Int \rightarrow [(a,b)] \rightarrow ([a],[b])$
\item $unbitslice2 :: [(a,b)] \rightarrow ([a],[b])$
\end{itemize}
</para>

</sect2>

<sect2><title>Logic on words</title>

<para>
The following functions take a singleton (bit) signal, and replicate
it in order to form a pair, triple, or quadruple of signals.  Each of
the ouput signals is simply connected to the input.
</para>

<programlisting>
fanout2 :: a -> (a,a)
fanout3 :: a -> (a,a,a)
fanout4 :: a -> (a,a,a,a)
</programlisting>

<programlisting>
fanout :: Signal a => Int -> a -> [a]
</programlisting>


<para>
The following functions insert buffers to drive the output signals.
</para>

<programlisting>
fanoutbuf2 :: Signal a => a -> (a,a)
fanoutbuf3 :: Signal a => a -> (a,a,a)
fanoutbuf4 :: Signal a => a -> (a,a,a,a)
</programlisting>

<programlisting>
fanoutbuf :: Signal a => Int -> a -> [a]
</programlisting>

<programlisting>
winv :: Signal a => [a] -> [a]

any0, any1, all0, all1 :: Signal a => [a] -> a

bitslice2 :: [a] -> [a] -> [(a,a)]
unbitslice2 :: [(a,b)] -> ([a],[b])
zipn :: Int -> [a] -> [b] -> [(a,b)]
unzipn n xs =


boolword :: Signal a => Int -> a -> [a]
</programlisting>

</sect2>

<sect2><title>Multiplexors and demultiplexors</title>

<para>

</para>


<programlisting>
mux1 :: Signal a => a -> a -> a -> a
</programlisting>

<programlisting>
mux2 :: Signal a => (a,a) -> a -> a -> a -> a -> a
mux3 :: Signal a => (a,a,a) -> a -> a -> a -> a -> a-> a -> a -> a -> a
</programlisting>

<programlisting>
mux22 :: Signal a => (a,a) -> (a,a) -> (a,a) -> (a,a) -> (a,a) -> (a,a)
</programlisting>

<programlisting>
mux1w :: Signal a => a -> [a] -> [a] -> [a]
mux2w :: Signal a => (a) -> [a] -> [a] -> [a] -> [a] -> [a]
</programlisting>

<programlisting>
demux1 :: Signal a => a -> a -> (a,a)
demux2 :: Signal a => (a,a) -> a -> (a,a,a,a)

demux1w :: Signal a => [a] -> a -> [a]
demux2w :: Signal a => [a] -> a -> [a]
demux3w :: Signal a => [a] -> a -> [a]
demux4w :: Signal a => [a] -> a -> [a]
</programlisting>

<para>

\begin{itemize}
\item \textbf{mux1} \\
  Type: $\mathit{mux1} :: \mathit{Signal}\ a \Rightarrow a
  \rightarrow a \rightarrow a \rightarrow a$ \\
  Usage: $x = \mathit{mux1}\ \mathit{ctl}\ a\ b$ \\
  This is the basic combinational \textit{if--then--else} circuit.  If
  the control input $\mathit{ctl}$ is zero the the output is $a$;
  otherwise it is $b$.
  \begin{center}
    \begin{tabular}[c]{c|c}
      $\mathit{ctl}$  $x$ \\
      \hline
      $0$  $a$ \\
      $1$  $b$
    \end{tabular}
  \end{center}

\item \textbf{mux2} \\
  Type: $\mathit{mux2} :: \mathit{Signal}\ a \Rightarrow (a,a)
  \rightarrow a \rightarrow a \rightarrow a \rightarrow a \rightarrow a$ \\
  Usage: $ x = \mathit{mux2}\ (\mathit{ctl}_0,\mathit{ctl}_1)\ a\ b\ c\ d$ \\
  Uses the two bit control input $(\mathit{ctl_0},\mathit{ctl}_0)$ to
  select one of the four data inputs, as follows:
  \begin{center}
    \begin{tabular}[c]{c|c}
      $(\mathit{ctl}_0,\mathit{ctl}_1)$  $x$ \\
      \hline
      $(0,0)$  $a$ \\
      $(0,1)$  $b$ \\
      $(1,0)$  $c$ \\
      $(1,1)$  $d$
    \end{tabular}
  \end{center}
\item \textbf{mux22} \\
  Type: $\mathit{mux22} :: \mathit{Signal}\ a \Rightarrow (a,a)
  \rightarrow (a,a) \rightarrow (a,a) \rightarrow (a,a) \rightarrow
  (a,a) \rightarrow (a,a)$ \\
  Usage: $(x_0,x_1) = \mathit{mux22}\ (\mathit{ctl_0},\mathit{ctl}_0)
  \ (a_0,a_1)\ (b_0,b_1)\ (c_0,c_1)\ (d_0,d_1)$ \\
  Similar to $\mathit{mux2}$, except the data inputs are bit pairs
  rather than singleton bits.  The two bit control input
  $(\mathit{ctl_0},\mathit{ctl}_1)$ is used to select one of the four
  data inputs, as follows:
  \begin{center}
    \begin{tabular}[c]{c|c}
      $(\mathit{ctl}_0,\mathit{ctl}_1)$  $(x_0,x_1)$ \\
      \hline
      $(0,0)$  $(a_0,a_1)$ \\
      $(0,1)$  $(b_0,b_1)$ \\
      $(1,0)$  $(c_0,c_1)$ \\
      $(1,1)$  $(d_0,d_1)$
    \end{tabular}
  \end{center}
\item \textbf{muxw1} \\
  Type: $\mathit{muxw1} :: \mathit{Signal} a \Rightarrow [a]
  \rightarrow [a] \rightarrow a$ \\
  Usage: $x = \mathit{muxw1}\ \mathit{cs}\ \mathit{xs}$ \\
  This is a large generic multiplexor that uses a $k$-bit control
  input word $\mathit{ctl}$ to select the $i$th bit of the $2_k$-bit
  data input word $\mathit{xs}$, where $i$ is the binary value of
  $\mathit{ctl}$.
\item \textbf{mux1w} \\
  Type: $\mathit{mux1w} :: \mathit{Signal} a \Rightarrow a \rightarrow
  [a] \rightarrow [a] \rightarrow [a]$ \\
  Usage: $xs = mux1w ctl ys zs $\\
  A single control bit is used to select between two input words.  If
  $\mathit{ctl}$ is zero then the output word $\mathit{xs}$ has the
  same value as the 0th data input word $\mathit{ys}$; if
  $\mathit{ctl}$ is one then $\mathit{xs}$ is equal to $\mathit{zs}$.
  The word sizes of $\mathit{ys}$ and $\mathit{zs}$ must be the same,
  and this is also the word size of the output $\mathit{xs}$.
\item \textbf{mux2w} \\
  Type: $\mathit{mux2w} :: Signal a \Rightarrow (a,a) \rightarrow [a]
  \rightarrow [a] \rightarrow [a] \rightarrow [a] \rightarrow [a]$ \\
  Usage: $ $ \\
  Uses a two-bit control input $(\mathit{ctl}_0,\mathit{ctl}_1)$ to
  select and output the corresponding data input word.  All of the
  data input words must have the same word size, and this is the word
  size of the output.
\end{itemize}


\section{Demultiplexers}
\label{sec:demultiplexers}

\begin{itemize}
\item $\mathit{demux1} :: \mathit{Signal} a \Rightarrow a \rightarrow a
  \rightarrow (a,a)$
\item $\mathit{demux1w} :: \mathit{Signal} a \Rightarrow [a]
  \rightarrow a \rightarrow [a]$
\item $\mathit{demux2w} :: \mathit{Signal} a \Rightarrow [a]
  \rightarrow a \rightarrow [a]$
\item $\mathit{demux3w} :: \mathit{Signal} a \Rightarrow [a]
  \rightarrow a \rightarrow [a]$
\item $\mathit{demux4w} :: \mathit{Signal} a \Rightarrow [a]
  \rightarrow a \rightarrow [a]$
\end{itemize}

</para>

<programlisting>
> demux1 :: Signal a => a -> a -> (a,a)
> demux1 c x = (and2 (inv c) x, and2 c x)
</programlisting>

<programlisting>
> mux22 :: Signal a => (a,a) -> (a,a) -> (a,a)
>            -> (a,a) -> (a,a) -> (a,a)
> mux22 (a,b) (w0,w1) (x0,x1) (y0,y1) (z0,z1) =
>   (mux2 (a,b) w0 x0 y0 z0,
>    mux2 (a,b) w1 x1 y1 z1)
</programlisting>

</sect2>

<sect2><title>Combinational shifting</title>

<para>
shr Shift a word to the right (shr) or to the left (shl).  In both
cases, this is just a wiring pattern.  A 0 is brought in on one
side, and the bit on the other side is just thrown away.
</para>

<programlisting>
shl, shrr :: Signal a => [a] -> [a]
</programlisting>

<para>

\begin{itemize}
  
\item $\mathit{winv4}\ ::\ \mathit{Signal}\ a \Rightarrow [a]
  \rightarrow [a]$ \hfill\break $ys = inv4 xs$ \hfill\break A 4-bit
  word inverter.  The input \textit{xs} is a word $[x_0,x_1,x_2,x_3]$
  of signals, which must have four elements, and the output word
  \textit{ys} is the bitwise inversion of \textit{xs}.

\item $\textit{rippleAdd4}\ ::\ \textit{Signal}\ a\ \Rightarrow
     a \rightarrow [(a,a)] \rightarrow (a,[a]) $ \hfill\break
  Example: $(c',s)\ =\ \textit{rippleAdd4}\ c\ \textit{z}$ \hfill\break
  Example: $(c',[s_0, s_1, s_2, s_3)\ =\ \textit{rippleAdd4}\ c
    \ [(x_0,y_0), (x_1,y_1), (x_2,y_2), (x_3,y_3)]$ \hfill\break
  A 4-bit ripple carry adder.  The sum of the carry input $c$ and two
  four-bit words $x = [x_0, x_1, x_2, x_3]$ and $y = [y_0, y_1, y_2, y_3]$
  which are input in bit slice format.  The output consists of a carry
  output c' and a sum word $s = [s_0, s_1, s_2, s_3]$.  The circuit
  satisfies the specification
     \[\textit{bin}\ (c':s)\ =\ \textit{bin}\ x\ +\ \textit{bin}\ y\ 
     +\ \textit{bit}\ c\]

\end{itemize}
</para>

</sect2>

</sect1>

<sect1><title>Arithmetic</title>

<para>
foo
</para>




<sect2><title>Ripple Carry Adder</title>

<para>
Specification


Implementation

Simulation
</para>

<para>
Although the adder is a combinational circuit, it's easiest to test it
with a full-blown simulation driver that provides separate numbers to
add during each clock cycle.  Unless the wordsize is very small, the
adder has too many inputs for a truth table to be reasonable, and the
only way to test it is by providing a small subset of all the possible
inputs.  A simulation driver provides a systematic way to run a series
of tests over a sequence of clock cycles.
</para>

<para>
The simulation driver for and adder should let you write the input and
read the output in decimal notation.  There are three values to be
supplied for each clock cycle: the carry input $c$, and the two
numbers $x$ and $y$.  For each test case, the inputs will be written
as a list of three decimal numbersThese will be written in a list of
the form $[c, x, y]$.  The entire simulation input will be a list of
test cases which will be run in a succession of clock cycles.  An
example of the input is \textit{add\_input1}.
</para>

<programlisting>
> add_input1 :: [[Int]]

> add_input1 =
> --  c   x    y
> -- bit bin  bin
> -- ~~~~~~~~~~~~~
>   [[0,   2,   3],
>    [0,   1,   8],
>    [0,  10,   5],
>    [0,  11,   2],
>    [1,   4,   5]]
</programlisting>

<para>
An important point to notice is that a simulation driver is concerned
only with the \emph{type} of a circuit, not with its internal
structure.  This means that we could have a variety of different
circuits that implement the same specification, an that share the same
type.  It's a good idea to exploit this by generalising the simulation
driver, so that it takes a particular circuit implementation as an
argument.  If we go on to optimise the circuit, in order to make it
faster, the same driver (and the same input) can be used to test each
version.  The adder simulation driver will work for any circuit that
has the appropriate type.  Since simulation drivers operate through a
sequence of clock cycles, they require the synchronous model to be
used. This means that the signal type $a$ must be in the
\textit{Clocked} class.
</para>

<programlisting>
Clocked a => a -> [(a,a)] -> (a,[a])
</programlisting>

<para>
Since the ripple carry adder is a combinational circuit, it works with
all semantic models, so it has the more general type:
</para>

<programlisting>
Signal a => a -> [(a,a)] -> (a,[a])
</programlisting>

<para>
Since any clocked signal is a signal, there is no problem with doing a
synchronous simulation of a combinational circuit.
</para>

<para>
The simulation driver is called \textit{sim\_adder}, and it takes
three arguments: the adder circuit to be tested, its wordsize, and the
input data.  For example, in order to test the 4-bit ripple carry
adder with the input data above, you can enter the following
expression at the interactive prompt:
</para>

<programlisting>
sim_adder rippleAdd4 4 add_input1
</programlisting>

<para>
The simulation produces the following output:
</para>

<programlisting>
WordCombTest> sim_adder rippleAdd4 4 add_input1

..................................................
   Simulating ripple carry adder
      0.   ci=0 x=   2 y=   3   Output: 0   5
      1.   ci=0 x=   1 y=   8   Output: 0   9
      2.   ci=0 x=  10 y=   5   Output: 0  15
      3.   ci=0 x=  11 y=   2   Output: 0  13
      4.   ci=1 x=   4 y=   5   Output: 0  10
..................................................
</programlisting>

<para>
We can try similar experiments by using the general $n$-bit circuit
\textit{rippleAdd}, by varying the wordsize, and by using alternative
test data.  The following experiments can be entered interactively, or
they can be gathered together into a batch simulation file.
</para>

<programlisting>
sim_adder rippleAdd4  4 add_input1
sim_adder rippleAdd   4 add_input1
sim_adder rippleAdd  16 add_input1
</programlisting>

<para>
\emph{Note:  see module WordCombTest}
</para>

<para>
The adder has one circuit parameter, its wordsize, since our ripple
carry adders may be defined using design patterns that work for
arbitrary size!  Here we use 8-bit words.
</para>

<programlisting>
n = 8
</programlisting>

<para>
The heart of the simulation driver is an equation that uses the
circuit.  Here, we define the carry output co and the sum word s to be
the outputs of an adder with input words x and y; these are
represented in bit slice form as a single word z :: [(a,a)].
</para>

<programlisting>
(co,s) = rippleAdd ci z
</programlisting>

<para>
The bit slice word z is formed by the bitslice2 wiring pattern:
</para>

<programlisting>
z = bitslice2 x y
</programlisting>

<para>
We could also omit this equation, and write the circuit application as
</para>

<programlisting>
(co,s) = rippleAdd ci (bitslice2 x y)
</programlisting>

<para>
The inputs to the circuit can be provided interactively, but sometimes
it's more convenient to define a set of inputs as a constant
definition in the simulation module.  This allows us to run a
simulation repeatedly, without having to keep typing the same inputs
over and over again.  That approach will be taken here; later we will
introduce tools that support interactive simulations.
</para>

<para>
Now we need to use the tools for converting the test input to the
correct signal representations:
</para>

<programlisting>
ci = getbit   input 0 :: Stream Bool 
   x  = getbin n input 1
   y  = getbin n input 2
</programlisting>

<para>
The first equation says that ci is obtained from the 0'th column of
the test input, using a bit conversion (getbit).  The second equation
says that x comes from column 1 in the test input, and it's converted
using a binary conversion (getbin n), where n is the wordsize.  The
last equation converts y from column 2 of the input data.
</para>

<para>
The final step is to format the output.  First, we specify the
underlying signal representation that is being used:
</para>


<programlisting>
simoutput :: [Format Bool]
</programlisting>

<para>
This is necessary, because Hydra supports a large number of signal
representations, and it needs to know which one to use here.
</para>

<para>
Now we define the simulation output by formatting the various signals
that should be printed.  The format consists of a list of fields
separated by commas.  For every clock cycle, Hydra will print a line
comprising all these fields.  The field format specifications are

  string "abc"  prints the literal string on each line
  bit x         prints the value of the bit signal x, as 0 or 1
  bindec k x    converts the binary word x to a 4-digit decimal integer
  tcdec k x     converts the two's complement word x to a 4-digit
                decimal integer
</para>

<para>
The following format prints the adder's inputs and outputs, along with
some labels:
</para>

<programlisting>
simoutput =
      [bit ci,
       string " x= ", bindec 4 x, tcdec 4 x,
       string " y= ", bindec 4 y, tcdec 4 y,
       string " Output: ", bit co,
       string " sum= ", bindec 4 s, tcdec 4 s]
</programlisting>

<para>
Putting all the pieces together, here is the simulation driver for the
ripple carry adder:
</para>

<para>

Here is the complete definition of the simulation driver.
</para>

<programlisting>
sim_adder add_circuit n input =
  let (co,s) = add_circuit ci (bitslice2 x y)
      ci = getbit   input 0
      x  = getbin n input 1
      y  = getbin n input 2
      simoutput :: [Format Bool]
      simoutput =
        [string " ci=", bit ci,
         string " x= ", bindec 3 x,
         string " y= ", bindec 3 y,
         string "   Output: ", bit co, bindec 4 s]
  in do putStrLn "\nSimulating ripple carry adder"
        run input simoutput
</programlisting>

</sect2>

<sect2><title>Subtraction</title>


<para>
Two's complement addition and subtraction
</para>

<programlisting>
> addSub :: Signal a => a -> [(a,a)] -> (a,[a])
> addSub sub xy = rippleAdd sub (map f xy)
>   where f (x,y) = (x, xor2 sub y)
</programlisting>

</sect2>

<sect2><title>Binary ripple comparison</title>


<para>
Simulation Driver for Comparitor

The ripple comparitor for binary numbers can be simulated by entering
the following:
</para>

<programlisting>
sim_comparitor rippleCmp 16 cmp_input1
</programlisting>

<para>
Here is some test data for the comparitor...
</para>

<programlisting>
> cmp_input1 :: [[Int]]
> cmp_input1 =
>   [[2, 3],
>    [3, 2],
>    [3, 3],
>    [1, 8],
>    [8, 1],
>    [9, 9],
>    [0, 5],
>    [7, 5]]
</programlisting>

<para>
The simulation driver is similar to the adder driver.
</para>

<programlisting>
> sim_comparitor circuit n input =
>   let (lt,eq,gt) = circuit (bitslice2 x y)
>       x = getbin n input 0
>       y = getbin n input 1
>       simoutput :: [Format Bool]
>       simoutput =
>         [string " x= ", bindec 4 x,
>          string "   y= ", bindec 4 y,
>          string "  (lt,eq,gt) = ",
>          bit lt, bit eq, bit gt]
>   in do putStrLn "\nSimulating comparitor"
>         run input simoutput
</programlisting>


<programlisting>
halfAdd :: Signal a => a -> a -> (a,a)
bsum, bcarry :: Signal a => (a,a) -> a -> a
fullAdd :: Signal a => (a,a) -> a -> (a,a)
rippleAdd :: Signal a => a -> [(a,a)] -> (a,[a])
addSub :: Signal a => a -> [(a,a)] -> (a,[a])

cmp1 :: Signal a => (a,a,a) -> (a,a) -> (a,a,a)
rippleCmp :: Signal a => [(a,a)] -> (a,a,a)
</programlisting>

<para>
The following is defined in Hydra.Circuits.Arithmetic.TreeAdd
</para>

<programlisting>
> add5 :: Signal a => a -> [(a,a)] -> (a,[a])
</programlisting>


<para>
The following is defined in Hydra.Circuits.Arithmetic.Multiply
</para>

<programlisting>
multiply :: Clocked a => Int
  -> a -> [a] -> [a] -> (a,[a],[a],[a],[a])
</programlisting>

<para>
\begin{itemize}
\item $halfAdd :: Signal a \Rightarrow a \rightarrow a \rightarrow (a,a)$
\item $fullAdd :: Signal a \Rightarrow (a,a) \rightarrow a \rightarrow (a,a)$
\item $bsum, bcarry :: Signal a \Rightarrow (a,a) \rightarrow a \rightarrow a$
\item $rippleAdd4 :: Signal a \Rightarrow a \rightarrow [(a,a)] \rightarrow (a,[a])$
\item $rippleAdd :: Signal a \Rightarrow a \rightarrow [(a,a)] \rightarrow (a,[a])$
\item $addSub :: Signal a \Rightarrow a \rightarrow [(a,a)] \rightarrow (a,[a])$
\item $cmp1 :: Signal a \Rightarrow (a,a,a) \rightarrow (a,a) \rightarrow (a,a,a)$
\item $rippleCmp :: Signal a \Rightarrow [(a,a)] \rightarrow (a,a,a)$
\end{itemize}
</para>
</sect2>
</sect1>

<sect1><title>Registers</title>

<sect2><title>Basic registers</title>

<programlisting>
reg1 :: Clocked a => a -> a -> a
reg :: Clocked a => Int -> a -> [a] -> [a]
wlatch :: Clocked a => Int -> [a] -> [a]
</programlisting>

<programlisting>
sr :: (Signal a, Clocked a)
  => (a,a) -> a -> a -> [a] -> (a,a,[a])
</programlisting>

<programlisting>
regfile1 :: Clocked a => Int -> a -> [a] -> [a] -> [a] -> a -> (a,a)
</programlisting>

<programlisting>
regfile :: Clocked a => Int -> Int
  -> a -> [a] -> [a] -> [a] -> [a] -> ([a],[a])
</programlisting>

<para>
\section{Registers}
\label{sec:registers}

\begin{itemize}
\item $reg1 :: Clocked a \Rightarrow a \rightarrow a \rightarrow a $
\item $reg :: Clocked a \Rightarrow Int \rightarrow a \rightarrow [a] \rightarrow [a]$
\item $srb :: Clocked a \Rightarrow (a,a) \rightarrow a \rightarrow a \rightarrow a \rightarrow a$ \\
  Meaning of op: 0 -- no state change 1 -- load input word x 2 --
  shift right 3 -- shift left
\item $sr :: (Signal a, Clocked a)$
\item $ sr4_v1 :: Clocked a \Rightarrow (a,a) \rightarrow a \rightarrow a \rightarrow [a] \rightarrow [a]$
\item $regfile1 :: Clocked a \Rightarrow Int \rightarrow a \rightarrow
  [a] \rightarrow [a] \rightarrow [a] \rightarrow a \rightarrow (a,a)$
\item $reg4 :: Clocked a \Rightarrow a \rightarrow [a] \rightarrow [a]$
\item $regfile :: Clocked a \Rightarrow Int \rightarrow Int
  \rightarrow a \rightarrow [a] \rightarrow [a] \rightarrow [a]
  \rightarrow [a] \rightarrow ([a],[a])$
\end{itemize}
</para>

</sect2>

<sect2><title>Shift Registers</title>

<programlisting>
> sr4_v1 :: Clocked a => (a,a) -> a -> a -> [a] -> [a]
> sr4_v1 op l r [x0,x1,x2,x3] = [a,b,c,d]
>   where
>      a = srb op l b x0
>      b = srb op a c x1
>      c = srb op b d x2
>      d = srb op c r x3
</programlisting>

<programlisting>
> sr4_v2 :: Clocked a => (a,a) -> a -> a -> [a] -> [a]
> sr4_v2 op l r [x0,x1,x2,x3] = [a,b,c,d]
>   where
>      (opa,opb,opc,opd) = fanout4 op
>      a = srb opa l b x0
>      b = srb opb a c x1
>      c = srb opc b d x2
>      d = srb opd c r x3
</programlisting>

<programlisting>
> sr4_v3 :: Clocked a => (a,a) -> a -> a -> [a] -> [a]
> sr4_v3 op l r [x0,x1,x2,x3] = [a,b,c,d]
>   where
>      f = srb op
>      a = f l b x0
>      b = f a c x1
>      c = f b d x2
>      d = f c r x3
</programlisting>

<para>
\begin{itemize}
\item Design a general shift register as follows:
  \begin{itemize}
  \item There are $n$ bit positions, each with one bit of state.
  \item There is an $n$-bit word input $a = [a_0, \ldots, a_{n-1}]$.
  \item There are two data inputs $l$ and $r$; $l$ is the left input
    (it comes into the leftmost position $0$), and $r$ is the right
    input (it comes into the rightmost position $n-1$).
  \item There is a two-bit control input $[c_0,c_1]$.  For
    convenience, we will refer to the four possible values of the
    control input as 0, 1, 2, and 3.
  \item The circuit has three outputs: an $n$-bit word which is the
    contents of the $n$ states; the left output (which is the value of
    bit 0) and the right output (which is the value of bit $n-1$).
    Notice that Bit 0 actually appears twice in the output, once as
    $l'$ and again as the 0'th bit of the output word; similarly Bit
    $n-1$ appears twice, once as $r'$ and also as bit $n-1$ of the
    output.
  \item At each clock tick, the behaviour is as follows:
\begin{center}
  \begin{tabular}{|l|l|l|} \hline
    $c$    \emph{action}  \emph{behaviour} \\ \hline
    0    clear   $x_i := 0$ for $0 \leq i LT n$ \\
    1    load    $x_i := a_i$ for $0 \leq i LT n$ \\
    2    shift left $x_i := x_{i+1}$ for $0 \leq i \leq n-2$,
            $x_{n-1} := r$  \\
    3    shift right $x_i := x_{i-1}$ for $1 \leq i \leq n-1$,
            $x_0 := l$\\
    \hline
  \end{tabular}
\end{center}
\item \textbf{Hint:} \emph{Figure out what's going on in each bit
    position, and design a circuit---you could call it
    \texttt{srb}---that implements an arbitrary position in the
    circuit.  Then design the entire circuit as a row of shift
    register bits, connnected together in an appropriate way.  If you
    like, you may simply design a version of the circuit at a specific
    wordsize, say 4 bits, but the most elegant approach is to use a
    combinator.}
\end{itemize}
\end{itemize}
</para>

<programlisting>
> srb :: Clocked a => (a,a) -> a -> a -> a -> a
> srb op l r x = y
>   where y = dff (mux2 op y x l r)
</programlisting>

<programlisting>
> sr4 :: Clocked a => (a,a) -> a -> a -> [a] -> [a]
> sr4 op l r [x0,x1,x2,x3] = [a,b,c,d]
>   where
>      a = srb op l b x0
>      b = srb op a c x1
>      c = srb op b d x2
>      d = srb op c r x3
</programlisting>

<para>
We can define the shift register circuit more generally with the
mscanr combinator; note that in this simulation, we use the general
circuit "sr" rather than the restricted 4-bit sr4.  The test data
is identical to that used above, and you can check that the circuit
defined in this more general way has the same behaviour on this
test data.
</para>

<programlisting>
sim_gen_sr_4 =
  let input =
--      op  l  r  x        op    produce  state
--      ~~~~~~~~~~~       ~~~~~~~~~~~~~~~~~~~~~
       [[1, 0, 0, 9],  -- load     1001    0000
        [0, 0, 0, 3],  -- nop      1001    1001
        [2, 1, 0, 4],  -- right 1  1100    1001
        [2, 0, 0, 2],  -- right 0  0110    1100
        [3, 0, 1, 7],  -- left  1  1101    0110
        [1, 0, 0, 5],  -- load     0101    1101
        [0, 0, 0, 0]]  -- nop      0101    0101
      op = getbit2  input 0
      l =  getbit   input 1
      r =  getbit   input 2
      x =  getbin 4 input 3
      (op0,op1) = op
      (p,q,y) = sr op l r x
      simoutput :: [Format Bool]
      simoutput = [string "Input: ",
              bit op0, bit op1, string " ",
              bit l, string " ", bit r, string " ", bits x,
              string "    Output: ",
              bit p, bit q, string " ", bits y]
  in do putStrLn "\nSimulate n-bit shift register, size 4"
        run input simoutput
</programlisting>

<para>
Here is a similar example, but where the word size is increased to
8.  Notice that all we had to do to change the wordsize was to
change the number of bits in x; the general mscanr combinator
automatically accommodates itself to the new word size!
</para>

<programlisting>
sim_gen_sr_8 =
  let input =
--      op  l  r  x        op        state
--      ~~~~~~~~~~~       ~~~~~~~~~~~~~~~~~~~~~
       [[1, 0, 0, 75],  -- load     0000 0000
        [0, 0, 0,  3],  -- nop      0100 1011
        [2, 1, 0,  4],  -- right 1  0100 1011
        [2, 0, 0,  2],  -- right 0  1010 0101
        [3, 0, 1,  7],  -- left  1  0101 0010
        [1, 0, 0,  5],  -- load     1010 0101
        [0, 0, 0,  0]]  -- nop      0000 0101
      op = getbit2  input 0
      l =  getbit   input 1
      r =  getbit   input 2
      x =  getbin 8 input 3  -- 8 bit words!
      (op0,op1) = op
      (p,q,y) = sr op l r x
      simoutput :: [Format Bool]
      simoutput = [string "Input: ",
              bit op0, bit op1, string " ",
              bit l, string " ", bit r, string " ", bits x,
              string "    Output: ",
              bit p, bit q, string " ", bits y]
  in run input simoutput
</programlisting>

<para>
We can define the shift register circuit more generally with the
mscanr combinator; note that in this simulation, we use the general
circuit "sr" rather than the restricted 4-bit sr4.  The test data
is identical to that used above, and you can check that the circuit
defined in this more general way has the same behaviour on this
test data.
</para>

<programlisting>
sim_gen_sr_4 =
  let input =
--      op  l  r  x        op    produce  state
--      ~~~~~~~~~~~       ~~~~~~~~~~~~~~~~~~~~~
       [[1, 0, 0, 9],  -- load     1001    0000
        [0, 0, 0, 3],  -- nop      1001    1001
        [2, 1, 0, 4],  -- right 1  1100    1001
        [2, 0, 0, 2],  -- right 0  0110    1100
        [3, 0, 1, 7],  -- left  1  1101    0110
        [1, 0, 0, 5],  -- load     0101    1101
        [0, 0, 0, 0]]  -- nop      0101    0101
      op = getbit2  input 0
      l =  getbit   input 1
      r =  getbit   input 2
      x =  getbin 4 input 3
      (op0,op1) = op
      (p,q,y) = sr op l r x
      simoutput :: [Format Bool]
      simoutput = [string "Input: ",
              bit op0, bit op1, string " ",
              bit l, string " ", bit r, string " ", bits x,
              string "    Output: ",
              bit p, bit q, string " ", bits y]
  in do putStrLn "\nSimulate n-bit shift register, size 4"
        run input simoutput
</programlisting>

<para>
Here is a similar example, but where the word size is increased to
8.  Notice that all we had to do to change the wordsize was to
change the number of bits in x; the general mscanr combinator
automatically accommodates itself to the new word size!
</para>

<programlisting>
sim_gen_sr_8 =
  let input =
--      op  l  r  x        op        state
--      ~~~~~~~~~~~       ~~~~~~~~~~~~~~~~~~~~~
       [[1, 0, 0, 75],  -- load     0000 0000
        [0, 0, 0,  3],  -- nop      0100 1011
        [2, 1, 0,  4],  -- right 1  0100 1011
        [2, 0, 0,  2],  -- right 0  1010 0101
        [3, 0, 1,  7],  -- left  1  0101 0010
        [1, 0, 0,  5],  -- load     1010 0101
        [0, 0, 0,  0]]  -- nop      0000 0101
      op = getbit2  input 0
      l =  getbit   input 1
      r =  getbit   input 2
      x =  getbin 8 input 3  -- 8 bit words!
      (op0,op1) = op
      (p,q,y) = sr op l r x
      simoutput :: [Format Bool]
      simoutput = [string "Input: ",
              bit op0, bit op1, string " ",
              bit l, string " ", bit r, string " ", bits x,
              string "    Output: ",
              bit p, bit q, string " ", bits y]
  in run input simoutput
</programlisting>
</sect2>

<sect2><title>Bidirectional Shift Registers</title>

<para>
The bidirectional shift register takes an operation code that
determines the behavior:
</para>

<para>
\begin{tabular}{ll}
  0  no state change \\
  1  load input word x \\
  2  shift right \\
  3  shift left \\
\end{tabular}
</para>

<para>
The following test data contains comments showing the expected output.
This is a useful technique for documenting a circuit, and it provides
a good permanent test case.
</para>

<programlisting>
sr4_input :: [[Int]]
sr4_input =
--      op  l  r  x        op    produce  state
--      ~~~~~~~~~~~       ~~~~~~~~~~~~~~~~~~~~~
       [[1, 0, 0, 9],  -- load     1001    0000
        [0, 0, 0, 3],  -- nop      1001    1001
        [2, 1, 0, 4],  -- right 1  1100    1001
        [2, 0, 0, 2],  -- right 0  0110    1100
        [3, 0, 1, 7],  -- left  1  1101    0110
        [1, 0, 0, 5],  -- load     0101    1101
        [0, 0, 0, 0]]  -- nop      0101    0101
</programlisting>

<para>
Here is a simulation driver intended specifically for the 4-bit
version of the circuit.
</para>

<programlisting>
sim_sr4 input =
  let op = getbit2  input 0
      l =  getbit   input 1
      r =  getbit   input 2
      x =  getbin 4 input 3
      (op0,op1) = op
      y = sr4 op l r x
      simoutput :: [Format Bool]
      simoutput = [string "Input: ",
              bit op0, bit op1, string " ",
              bit l, string " ", bit r, string " ", bits x,
              string "    Output: ", bits y]
  in do putStrLn "\nSimulate 4-bit shift register"
        run input simoutput
</programlisting>

</sect2>

<sect2><title>Memory</title>

<programlisting>
mem1 :: (Signal a, Clocked a) => Int
  -> a -> [a] -> [a] -> a -> a

memw :: Clocked a => Int -> Int -> a -> [a] -> [a] -> [a]

mem1a :: Clocked a => Int -> a -> [a] -> a -> a
</programlisting>


<para>
\item $mem1 :: (Signal a, Clocked a) \Rightarrow Int \rightarrow a
  \rightarrow [a] \rightarrow [a] \rightarrow a \rightarrow a$

\item $mem1a :: Clocked a \Rightarrow Int \rightarrow a \rightarrow [a] \rightarrow a \rightarrow a$

\item $memw :: Clocked a \Rightarrow Int \rightarrow Int \rightarrow a
  \rightarrow [a] \rightarrow [a] \rightarrow [a]$
</para>

<programlisting>
> mem1
>   :: (Signal a, Clocked a)
>   => Int
>   -> a -> [a] -> [a] -> a -> a

> mem1 0 ld d sa x =
>   reg1 ld x

> mem1 (k+1) ld (d:ds) (sa:sas) x = a
>   where
>     (ld0,ld1) = demux1 d ld
>     a0 = mem1 k ld0 ds sas x
>     a1 = mem1 k ld1 ds sas x
>     a = mux1 sa a0 a1
</programlisting>

</sect2>

</sect1>

</chapter>


</book>



---------------------------------------------------------------------------
## Typesetting Demo (two hash section header)

Here is a figure.

![map4 circuit box with xs inputs and ys
outputs](../src/figures/xfig/map4box.png)

### Three hashes

This is a paragraph of dummy text.
This is a paragraph of dummy text.
This is a paragraph of dummy text.
This is a paragraph of dummy text.
This is a paragraph of dummy text.


#### Four hashes

This is a paragraph of dummy text.
This is a paragraph of dummy text.
This is a paragraph of dummy text.
This is a paragraph of dummy text.
This is a paragraph of dummy text.

##### Five hashes

This is a paragraph of dummy text.
This is a paragraph of dummy text.
This is a paragraph of dummy text.
This is a paragraph of dummy text.
This is a paragraph of dummy text.


# old tutorial.xml


<sect1><title>Circuit Definition Equations</title>

<para>
A circuit is a collection of components connected together with wires.
An input to a component may be either a constant signal (zero or one),
or an output produced by some other component and transmitted by a
wire.
</para>

<para>
So far, we have been specifying circuits by mentioning every component
explicitly.  If a circuit design is useful, however, we would like to
be able to design it once and for all, and then reuse it as often as
needed.
</para>

<para>
Reusability is achieved by <emphasis>black box abstraction</emphasis>.
The idea is that a circuit is specified, its interface (how to use it)
is defined, and the specification is given a name.  The circuit can
then be reused many times, and each reuse will introduce a fresh set
of components into the circuit.
</para>

<para>
Black box abstraction in hardware design is similar to procedural or
functional abstraction in programming languages: instead of writing a
common set of statements many times, you define a procedure containing
the statements, and can then call the procedure as often as necessary.
</para>


<para>
The simplest form of a circuit definition equation is <emphasis>lhs =
rhs</emphasis>, where the right hand side is a signal value, and the
left hand side is an application of the circuit's names to the
internal names of its inputs.  Here is an example:
</para>

<programlisting>
circ1 p q r = nor3 p (inv q) r
</programlisting>

<para>
  <inlinemediaobject>
    <imageobject>
      <imagedata fileref="figures/xfig/bboxnorpinvqr.png" format="PNG" />
    </imageobject>
    <imageobject>
	<imagedata fileref="figures/xfig/bboxnorpinvqr.eps" format="EPS" />
    </imageobject>
  </inlinemediaobject>
</para>

<para>
This equation defines the circuit named <emphasis>circ1</emphasis>.
It gives local names p, q, r to the input signals (which could have
different names elsewhere in the circuit).  The output of the circuit
is the value on the right hand side of the equation, i.e. the output
of the nor3 gate.  The expression giving the circuit's output can use
p, q, r to refer to the values of the input signals.
</para>

<para>
Now that circ1 has been defined, it can be simulated just like any
other component:
</para>

<programlisting>
truthTable31 circ1
</programlisting>

<para>
Defining new circuits allows us to build up a set of useful building
blocks. A typical example is the multiplexor, called mux1, which takes
a control bit c and two data bits x, y.  The multiplexor uses c to
determine which of the data bits to output.  Its behavior can be
described informally as
</para>

<programlisting>
output = if c=zero then x else y
</programlisting>

<para>
It is straightforward to verify that this circuit implements a
multiplexor correctly:
</para>

<programlisting>
mux1 c x y = or2 (and2 (inv c) x) (and2 c y)
</programlisting>

<para>
The defining equation has given the name mux1 to the circuit, and we
can use it just like any other component:
</para>

<programlisting>
mux1 (and2 a b) x (inv y)
</programlisting>

<para>
Hydra provides a library of common circuits, including mux1, and a
later chapter in the tutorial shows how to use them.
</para>

<para>
Some of the circuits we have defined contain internal signals, but
these have all been anonymous.  Sometimes it is helpful to give names
to some of the internal signals, using signal defining equations.
This is done using a more general form of the circuit defining
equation:
</para>

<programlisting>
circuit_name inputs = output
  where signal_equation
        signal_equation
        ...
        signal_equation
</programlisting>

<para>
For example, suppose that we wanted to give names to a couple of the
internal signals in the definition of the multiplexor.  This could be
done using a "where" clause:
</para>

<programlisting>
mux1 c x y = or2 p q
  where p = and2 (inv c) x
        q = and2 c y
</programlisting>

<para>
This second version of the multiplexor describes exactly the same
circuit; there is no difference in the hardware, and there is no
difference in how the circuit is used.  The only difference is in the
notation.  The first version is shorter, while the second provides
names p and q that could be used in documentation to help explain how
the circuit works.  Names are not part of the hardware; they are just
part of the notation.
</para>

<para>
Internal signal names can be used to specify that one signal is to be
shared (this is called fanout).  Compare the following two
specifications:
</para>

<programlisting>
circ5 a b c = xor2 q r
  where a' = inv a
        q = and2 a' b
        r = and2 a' c

circ6 a b c = xor2 q r
  where q = and2 (inv a) b
        r = and2 (inv a) c
</programlisting>

<para>
In circ5 there is just one inverter, and its output goes to both and2
gates.  In circ6 there are two inverters, and the input a goes to both
of those.  Thus circ6 requires the input signal a to drive two gates,
while in circ 5 the inverter has to drive two gates.
</para>

</sect1>

<sect1><title>Groups of Signals</title>

<para>
Circuits often contain groups of signals that belong together.  It is
often possible to make a circuit design clearer, more concise, and
more readable by giving a name to a group of signals and to treat it
as a single entity, rather than naming all the individual signals.  In
the physical circuit the signals comprising a group actually
correspond to completely independent wires, but the designer may
prefer to think of them more abstractly as a single value, such as a
binary number.
</para>

<para>
Hydra provides two mechanisms for grouping signals together: tuples
and words.  Tuples are used to group signals together when the
individual components have different purposes, while words are used to
represent binary numbers, addresses, and so on.
</para>

<para>
There are a number of operations that can be applied to tuples and
words, such as extracting individual signals from a group.  It is
important to remember that operations on signal groups are purely
notational techniques, but they do not correspond to actualy
components in a circuit.
</para>

<sect2><title>Tuples</title>

<para>
Tuples are used to group together signals that are related to each
other, but which do not represent the bits in a number.  The syntax
for tuples requires the signals to be separated by commas, and the
entire tuple is surrounded by parentheses (round brackets).  For
example, if x and y are signals, then (x,y) is a tuple containing them
both.
</para>

<para>
Tuples are useful when a circuit has several outputs.  A circuit
defining equation specifies just one output, but that output can be a
tuple comprising several bits.  For example, the half adder circuit,
halfAdd, computes the sum of two bits x and y.  The sum could be 0, 1,
or 2, so it takes two bits to represent the result.  A standard
solution is to use two bits called carry and sum, or just c and s, so
that the numeric value of the result is 2 * c + s.  Since the half
adder's output is two bits, but the defining equation has just one
right hand side, we need to gather the output bits into a tuple
(carry, sum):
</para>

<programlisting>
halfAdd x y = (and2 x y, xor2 x y)
</programlisting>

<para>
An alternative way to define this is to give internal names to the two
result bits:
</para>

<programlisting>
halfAdd x y = (c,s)
  where c = and2 x y
        s = xor2 x y
</programlisting>

<para>
Both definitions yield the same circuit; the difference is just a
matter of style.
</para>

<para>
A tuple may have any number of components.  Thus (a,b) is a 2-tuple,
or pair, (a,b,c) is a 3-tuple or triple, and so on.  A tuple cannot
have just one element; if you write (a) this means just the signal
$a$.  (This is because anything written in parentheses
<emphasis>without</emphasis> commas inside is just an expression.)
However, the empty 0-tuple (), which is a group containing no signals,
is allowed, and later we will see some situations where it is useful.
</para>

<para>
The half adder definition used a tuple to gather several results into
one value.  We can give a name to the tuple produced by a half adder
with a signal definition equation:
</para>

<programlisting>
result = halfadd x y
</programlisting>

<para>
This equation says that result is a pair of signals, and they can be
connected to a circuit that requires a pair of signals using an
ordinary application:
</para>

<programlisting>
circ result
</programlisting>

<para>
Alternatively, we can use a tuple pattern in a signal defining
equation in order to give names to the components of the tuple, rather
than to the whole tuple:
</para>

<programlisting>
(p,q) = halfadd x y
</programlisting>

<para>
Using this equation, p is the name of the carry output, and q is the
name of the sum output.
</para>

</sect2>

<sect2><title>Words</title>

<para>
A word is a group of bits that can be accessed by index.  Words are
used to represent binary numbers, twos complement numbers, addresses,
fields of floating point numbers, and so on.
</para>

<para>
In Hydra, a word is written by separating the individual bits with
commas, and enclosing the whole word in square brackets [ ].  For
example, suppose that a, b, c and d are ordinary bit signals.  Then a
4-bit word could be written as
</para>

<programlisting>
[a, b, c, d]
</programlisting>

<para>
Typically, there is no need for distinctive names for the bits in a
word, so we will often use names that contain the index:
</para>

<programlisting>
[x0, x1, x2, x3]
</programlisting>

<para>
Usually we will use a single name for an entire word.  You can give a
name to a word using a signal defining equation:
</para>

<programlisting>
w = [x0, x1, x2, x3]
</programlisting>

<para>
Now w can be provided as an input to a circuit, without having to
mention every bit individually.  This is a big time saver, especially
for words with 32 or 64 bits.

wiring patterns

Indexing !!

w !! 2 => x2


lsb gives the least significant (rightmost) bit of a word, and msb
gives the most significant (leftmost) bit.



Concatenation ++

head, tail

Attaching an element :

Pattern matching [a,b,c]

Pattern matching :
</para>


<para>
Shift a word to the right (shr) or to the left (shl).  In both
cases, this is just a wiring pattern.  A 0 is brought in on one
side, and the bit on the other side is just thrown away.
</para>

<programlisting>
> shr x = zero : [x!!i | i FROM- [0..k-2]]
>   where k = length x
> shl x = [x!!i | i FRM [1..k-1]] ++ [zero]
>   where k = length x
</programlisting>


<programlisting>

</programlisting>

<para>


\item \textbf{msb} Most significant bit\\
  Type: $\mathit{msb} :: [a] \rightarrow a$ \\
  Usage: $y = \mathit{msb}\ \mathit{xs}$ \\
  This is a wiring pattern that gives the most significant (leftmost)
  position of a word.  If $\mathit{xs} = [x_0, \ldots, x_{k-1}]$ then
  $\mathit{msb}\ \mathit{xs} = x_0$ It is an error to take the least
  significant position of an empty word: $\mathit{msb}\ []$ will
  produce an error.

\item \textbf{(:)} \\
  Type: $(:) :: a \rightarrow [a] \rightarrow [a]$ \\
  Usage: $\mathit{ys} = x : \mathit{xs}$ \\
  This wiring pattern produces the word obtained by attaching the
  singleton element $x$ onto the front of the word $\mathit{xs}$.  The
  element type of $x$ must be the same as the types of the elements of
  $\mathit{xs}$.  For example, \[(a,b) : [(x_0,y_0), (x_1,y_1),
  (x_2,y_2)] = [(a,b), (x_0,y_0), (x_1,y_1), (x_2,y_2)].\]

\item \textbf{(!!)} \\
  Type: $(!!) :: [a] \rightarrow a$ \\
  Usage: $x = \mathit{xs}!!i$ \\
  This wiring pattern gives the $i$th signal in a word, where the
  leftmost bit has index 0.  If $\mathit{xs} = [x_0, x_1, \ldots,
  x_{k-1}]$, then $\mathit{xs}!!i = x_i$ provided that $0 \leq i LT k$.

\item \textbf{(\plusplus)} \\
  Type: $(\plusplus) :: [a] \rightarrow [a] \rightarrow [a]$ \\
  Usage: $\mathit{xs} \plusplus \mathit{ys}$ \\
  This operator is written as two consecutive + symbols, and it
  denotes a wiring pattern that concatenates two words to form one
  larger word. \[[x_0, \ldots, x_{j-1}] \plusplus [y_0, \ldots,
  y_{k-1}] = [x_0, \ldots, x_{j-1}, y_0, \ldots, y_{k-1}].\]

\item \textbf{field} \\
  Type: $\mathit{field} :: [a] \rightarrow Int \rightarrow Int
  \rightarrow [a]$ \\
  Usage: $\mathit{ys} = \mathit{field}\ \mathit{xs}\ j\ k$ \\
  The wiring pattern extracts a subfield from $\mathit{xs}$, starting
  at bit position $j$ (where the leftmost bit has index 0) and with
  length $k$.  Provided that $\mathit{xs}$ is long enough, the value
  of $\mathit{ys}$ is $[x_j, x_{j+1}, \ldots, x_{j+k-1}]$.  For
  example, if $\mathit{xs} = [x_0, x_1, \ldots, x_{15}]$, then
  $\mathit{field}\ \mathit{xs}\ 8\ 4 = [x_8, x_9, x_{10}, x_{11}]$.
\item $winv :: Signal a \Rightarrow [a] \rightarrow [a]$
\end{itemize}


\item $boolword :: Signal a \Rightarrow Int \rightarrow a \rightarrow [a]$ \\
  Representing a boolean bit as a word: boolword takes a bit x, and
  pads it to the left with 0s to form a word.  If the input x is False
  (0), the result is the integer 0 (i.e. n 0-bits), and if x is True
  (1) the result is the integer 1 (rightmost bit is 1, all others are
  0).


Determine whether there exists a 1 in a word, or whether all the bits
are 0.  A tree fold can do this in log time, but for simplicity this
is just a linear time fold.

\item $any1, all0 :: Signal a \Rightarrow [a] \rightarrow a$

</para>
</sect2>
</sect1>

<sect1><title>Types</title>

<para>
It is important to provide the correct number of inputs to any
component.  You cannot provide three inputs to a logic gate with only
two input ports, and you should always ensure that all inputs to a
logic gate are connected to a signal.
</para>

<para>
Sometimes it's quicker to copy and paste a simulation expression than
to type it in manually.  For example, use the mouse to select the
expression <emphasis>nand2 (or2 True False) (xor2 False True)</emphasis>
and then use your web browser to copy the text.  Paste the text into
the shell window where Hydra is running, and press return.  The result
should look like this:
</para>

<programlisting>*BoolModel> nand2 (or2 True False) (xor2 False True)
False
</programlisting>

<para>
The copy and paste technique can save retyping complex expressions,
and is often useful for running some quick examples or test cases that
are embedded in a documentation file.
</para>



<para>
A specification consists of two parts: (1) the type specification,
which is optional, and (2) the behaviour specification, which is
required.  For example, the first line of the following specification
gives the type of circ and the second defines its internal structure:
</para>

<programlisting>
circ :: Signal a => a -> a
circ x = inv x
</programlisting>

</sect1>



<sect1><title>Some Useful Techniques</title>


<para>
The definition of a circuit consists of two parts:



-- A <emphasis>type declaration</emphasis>, which describes the
<emphasis>interface</emphasis> of the circuit.  This includes a precise
description of the input and output ports.

--  A <emphasis>defining equation</emphasis>, which describes the internal
structure of the circuit.  This gives names to some or all of the
signals, states what internal components are used, and how they are
connected.
</para>


<para>
Running quick experiments by entering expressions like "inv True" can
be helpful, but it's also a good idea to include suitable test cases
as permanent definitions in a circuit specification module.  One way
to do this is to define a test case by a top-level equation, like
this:
</para>

<programlisting>
> test_inv_1 = inv True   -- should be False
> test_inv_2 = inv False  -- should be True
</programlisting>

<para>
Now you can run these test cases any time by entering the name
interactively:
</para>

<programlisting>
*Tutorial1> test_inv_1
  False
</programlisting>

<para>
Although these examples are trivial, as you develop larger designs it
is helpful to have a collection of test cases, with the expected
results in comments.  These serve as examples of how to use the
circuits, and if a change to the file somewhere causes everything to
go wrong, you can easily run all the tests again to find out what is
working.
</para>

<para>
Many circuits cannot be handled directly using either
\textit{truthTable} or the \textit{truthTableij} family.  These
include circuits with too many inputs or outputs, and ones that have
signals with special grouping.  It is still straightforward to
generate their truth tables; you just need to make a temporary
definition of an equivalent circuit with the inputs all in one word,
and the outputs all in another.  For example, the full adder circuit
(module \textit{BitComb}) has type
\begin{equation}
  \label{eq:3}
  \mathit{fullAdd}\ ::\ \mathit{Signal}\ a\ \Rightarrow\
    (a,a) \rightarrow a \rightarrow (a,a)
\end{equation}
Even though this has only 3 inputs and 2 outputs, we can't use
\textit{truthTable32} because the first two inputs are grouped in a
tuple.  However, we can test it by using a \textbf{let} expression to
define an equivalent circuit \textit{f} which is compatible with
\textit{truthTable}:
</para>

<programlisting>
>      let f [x,y,c] =
>            let (c',s) = fullAdd (x,y) c
>              in [c',s]
>        in truthTable 3 f
</programlisting>


<para>
Port Specifications


Multiple Inputs


Multiple Outputs


Fanout and Partial Applications
</para>

<para>
Suppose you have a circuit $f$ that takes two inputs, an opcode
\textit{op} and a data input $x$.  Often one needs to apply such a
circuit to every bit in a word, but where each bit position receives
the same opcode.  That is, given input $[x_0, x_1, \ldots, x_{k-1}]$,
we want the output to be \[[f op x_0, f op x_1, \ldots, f op
x_{k-1}.\]
</para>

<para>
One way to express this is by writing out all the applications
explicitly:
</para>

<programlisting>
circ_v1 op [x0,x1,x2,x3] =
  [f op x0, f op x1, f op x2, f op x3]
</programlisting>

<para>
A more concise way to write it is to define locally a special version
of $f$ that is already connected to the shared signal \textit{op}.
Calling this specialized circuit $g$, we have a second version of the
circuit:
</para>

<programlisting>
circ_v2 op [x0,x1,x2,x3] = [g x0, g x1, g x2, g x3]
  where g x = f op x
</programlisting>

<para>
It is straightforward to see that the two circuits are equivalent.
For the first bit position, we can use the definition of g to
calculate $g x0 = f op x0$.  An equivalent way to write this
definition is to omit that last $x$ on both sides of the equation
defining $g$, leading to a third version:
</para>

<programlisting>
circ_v3 op [x0,x1,x2,x3] = [g x0, g x1, g x2, g x3]
  where g = f op
</programlisting>

<para>
The choice between versions 2 and 3 is entirely stylistic; it's just a
matter of personal taste.  Version 2 may seem more straightforward at
first, but version 3 is more concise, as it allows you to define the
specialized circuit just by writing $(f\ \mathit{op})$ as an
expression, without even requiring an equation.
</para>

<para>
A definition like $g$ is called a \textit{partial application},
because it is an $f$ box applied to a partial set of its inputs, but
not all of them.  Partial applications are frequently useful in
conjunction with design patterns.  For example, we could generalize
the circuit defined above to work on words of arbitrary size using a
\textit{map} pattern, as follows:
</para>

<programlisting>
circ op xs = map (f op) xs
</programlisting>

<para>
Note that we cannot write $\mathit{map2}\ f\ \mathit{op}\ \mathit{xs}$
because \textit{op} is not a word.  For another example of the use of
partial applications, see the shift register definitions in Section
??.
</para>

<programlisting>
circ :: Signal a => a -> a -> (a,a)
circ a b = (y,z)
  where
    p = inv a
    y = and2 p b
    z = or2 p b
</programlisting>


<programlisting>
> mux1 :: Signal a => a -> a -> a -> a
> mux1 c x y = or2 (and2 (inv c) x) (and2 c y)
</programlisting>

<programlisting>
> mux2 :: Signal a => (a,a) -> a -> a -> a -> a -> a
> mux2 (c,d) p q w r =
>   mux1 c (mux1 d p q) (mux1 d w r)
</programlisting>

<programlisting>
> winv4 :: Signal a => [a] -> [a]
> winv4 [x0,x1,x2,x3]
>   = [inv x0, inv x1, inv x2, inv x3]
</programlisting>

<para>
If a circuit takes an input word and produces an output word, then its
truth table can be generated using the \textit{truthTable} function.
This takes two arguments: the size $k$ of the input word, and the
circuit.  For example, we can define a circuit \textit{inv4} that
inverts a 4-bit word:
</para>

<programlisting>
> winv4 :: Signal a => [a] -> [a]
> winv4 [x0,x1,x2,x3]
>   = [inv x0, inv x1, inv x2, inv x3]
</programlisting>

<para>
Now its truth table can be generated by entering
</para>

<programlisting>
truthTable 4 winv4
</programlisting>



<programlisting>
> halfAdd :: Signal a => a -> a -> (a,a)
> halfAdd x y = (and2 x y, xor2 x y)
</programlisting>

<programlisting>
> bsum, bcarry :: Signal a => (a,a) -> a -> a
> bsum (x,y) c = xor3 x y c
> bcarry (x,y) c = or3 (and2 x y) (and2 x c) (and2 y c)
</programlisting>

<programlisting>
> fullAdd :: Signal a => (a,a) -> a -> (a,a)
> fullAdd (x,y) c = (bcarry (x,y) c, bsum (x,y) c)
</programlisting>

<programlisting>
> rippleAdd4 :: Signal a => a -> [(a,a)] -> (a,[a])
> rippleAdd4 c [(x0,y0),(x1,y1),(x2,y2),(x3,y3)]
>   = (c0, [s0,s1,s2,s3])
>   where
>     (c0,s0) = fullAdd (x0,y0) c1
>     (c1,s1) = fullAdd (x1,y1) c2
>     (c2,s2) = fullAdd (x2,y2) c3
>     (c3,s3) = fullAdd (x3,y3) cin
</programlisting>

<para>
\begin{exercise}
  Produce a truth table for the 4-bit ripple carry adder,
  \textit{rippleAdd4}.  Choose randomly a few of the lines of this
  rather lengthy table, and verify that the circuit's outputs are
  correct.
\end{exercise}
</para>

<programlisting>
\begin{figure}[htbp]
  \begin{center}
    \includegraphics{../figures/xfig/rippleAdd4.eps}
    \caption{4-Bit Ripple Carry Adder}
    \label{fig:rippleAdd4}
  \end{center}
\end{figure}
</programlisting>


</sect1>

</chapter>

<chapter><title>Tu3seq.hs: Sequential Circuits</title>

<para>
foo
</para>

<sect1><title>Clocked signals</title>

<para>
A sequential circuit has behavior that changes over time.  We will use
synchronous circuits, which require (1) every flip flop receives a
clock tick simultaneously, and (2) every feedback loop must go through
a flip flop.
</para>

<para>
Clocked signals
</para>

<para>
Any circuit that contains a flip flop requires the synchronous model
to specify its behavior.  This, in turn, requires that the
representation of signals must be able to handle the system clock.  We
express that by the notation "Clocked a =>" in the circuit's type.
</para>

<programlisting>
> seqcirc :: Clocked a => a -> a
> seqcirc x = y
>   where y = dff z
>         z = xor2 x y
</programlisting>

<para>
Now the value of a Clocked signal is not simply True or False; it has
a value during every clock cycle.  A sequence of values over time is
called a stream.  The input data for seqcirc must therefore have a
type Stream Bool.  We can construct the signal by writing a list of
values, where the i'th element of the list is the input during clock
cycle i, and then converting the list to a stream with the listStream
function:
</para>

<programlisting>
> test_input_1 :: Stream Bool
> test_input_1 =
>   listStream
>     [True,  False, True,  True,
>      False, True,  False, False,
>      True,  True,  True,  False]
</programlisting>

<para>
The definition above says that the signal has value True during cycle
0, False during cycle 1, and so on.  Strictly speaking, the list
should be infinitely long because the clock runs -- at least in
principle -- forever.
</para>

</sect1>


<sect1><title>Sequential Circuits</title>

<sect2><title>Feedback</title>

<programlisting>
> reg1 :: Clocked a => a -> a -> a
> reg1 ld x = r
>   where r = dff (mux1 ld r x)
</programlisting>

<programlisting>
\begin{figure}[htbp]
  \begin{center}
    \includegraphics{../figures/xfig/reg1.eps}
    \caption{Register Bit}
    \label{fig:reg1}
  \end{center}
\end{figure}
</programlisting>

<programlisting>
> reg4 :: Clocked a => a -> [a] -> [a]
> reg4 ld [x0,x1,x2,x3] =
>   [reg1 ld x0, reg1 ld x1, reg1 ld x2, reg1 ld x3]
</programlisting>

</sect2>
</sect1>


<sect1><title>Sequential simulation</title>

<para>
Now we can simulate the circuit by applying it to its input signal.
but it's a good idea first to work out by hand the expected results.
Do this by making a table, where each column is a signal value and
each row is a clock cycle.  It's helpful to break the columns into
several categories: the clock cycle, the input signals, the flip flop
states, the outputs, and other internal signals.  For seqcirc, y is
both a flip flop state and an output of the circuit.  The table has
the form:
</para>

<programlisting>
                  Output
  Cycle | Input | State | Signals
        |   x   |   y   |   z
  -------------------------------
    0   |   1       0
    1   |   0
    2   |   1
    3   |   1
   ...  |   0
</programlisting>

<para>
Now initialize the table by setting the initial state of each flip
flop (i.e. its output during Cycle 0) to the flip flop power-up value,
and filling in some of the inputs.  For the Stream Bool model, the
initial flip flop state (and output value) is False (thus we assume
that the flip flop has a 0 when you first turn on power to the
circuit; in some of the other circuit models we will not make that
assumption).  To save space, We'll write 0 for False and 1 for True.
So the initial table is
</para>

<programlisting>
                  Output
  Cycle | Input | State | Signals
        |   x   |   y   |   z
  -------------------------------
    0   |   1       0
    1   |   0
    2   |   1
    3   |   1
   ...  |   0
</programlisting>

<para>
Now for each cycle, do the following:
</para>

<para>


(1) Simulate the settling down of the combinational logic by working
    out all the signal values.  Notice that when you work out the value
    of a combinational logic signal in a certain row of the table, you
    always use existing values from that same row.

    For Cycle 0, note that z = xor2 x y = xor2 1 0 = 1, giving:
</para>

<programlisting>
                  Output
  Cycle | Input | State | Signals
        |   x   |   y   |   z
  -------------------------------
    0   |   1       0       1
    1   |   0
    2   |   1
    3   |   1
   ...  |   0
</programlisting>

<para>
(2) Simulate the clock tick that ends the cycle: find the value of the
    input to a flip flop, and write it down as the flip flop's state
    for the *next* cycle.  Now the input to the flip flop y is the
    signal z, and z=1 in Cycle 0, so write down 1 as the flip flop
    state  y in the next row of the table:
</para>

<programlisting>
                  Output
  Cycle | Input | State | Signals
        |   x   |   y   |   z
  -------------------------------
    0   |   1       0       1
    1   |   0       1
    2   |   1
    3   |   1
   ...  |   0
</programlisting>

<para>
Continue the simulation, row by row.  You will alternately simulate a
clock cycle followed by a tick, then the next cycle, and so on, and as
time passes you'll fill the table from top to bottom.  After a few
cycles the table should look like this:
</para>

<programlisting>
                  Output
  Cycle | Input | State | Signals
        |   x   |   y   |   z
  -------------------------------
    0   |   1       0       1
    1   |   0       1       1
    2   |   1       1       0
    3   |   1       0       1
    4   |   0       1       1
    5   |   1       1       0
    6   |   0       0       0
    7   |   0       0       0
    8   |   1       0       1
    9   |   1       1       0
   10   |   1       0       1
   11   |   0       1       1
</programlisting>

<para>
Now, after simulating some test data by hand, enter the following
expression into Hydra:
</para>

<programlisting>
seqcirc test_input_1
</programlisting>

<para>
Hydra performs the simulation and produces the following result:
</para>

<programlisting>
*Tutorial1> seqcirc test_input_1
0,1,1,0,1,1,0,0,0,1,0,1,1,*** Exception: no more stream data from list
</programlisting>

<para>
The output matches the results of the manual simulation.  The output
uses 1 and 0 rather than True and False; Hydra is still using True and
False to represent the signal values during a clock cycle, but it has
converted the Booleans to 0/1 automatically.  Since the input data
terminated after twelve cycles, an exception was thrown indicating
that there is no input data for cycle 12.  This message can be
ignored.
</para>

</sect1>





</chapter>

<chapter><title>Tu4sim.ha: Simulation Drivers</title>

<sect1><title>foo</title>


<para>

 Hydra: Simulation Drivers

Introduction
</para>

<para>
The subject of this tutorial is simulation drivers: software tools
that make it easier to write down the inputs and to read and
understand the outputs when you're simulating a circuit.
</para>

<para>
Small circuits can be simulated by providing the values of all the
individual input bits, and reading the resulting output bits.  For
larger scale designs, there are just too many bits for this to be
feasible.  To simulate a processor, there are likely to be several
input words and a dozen of more output words; this would require the
user to read through hundreds of 0s and 1s, and to do that again and
again for each clock cycle.
</para>

<para>
A simulation driver is a piece of software that takes input in a
readable form, runs the simulation, and formats the output signals.
We will use a simulation driver for each of our main circuits. 
We'll provide inputs to sequential circuits by making a list, where
each line of the list corresponds to a clock cycle, and it contains
the input signal values for that cycle (expressed in decimal).
</para>

<para>
Since any clocked signal is a signal, there is no problem with doing a
synchronous simulation of a combinational circuit.
</para>

<para>
The simulation driver for a synchronous circuit contains four main
pieces:



Choices for the circuit parameters, if any; these typically
include word size and address size.

An equation that applies the circuit to its inputs, defining names
for the outputs.

Tools that take the inputs expressed in a form easy for the user
to write and convert them to the proper input signal representation.

Tools that take the output signals from the circuit and format
them readably.

</para>

<para>

Simulation driver for the adder</para>

<para>
To show how to write a simulation driver, this section will work
through an example in detail: a driver for the ripple carry adder,
with type
</para>

<para>
  Clocked a => a -> [(a,a)] -> (a,[a])
</para>

<para>
The adder has one circuit parameter, its wordsize, since our ripple
carry adders may be defined using design patterns that work for
arbitrary size!  Here we use 8-bit words.
</para>

<para>
n = 8

The heart of the simulation driver is an equation that uses the
circuit.  Here, we define the carry output co and the sum word s to be
the outputs of an adder with input words x and y; these are
represented in bit slice form as a single word z :: [(a,a)].
</para>

<programlisting>
    (co,s) = rippleAdd ci z
</programlisting>

<para>
The bit slice word z is formed by the bitslice2 wiring pattern:
</para>

<programlisting>
    z = bitslice2 x y
</programlisting>

<para>
We could also omit this equation, and write the circuit application as
</para>

<programlisting>
    (co,s) = rippleAdd ci (bitslice2 x y)
</programlisting>

<para>
The inputs to the circuit can be provided interactively, but sometimes
it's more convenient to define a set of inputs as a constant
definition in the simulation module.  This allows us to run a
simulation repeatedly, without having to keep typing the same inputs
over and over again.  That approach will be taken here; later we will
introduce tools that support interactive simulations.
</para>

<para>
There are three values to be supplied for each clock cycle: the carry
input, and the two words x and y.  These will be written in a list of
lists; here's an example definition of test input:
</para>

<programlisting>
> add_input1 :: [[Int]]

> add_input1 =
>   [[0,  2,  3],
>    [0,  1,  8],
>    [0, 10,  5],
>    [0, 11,  2],
>    [1,  4,  5]]
</programlisting>

<para>
This says that in clock cycle 0, the carry input is 0, x is 3, and y
is 8; in clock cycle 1 x=5 and y=-9, and so on.  Note that the words
can be written in decimal in the test data.
</para>

<para>
The simulation driver is called \texttt{sim\_adder}, and you give it three arguments:
  -- the name of the adder circuit you want to use
  -- the wordsize
  -- the input data
For example,
</para>

<programlisting>
sim_adder rippleAdd4  4 add_input1
</programlisting>

<para>
says to use the 4-bit ripple carry adder (the same one presented in
lecture) with the data above.  Go ahead and enter that line at the
prompt, and you should see output something like this...
</para>

<programlisting>
Tutorial1> sim_adder rippleAdd4 4 add_input1

..................................................
   Simulating ripple carry adder
      0.   ci=0 x=   2 y=   3   Output: 0   5
      1.   ci=0 x=   1 y=   8   Output: 0   9
      2.   ci=0 x=  10 y=   5   Output: 0  15
      3.   ci=0 x=  11 y=   2   Output: 0  13
      4.   ci=1 x=   4 y=   5   Output: 0  10
..................................................
</programlisting>

<para>
Now you can try some other experiments, for example by using the
general n-bit adder (rippleAdd) or by varying the wordsize.  Of course
you can also modify the input test data.  To run the experiments,
enter the following expressions:
</para>

<programlisting>
   sim_adder rippleAdd4  4 add_input1
   sim_adder rippleAdd   4 add_input1
   sim_adder rippleAdd  16 add_input1
</programlisting>


<para>Writing a Simulation Driver for the Ripple Carry Adder</para>

<para>
Now we need to use the tools for converting the test input to the
correct signal representations:
</para>

<programlisting>
   ci = getbit   input 0 :: Stream Bool 
   x  = getbin n input 1
   y  = getbin n input 2
</programlisting>

<para>
The first equation says that ci is obtained from the 0'th column of
the test input, using a bit conversion (getbit).  The second equation
says that x comes from column 1 in the test input, and it's converted
using a binary conversion (getbin n), where n is the wordsize.  The
last equation converts y from column 2 of the input data.
</para>

<para>
The final step is to format the output.  First, we specify the
underlying signal representation that is being used:
</para>

<programlisting>
   simoutput :: [Format Bool]
</programlisting>

<para>
This is necessary, because Hydra supports a large number of signal
representations, and it needs to know which one to use here.
</para>

<para>
Now we define the simulation output by formatting the various signals
that should be printed.  The format consists of a list of fields
separated by commas.  For every clock cycle, Hydra will print a line
comprising all these fields.  The field format specifications are
</para>

<programlisting>
  string "abc"  prints the literal string on each line
  bit x         prints the value of the bit signal x, as 0 or 1
  bindec k x    converts the binary word x to a 4-digit decimal integer
  tcdec k x     converts the two's complement word x to a 4-digit
                decimal integer
</programlisting>

<para>
The following format prints the adder's inputs and outputs, along with
some labels:
</para>

<programlisting>
    simoutput =
      [bit ci,
       string " x= ", bindec 4 x, tcdec 4 x,
       string " y= ", bindec 4 y, tcdec 4 y,
       string " Output: ", bit co,
       string " sum= ", bindec 4 s, tcdec 4 s]
</programlisting>

<para>
Putting all the pieces together, here is the simulation driver for the
ripple carry adder:
</para>

<programlisting>
> sim_adder add_circuit n input =
>   let (co,s) = add_circuit ci (bitslice2 x y)
>       ci = getbit   input 0
>       x  = getbin n input 1
>       y  = getbin n input 2
>       simoutput :: [Format Bool]
>       simoutput =
>         [string " ci=", bit ci,
>          string " x= ", bindec 3 x,
>          string " y= ", bindec 3 y,
>          string "   Output: ", bit co, bindec 4 s]
>   in do putStrLn "\nSimulating ripple carry adder"
>         run input simoutput
</programlisting>

<para>
A simulation driver for the comparitor

The ripple comparitor for binary numbers can be simulated by entering
the following:
</para>

<programlisting>
   sim_comparitor rippleCmp 16 cmp_input1
</programlisting>

<para>
Here is some test data for the comparitor...
</para>

<programlisting>
> cmp_input1 :: [[Int]]
> cmp_input1 =
>   [[2, 3],
>    [3, 2],
>    [3, 3],
>    [1, 8],
>    [8, 1],
>    [9, 9],
>    [0, 5],
>    [7, 5]]
</programlisting>

<para>
The simulation driver is similar to the adder driver.
</para>

<programlisting>
> sim_comparitor circuit n input =
>   let (lt,eq,gt) = circuit (bitslice2 x y)
>       x = getbin n input 0
>       y = getbin n input 1
>       simoutput :: [Format Bool]
>       simoutput =
>         [string " x= ", bindec 4 x,
>          string "   y= ", bindec 4 y,
>          string "  (lt,eq,gt) = ",
>          bit lt, bit eq, bit gt]
>   in do putStrLn "\nSimulating comparitor"
>         run input simoutput
</programlisting>


<para>
The simulation driver for a synchronous circuit contains four main
pieces:
</para>

<para>
\begin{itemize}
\item Definitions of the circuit parameters, if any; these typically
  include word size and address size.
\item An equation that applies the circuit to its inputs, defining
  names for the outputs.
\item Tools that take the inputs expressed in a form easy for the user
  to write and convert them to the proper input signal representation.
\item Tools that take the output signals from the circuit and format
  them readably.
\end{itemize}
</para>

<para>
The simulation is performed by executing the IO operation \textit{run
  input simoutput}, where $\textit{input} :: [[\textit{Int}]]$ is the
input data specified by the user.  Thus the form of a typical simulation
  driver is
\begin{align*}
   \mathit{simoutput}\ ::\ [\mathit{Format}\ \mathit{Bool}] \\
   \mathit{simoutput}\ =\ [\ldots\ \textit{list of format specifiers}\ \ldots]
\end{align*}
</para>

<sect2><title>Number System Conversions</title>

<para>
There are functions for converting between natural numbers (using
binary representation), integers (using two's complement
representation) bit strings, and hexadecimal.
</para>

<para>
The functions most useful for generating input signals are: intbit
intbin inttc hexbin hextc.
</para>

<para>
The functions most useful for interpreting output signals are: bitint
binint tcint binhex tchex.

\textit{more later...}
</para>

</sect2>

<sect2><title>Sequential Simulation</title>

<para>
Circuits often have large numbers of input and output signals. It can
be difficult and error prone to set up the inputs for a simulation, as
well as to interrpret the outputs.  For example, it is straightforward
but tedious to convert decimal numbers to binary or two's complement
representations.  Furthermore, an actual simulation requires the
inputs to be expressed in a signal class instance.  This is
essentially a data structure intended for internal use only, and the
circuit designer should not need to delve into Hydra's internal data
structures.
</para>

<para>
solution: a software interface to the simulation, called a simulation
driver. It allows input to be provided in a readable form, and
translates this to the actual signal inputs required by the
circuit. Conversely, it takes the cirucuit's output signals, converts
them to a convenient notation, and formats them neatly for output.
</para>

<para>
It's important to be clear about what is software and what is
hardware--especially when the hardware isn't really hard, but is
actually being created virtually via simulation!
</para>
</sect2>

</sect1>


<sect1><title>Example: A Simple Simulation Driver</title>

<para>
The tools for writing simulation drivers are illustrated in this
section by a simple standalone driver, which reads some signals and
then just outputs them directly, without processing them with a circuit.
</para>

<para>
In this experiment, there are three inputs: a bit $x$, an 8-bit binary
number $y$, and an 8-bit two's complement number $z$.  Each line of
the input will be specified with integers for $x$, $y$, ans $z$ in
order.  A particular input data set \textit{test\_input} is defined
below.  It's a good idea to line up the elements neatly, so that any
signal can be followed through time by reading down a column.
Comments are used to label each column with the signal name, and to
say what the representation for that signal is.  In this example, the
cycle numbers are labelled as well.  Normally this is unnecessary, but
in a test case that runs for only a few cycles it may be helpful.
</para>

<programlisting>
> test_input :: [[Int]]
> test_input =
> --  x    y     z
> -- bit  bin   tc
> -- ~~~~~~~~~~~~~~~
>   [[0,    5,    5],     -- cycle 0
>    [1,  255,   -1],     -- cycle 1
>    [1,    0,  127],     -- cycle 2
>    [0,   42, -128],     -- cycle 3
>    [1,  195,  -37]      -- cycle 4
>   ]
</programlisting>

<programlisting>
> standalone_driver :: [[Int]] -> IO ()
> standalone_driver input = do run input simoutput
>   where
>
> -- Size parameters
>     n = 8
>
> -- Input formatting
>     x = getbit   input 0 :: Stream Bool
>     y = getbin n input 1
>     z = gettc  n input 2
>
> -- Output formatting
>     simoutput :: [Format Bool]
>     simoutput =
>       [string "x = ", bit x,
>        string "      y = ", hex y, bindec 5 y, tcdec 5 y,
>        string "      z = ", hex z, string " ", bits z,
>          bindec 5 z, tcdec 5 z]
</programlisting>

<para>
The simulation can now be performed by running the driver with an
input data set.  One way is to enter the expression

<programlisting>
standalone_driver test_input
</programlisting>

at the interactive prompt.  With larger design projects, it's useful
to define a batch script \texttt{main} which executes the test.  This
allows many test cases to be run together.  It is a good idea to run
such batch tests regularly as a design is developed, to ensure that
any changes haven't introduced bugs.
</para>

<programlisting>
> main :: IO ()
> main =
>   do standalone_driver test_input
</programlisting>

<para>
The output from executing \texttt{main} is shown below.  From the
output it's easy to see that $x$ is the same values as were specified
in the input.  The second signal, $y$, is an 8-bit word which is
displayed three ways: as a hexadecimal, as an integer using binary
representation, and as an integer using two's complement
representation.  Note that $y$ was input using a binary format
specifier, and the binary output gives exactly the same values.
Naturally, the two's complement output for $y$ is different; for
example, the word consisting of all 1s represents 255 in binary but -1
in two's complement.  Since $z$ was input using a two's complement
format, the two's complement output column shows the same values,
while the binary output column may be different.
</para>

<programlisting>
*FormatTest> main
   0.  x = 0      y = 05    5    5      z = 05 00000101    5    5
   1.  x = 1      y = ff  255   -1      z = ff 11111111  255   -1
   2.  x = 1      y = 00    0    0      z = 7f 01111111  127  127
   3.  x = 0      y = 2a   42   42      z = 80 10000000  128 -128
   4.  x = 1      y = c3  195  -61      z = db 11011011  219  -37
</programlisting>
</sect1>

<sect1><title>Batch Testing</title>

<para>
This is a single operation that runs the various examples above as one
large batch.  You can run it by just launching Hydra, loading this
file, and entering "main" at the prompt.
</para>

<programlisting>
main =
  do putStrLn "Hydra: running Tutorial1 batch"
     sim_adder rippleAdd 16 add_input1
     sim_sr4 sr4_input
     sim_regfile
     sim_regfile_dec
     sim_rtm
     sim_mult
     putStrLn "Examples1 finished"
</programlisting>

<itemizedlist>
<listitem><para>truthTable11</para></listitem>
<listitem><para>truthTable12</para></listitem>
<listitem><para>truthTable21</para></listitem>
<listitem><para>truthTable22</para></listitem>
<listitem><para>truthTable23</para></listitem>
<listitem><para>truthTable31</para></listitem>
<listitem><para>truthTable32</para></listitem>
<listitem><para>truthTable33</para></listitem>
<listitem><para>truthTable41</para></listitem>
<listitem><para>truthTable42</para></listitem>
<listitem><para>truthTable43</para></listitem>
</itemizedlist>

</sect1>


<sect1><title>from ref man</title>
<para> foo </para>
</sect1>

<sect1><title>Formatting input and output signals</title>

<para>
A "simulation driver" is a piece of software that takes input in a
readable form, runs the simulation, and formats the output signals.
We will use a simulation driver for each of our main circuits. 
We'll provide inputs to sequential circuits by making a list, where
each line of the list corresponds to a clock cycle, and it contains
the input signal values for that cycle (expressed in decimal).
</para>


<sect2><title>Providing Input to a Circuit</title>

<para>
The inputs for a simulation are written as lists of integers, and the
simulation driver contains format specifiers that say how to obtain
the signals from these integers.
</para>

<para>
The simulation input is a value of type $[[\textit{Int}]]$, and is
typically given the name \textit{input}.  The $i$th element of
\textit{input} specifies all the circuit inputs for clock cycle $i$,
and is a list of elements that define the input signal values during
cycle $i$.
</para>

<para>
Each clock cycle input is a list of integers.  The signals are
calculated from those integers using \emph{input format specifiers.}
Generally, each signal comes from one element of the list.  Each
signal is defined by an equation of the form
\begin{equation}
  \label{eq:1}
  \mathit{signal}\ =\ \mathit{format}\ \mathit{input}\ i
\end{equation}
where $i$ is an index within the list of integers for the cycle.  For
example, the equation
\begin{equation}
  \label{eq:2}
  x\ =\ \mathit{getbit}\ \mathit{input}\ 3
\end{equation}
says that the signal $x$ is a bit whose value is given in the third
element of \textit{input}.
</para>

<para>
A variety of input formats are provided, allowing you to extract bits
and words, using either binary or two's complement representation.
The most frequently used input formats are:
</para>

<para>
\begin{itemize}
\item $b\ =\ \mathit{getbit}\ \mathit{input}\ i$ defines $b$ as a bit
  signal representing the $i$th element of the input list.  The value
  of $b$ during a clock cycle is \textit{zero} if the corresponding
  input integer is 0, and \textit{one} if the integer is 1.
\item $w\ =\ \mathit{getbin}\ k\ \mathit{input}\ i$ defines $w$ to be
  a $k$-bit word whose binary interpretation is the $i$th integer in
  the input list.
\item $w\ =\ \mathit{gettc}\ k\ \mathit{input}\ i$ defines $w$ to be a
  $k$-bit word whose two's complement interpretation is the $i$th
  integer in the input list.
\end{itemize}
</para>

</sect2>

<sect2><title>Interpreting the Output from a Circuit</title>

<para>
The output signals produced by a circuit may be hard to read directly,
partly because there are likely to be too many bits to grasp easily,
and partly because the data structures that Hydra uses to represent
clocked signals contain a lot of detail.
</para>

<para>
To make the outputs more readable, a simulation driver uses a format
specification to construct neat textual output.  A complete format is
a list of individual specifiers, each of which produces one or more
characters of output. The output specification can be given a name
like \textit{simoutput}, and defined as follows
\begin{align*}
   \mathit{simoutput}\ ::\ [\mathit{Format}\ \mathit{Bool}] \\
   \mathit{simoutput}\ =\ [\ldots\ \textit{list of format specifiers}\ \ldots]
\end{align*}
</para>

<para>
The format specifiers are:
</para>

<para>
\begin{itemize}
\item $\mathit{bit}\ b$ outputs the bit $b$ in one character, which
  will be either \texttt{0} or \texttt{1}.
\item $\mathit{bits}\ w$ outputs the word $w$ in a string of length
  $k$ consisting of \texttt{0}s and \texttt{1}s, where $k$ is the size
  of $w$.
\item $\mathit{hex}\ w$ outputs the word $w$ as a hexadecimal string.
  The size of the string is the $\lceil k/4 \rceil$ ($k/4$ rounded up
  to an integer), which is the minimal size needed to represent $w$.
\item $\mathit{bindec}\ k\ w$ interprets the word $w$ as a binary
  representation, and converts it to a decimal number $k$ characters
  wide.  Leading spaces are attached if necessary to fill the field.
\item $\mathit{tcdec}\ k\ w$ interprets the word $w$ as a two's
  complement representation, and converts it to a decimal number $k$
  characters wide.
\item $\mathit{string}\ s$ outputs the character string $s$, which is
  useful for labelling signals, inserting newlines, etc.
\end{itemize}
</para>

</sect2>
</sect1>

<sect1><title>foo</title>

<para>
Design examples
</para>

<para>Bidirectional shift register
</para>

<para>
The bidirectional shift register takes an operation code that
determines the behavior:
</para>

<programlisting>
  0 -- no state change
  1 -- load input word x
  2 -- shift right
  3 -- shift left
</programlisting>

<para>
The following test data contains comments showing the expected output.
This is a useful technique for documenting a circuit, and it provides
a good permanent test case.  You can run the simulation by copying the
following expression, and pasting it into a Hydra dialogue:
</para>

<programlisting>
  sim_sr4 sr4_testdata_1

> sr4_testdata_1 :: [[Int]]
> sr4_testdata_1 =
> --      op  l  r  x        op    produce  state
> --      ~~~~~~~~~~~       ~~~~~~~~~~~~~~~~~~~~~
>        [[1, 0, 0, 9],  -- load     1001    0000
>         [0, 0, 0, 3],  -- nop      1001    1001
>         [2, 1, 0, 4],  -- right 1  1100    1001
>         [2, 0, 0, 2],  -- right 0  0110    1100
>         [3, 0, 1, 7],  -- left  1  1101    0110
>         [1, 0, 0, 5],  -- load     0101    1101
>         [0, 0, 0, 0]]  -- nop      0101    0101
</programlisting>

<para>
Here is a simulation driver intended specifically for the 4-bit
version of the circuit.
</para>

<programlisting>
> sim_sr4 input =
>   let op = getbit2  input 0
>       l =  getbit   input 1
>       r =  getbit   input 2
>       x =  getbin 4 input 3
>       (op0,op1) = op
>       y = sr4 op l r x
>       simoutput :: [Format Bool]
>       simoutput = [string "Input: ",
>               bit op0, bit op1, string " ",
>               bit l, string " ", bit r, string " ", bits x,
>               string "    Output: ", bits y]
>   in do putStrLn "\nSimulate 4-bit shift register"
>         run input simoutput
</programlisting>

<para>The register file
</para>

<para>
Now we'll simulate a register file with 16 registers, each containing
16 bits.  This is the circuit used within the ITM!  The circuit
definition appears in WordSeq.lhs, and here is the test data:
</para>

<programlisting>
> regfile_input1 :: [[Int]]
> regfile_input1 =
> --      ld  d sa sb  x
> --      ~~~~~~~~~~~~~~~
>        [[1, 4, 0, 0,  25],  -- R4 :=  25    R0 =   0, R0 =   0
>         [1, 7, 4, 7, 255],  -- R7 := 255    R4 =  25, R7 =   0
>         [1, 1, 4, 7,  31],  -- R1 :=  31    R4 =  25, R7 = 255
>         [0, 1, 0, 1,  50],  --              R0 =   0, R1 =  31
>         [1, 2, 1, 7, 100],  -- R2 := 100,   R1 =  31, R7 = 255
>         [0, 0, 0, 2,   0]]  --              R0 =   0  R2 = 100
</programlisting>

<para>
This means, for example, that in the initial clock cycle ld=1, so x
(which is 25) will be loaded into reg[4] (because the destination
address d is 4).  On the next clock cycle, the source address sa is 4,
so the circuit will output the contents of reg[4], which by then will
be 25.  You should work through this input data in detail.
</para>

<para>
Run the simulation by entering
</para>

<programlisting>
  sim_regfile regfile_input1
</programlisting>

<para>
You can see that the long binary numbers are hard to read.  There is
another simulation driver which converts the numbers to decimal;
exactly the same circuit is simulated, but the output is more
readable.  You can try it by entering
</para>

<programlisting>
  sim_regfile_dec regfile_input1
</programlisting>

<para>
It's a good idea to make up your own example: work out a sequence of
operations for the register file to perform, figure out what input
signals are needed to achieve it, edit \texttt{regfile\_input1}, and run the
simulation.
</para>

<programlisting>
> sim_regfile =
>   let k = 3  -- there are 2^3 = 8 registers
>       n = 8  -- each register contains 8 bits
>       input =
> --      ld  d sa sb  x
> --      ~~~~~~~~~~~~~~~
>        [[1, 4, 0, 0,  25],  -- R4 :=  25    R0 =   0, R0 =   0
>         [1, 7, 4, 7, 255],  -- R7 := 255    R4 =  25, R7 =   0
>         [1, 1, 4, 7,  31],  -- R1 :=  31    R4 =  25, R7 = 255
>         [0, 1, 0, 1,  50],  --              R0 =   0, R1 =  31
>         [1, 2, 1, 7, 100],  -- R2 := 100,   R1 =  31, R7 = 255
>         [0, 0, 0, 2,   0]]  --              R0 =   0  R2 = 100
>       ld = getbit   input 0
>       d  = getbin k input 1
>       sa = getbin k input 2
>       sb = getbin k input 3
>       x  = getbin n input 4
>       (a,b) = regfile n k ld d sa sb x
>       simoutput :: [Format Bool]
>       simoutput =
>         [string "Input: ",
>          bit ld, string " ", bits d, string " ",
>          bits sa, string " ", bits sb, string " ", bits x,
>          string "   Output: ", bits a, string " ", bits b]
>   in do putStrLn "\nSimulating register file (format output as binary)"
>         run input simoutput
</programlisting>

<para>
The following is the same as \texttt{sim\_regfile}, but it prints the output
using decimal representations.  The only difference appears in
simoutput, where bindec is used instead of bits for printing the binary
numbers in decimal notation.
</para>

<programlisting>
> sim_regfile_dec =
>   let k = 3  -- there are 2^3 = 8 registers
>       n = 8  -- each register contains 8 bits
>       input =
> --      ld  d sa sb  x
> --      ~~~~~~~~~~~~~~~
>        [[1, 4, 0, 0,  25],  -- R4 :=  25    R0 =   0, R0 =   0
>         [1, 7, 4, 7, 255],  -- R7 := 255    R4 =  25, R7 =   0
>         [1, 1, 4, 7,  31],  -- R1 :=  31    R4 =  25, R7 = 255
>         [0, 1, 0, 1,  50],  --              R0 =   0, R1 =  31
>         [1, 2, 1, 7, 100],  -- R2 := 100,   R1 =  31, R7 = 255
>         [0, 0, 0, 2,   0]]  --              R0 =   0  R2 = 100
>       ld = getbit   input 0
>       d  = getbin k input 1
>       sa = getbin k input 2
>       sb = getbin k input 3
>       x  = getbin n input 4
>       (a,b) = regfile n k ld d sa sb x
>       simoutput :: [Format Bool]
>       simoutput =
>         [string "Input: ",
>          bit ld, string " ", bindec 1 d, string " ",
>          bindec 1 sa, string " ", bindec 1 sb,
>          string " ", bindec 3 x,
>          string "   Output: ",
>          bindec 3 a, string " ", bindec 3 b]
>   in do putStrLn "\nSimulating register file (format output as decimal)"
>         run input simoutput
</programlisting>

<para>
Simulate the Register File
</para>

<para>
You don't need to read the simulation driver, which just handles the
formatting of the input and output signals.
</para>

<programlisting>
> sim_regfile2 input =
>   let k =  4  -- there are 2^4 = 16 registers
>       n = 16  -- each register contains 16 bits
>       ld = getbit   input 0
>       d  = getbin k input 1
>       sa = getbin k input 2
>       sb = getbin k input 3
>       x  = getbin n input 4
>       (a,b) = regfile n k ld d sa sb x
>       simoutput :: [Format Bool]
>       simoutput =
>         [string "Input: ",
>          bit ld, string " ", bits d, string " ",
>          bits sa, string " ", bits sb, string " ", bits x,
>          string "\n       Output: ", bits a, string " ", bits b]
>   in do putStrLn "\nSimulating register file (format output as binary)"
>         run input simoutput
</programlisting>

<para>
The following is the same as \texttt{sim\_regfile}, but it prints the output
using decimal representations.  The only difference appears in
simoutput, where bindec is used instead of bits for printing the binary
numbers in decimal notation.
</para>

<programlisting>
> sim_regfile_dec2 input =
>   let k =  4  -- there are 2^4 = 16 registers
>       n = 16  -- each register contains 16 bits
>       ld = getbit   input 0
>       d  = getbin k input 1
>       sa = getbin k input 2
>       sb = getbin k input 3
>       x  = getbin n input 4
>       (a,b) = regfile n k ld d sa sb x
>       simoutput :: [Format Bool]
>       simoutput =
>         [string "Input: ",
>          bit ld, string " ", bindec 1 d, string " ",
>          bindec 1 sa, string " ", bindec 1 sb,
>          string " ", bindec 3 x,
>          string "   Output: ",
>          bindec 3 a, string " ", bindec 3 b]
>   in do putStrLn "\nSimulating register file (format output as decimal)"
>         run input simoutput
</programlisting>

<para>
Sequential multiplier

Simulating the Multiplier
</para>

<programlisting>
> sim_mult =
>   let k = 8
>       input =
> --     start  x    y
> --     ~~~~~~~~~~~~~~
>        [[1,  50,  75],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [1, 100, 100],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [1, 100, 100],
>         [0,   0,   0],
>         [0,   0,   0],
>         [1,   2,   3],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0]]
>       start = getbit   input 0
>       x     = getbin k input 1
>       y     = getbin k input 2
>       (rdy,prod,rx,ry,s) = mult k start x y
>       spec :: [Format Bool]
>       spec =
>         [string "Input: ",
>          bit start, bindec 4 x, bindec 4 y,
>          string "  Output: ",
>          bit rdy, bindec 6 prod, bindec 4 rx, bindec 6 ry,
>          bindec 6 s]
>     in do putStrLn "\nSimulate sequential multiplier"
>           run input spec
</programlisting>

<para>
The Register Transfer Machine
</para>

<para>
Simulating the Register File

Now we'll simulate a register file with 16 registers, each containing
16 bits.  This is the circuit used within the ITM!  The circuit
definition appears in WordSeq.lhs, and here is the test data:
</para>

<programlisting>
> regfile_input1 :: [[Int]]
> regfile_input1 =
> --      ld  d sa sb  x
> --      ~~~~~~~~~~~~~~~
>        [[1, 4, 0, 0,  25],  -- R4 :=  25    R0 =   0, R0 =   0
>         [1, 7, 4, 7, 255],  -- R7 := 255    R4 =  25, R7 =   0
>         [1, 1, 4, 7,  31],  -- R1 :=  31    R4 =  25, R7 = 255
>         [0, 1, 0, 1,  50],  --              R0 =   0, R1 =  31
>         [1, 2, 1, 7, 100],  -- R2 := 100,   R1 =  31, R7 = 255
>         [0, 0, 0, 2,   0]]  --              R0 =   0  R2 = 100

</programlisting>

<para>
This means, for example, that in the initial clock cycle ld=1, so x
(which is 25) will be loaded into reg[4] (because the destination
address d is 4).  On the next clock cycle, the source address sa is 4,
so the circuit will output the contents of reg[4], which by then will
be 25.  You should work through this input data in detail.
</para>

<para>
Run the simulation by entering
</para>

<programlisting>
sim_regfile regfile_input1
  
</programlisting>

<para>
You can see that the long binary numbers are hard to read.  There is
another simulation driver which converts the numbers to decimal;
exactly the same circuit is simulated, but the output is more
readable.  You can try it by entering
</para>

<programlisting>
sim_regfile_dec regfile_input1
  
</programlisting>

<para>
It's a good idea to make up your own example: work out a sequence of
operations for the register file to perform, figure out what input
signals are needed to achieve it, edit \texttt{regfile\_input1}, and run the
simulation.
</para>

<programlisting>
> sim_regfile =
>   let k = 3  -- there are 2^3 = 8 registers
>       n = 8  -- each register contains 8 bits
>       input =
> --      ld  d sa sb  x
> --      ~~~~~~~~~~~~~~~
>        [[1, 4, 0, 0,  25],  -- R4 :=  25    R0 =   0, R0 =   0
>         [1, 7, 4, 7, 255],  -- R7 := 255    R4 =  25, R7 =   0
>         [1, 1, 4, 7,  31],  -- R1 :=  31    R4 =  25, R7 = 255
>         [0, 1, 0, 1,  50],  --              R0 =   0, R1 =  31
>         [1, 2, 1, 7, 100],  -- R2 := 100,   R1 =  31, R7 = 255
>         [0, 0, 0, 2,   0]]  --              R0 =   0  R2 = 100
>       ld = getbit   input 0
>       d  = getbin k input 1
>       sa = getbin k input 2
>       sb = getbin k input 3
>       x  = getbin n input 4
>       (a,b) = regfile n k ld d sa sb x
>       simoutput :: [Format Bool]
>       simoutput =
>         [string "Input: ",
>          bit ld, string " ", bits d, string " ",
>          bits sa, string " ", bits sb, string " ", bits x,
>          string "   Output: ", bits a, string " ", bits b]
>   in do putStrLn "\nSimulating register file (format output as binary)"
>         run input simoutput

</programlisting>

<para>
The following is the same as \texttt{sim\_regfile}, but it prints the output
using decimal representations.  The only difference appears in
simoutput, where bindec is used instead of bits for printing the binary
numbers in decimal notation.
</para>

<programlisting>
> sim_regfile_dec =
>   let k = 3  -- there are 2^3 = 8 registers
>       n = 8  -- each register contains 8 bits
>       input =
> --      ld  d sa sb  x
> --      ~~~~~~~~~~~~~~~
>        [[1, 4, 0, 0,  25],  -- R4 :=  25    R0 =   0, R0 =   0
>         [1, 7, 4, 7, 255],  -- R7 := 255    R4 =  25, R7 =   0
>         [1, 1, 4, 7,  31],  -- R1 :=  31    R4 =  25, R7 = 255
>         [0, 1, 0, 1,  50],  --              R0 =   0, R1 =  31
>         [1, 2, 1, 7, 100],  -- R2 := 100,   R1 =  31, R7 = 255
>         [0, 0, 0, 2,   0]]  --              R0 =   0  R2 = 100
>       ld = getbit   input 0
>       d  = getbin k input 1
>       sa = getbin k input 2
>       sb = getbin k input 3
>       x  = getbin n input 4
>       (a,b) = regfile n k ld d sa sb x
>       simoutput :: [Format Bool]
>       simoutput =
>         [string "Input: ",
>          bit ld, string " ", bindec 1 d, string " ",
>          bindec 1 sa, string " ", bindec 1 sb,
>          string " ", bindec 3 x,
>          string "   Output: ",
>          bindec 3 a, string " ", bindec 3 b]
>   in do putStrLn "\nSimulating register file (format output as decimal)"
>         run input simoutput
</programlisting>

<para>
Simulate the Register File
</para>

<para>
You don't need to read the simulation driver, which just handles the
formatting of the input and output signals.
</para>

<programlisting>
> sim_regfile2 input =
>   let k =  4  -- there are 2^4 = 16 registers
>       n = 16  -- each register contains 16 bits
>       ld = getbit   input 0
>       d  = getbin k input 1
>       sa = getbin k input 2
>       sb = getbin k input 3
>       x  = getbin n input 4
>       (a,b) = regfile n k ld d sa sb x
>       simoutput :: [Format Bool]
>       simoutput =
>         [string "Input: ",
>          bit ld, string " ", bits d, string " ",
>          bits sa, string " ", bits sb, string " ", bits x,
>          string "\n       Output: ", bits a, string " ", bits b]
>   in do putStrLn "\nSimulating register file (format output as binary)"
>         run input simoutput
</programlisting>

<para>
The following is the same as \texttt{sim\_regfile}, but it prints the output
using decimal representations.  The only difference appears in
simoutput, where bindec is used instead of bits for printing the binary
numbers in decimal notation.
</para>

<programlisting>
> sim_regfile_dec2 input =
>   let k =  4  -- there are 2^4 = 16 registers
>       n = 16  -- each register contains 16 bits
>       ld = getbit   input 0
>       d  = getbin k input 1
>       sa = getbin k input 2
>       sb = getbin k input 3
>       x  = getbin n input 4
>       (a,b) = regfile n k ld d sa sb x
>       simoutput :: [Format Bool]
>       simoutput =
>         [string "Input: ",
>          bit ld, string " ", bindec 1 d, string " ",
>          bindec 1 sa, string " ", bindec 1 sb,
>          string " ", bindec 3 x,
>          string "   Output: ",
>          bindec 3 a, string " ", bindec 3 b]
>   in do putStrLn "\nSimulating register file (format output as decimal)"
>         run input simoutput
</programlisting>

<para>
Simulating the Register Transfer Machine
</para>

<para>
On each clock cycle, the register transfer machine can read out two
registers (specified by the sa, sb addresses), calculate a data value,
and load that data value into reg[d] if the load control ld=1.  The
data value can be either the data input x, or the sum produced by the
adder, and the add control signal determines which value is chosen.
If add=1 then the adder's output is selected and otherwise x is used.
Here is some sample input data, along with comments that describe what
is going on.
</para>

<programlisting>
> rtm_input1 :: [[Int]]
> rtm_input1 =
> --      ld add d sa sb   x
> --      ~~~~~~~~~~~~~~~~~~~
>        [[1, 0, 3, 0, 0, 125], -- R3 :=   x   = 125. R0=  0 R0=  0
>         [1, 0, 6, 3, 0,  10], -- R6 :=   x   =  10. R3=125 R0=  0
>         [1, 1, 2, 3, 6,   0], -- R2 := R3+R6 = 135. R3=125 R6= 10
>         [1, 0, 1, 1, 2,  75], -- R1 :=   x   =  75. R1=  0 R2=135
>         [1, 1, 1, 1, 2,   0], -- R1 := R1+R2 = 210. R1= 75 R2=135
>         [0, 0, 0, 1, 2,   0], -- nop                R1=210 R2=135
>         [0, 0, 0, 0, 0,   0]] -- nop                R0=  0 R0=  0
</programlisting>

<para>
The simulation driver will print the input values for each clock
cycle, and then it will show the outputs produced by the register
transfer machine:
  -- reg[sa], the register addressed by sa
  -- reg[sb], the register addressed by sb
  -- the selected data value,
        which will either be reg[sa]+reg[sb] or x,
        and which *might* get loaded into a register
  -- the sum produced by the adder
       (this is the value of  reg[sa] + reg[sb]

You can run it by entering
</para>

<programlisting>
sim_rtm rtm_input1
  
</programlisting>

<para>
Here's the simulation driver, which you can ignore.  It just takes
care of formatting and number conversions.
</para>

<programlisting>
> sim_rtm input =
>   let n = 16  -- each register contains 16 bits
>       k =  4  -- there are 2^4 = 16 registers
>       ld  = getbit   input 0
>       add = getbit   input 1
>       d   = getbin k input 2
>       sa  = getbin k input 3
>       sb  = getbin k input 4
>       x   = getbin n input 5
>       (a,b,y,c,s) = rtm n k ld add d sa sb x
>       simoutput :: [Format Bool]
>       simoutput =
>         [string "Input: ",
>          bit ld, bit add, bindec 2 d, bindec 2 sa, bindec 2 sb,
>          bindec 4 x,
>          string "  Output: ",
>          bindec 4 a, bindec 4 b, bindec 4 y, bindec 4 s]
>   in do putStrLn "\nSimulate register transfer machine"
>         run input simoutput
</programlisting>

<para>
Simulating the Register Transfer Machine
</para>

<programlisting>
> sim_rtm2 =
>   let n = 30
>       k = 5
>       input =
> --      ld add d sa sb   x
> --      ~~~~~~~~~~~~~~~~~~~
>        [[1, 0, 3, 0, 0, 125], -- R3 :=   x   = 125. R0=  0 R0=  0
>         [1, 0, 6, 3, 0,  10], -- R6 :=   x   =  10. R3=125 R0=  0
>         [1, 1, 2, 3, 6,   0], -- R2 := R3+R6 = 135. R3=125 R6= 10
>         [1, 0, 1, 1, 2,  75], -- R1 :=   x   =  75. R1=  0 R2=135
>         [1, 1, 1, 1, 2,   0], -- R1 := R1+R2 = 210. R1= 75 R2=135
>         [0, 0, 0, 1, 2,   0], -- nop                R1=210 R2=135
>         [0, 0, 0, 0, 0,   0]]
>       ld  = getbit   input 0
>       add = getbit   input 1
>       d   = getbin k input 2
>       sa  = getbin k input 3
>       sb  = getbin k input 4
>       x   = getbin n input 5
>       (a,b,y,c,s) = rtm n k ld add d sa sb x
>       simoutput :: [Format Bool]
>       simoutput =
>         [string "Input: ",
>          bit ld, bit add, bindec 2 d, bindec 2 sa, bindec 2 sb,
>          bindec 4 x,
>          string "  Output: ",
>          bindec 4 a, bindec 4 b, bindec 4 y, bindec 4 s]
>   in do putStrLn "\nSimulate register transfer machine"
>         run input simoutput

</programlisting>

<para>
Simulating the Multiplier
</para>

<programlisting>
> sim_mult =
>   let k = 8
>       input =
> --     start  x    y
> --     ~~~~~~~~~~~~~~
>        [[1,  50,  75],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [1, 100, 100],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [1, 100, 100],
>         [0,   0,   0],
>         [0,   0,   0],
>         [1,   2,   3],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0],
>         [0,   0,   0]]
>       start = getbit   input 0
>       x     = getbin k input 1
>       y     = getbin k input 2
>       (rdy,prod,rx,ry,s) = mult k start x y
>       spec :: [Format Bool]
>       spec =
>         [string "Input: ",
>          bit start, bindec 4 x, bindec 4 y,
>          string "  Output: ",
>          bit rdy, bindec 6 prod, bindec 4 rx, bindec 6 ry,
>          bindec 6 s]
>     in do putStrLn "\nSimulate sequential multiplier"
>           run input spec

</programlisting>

<para>
Running the simulations as batch job
</para>

<para>
This is a single operation that runs the various examples above as one
large batch.  You can run it by just launching Hydra, loading this
file, and entering "main" at the prompt.
</para>

<programlisting>
> main =
>   do putStrLn "Hydra: running Tutorial1 batch"
>      sim_adder rippleAdd 16 add_input1
>      sim_sr4 sr4_testdata_1
>      sim_regfile
>      sim_regfile_dec
>      sim_rtm2
>      sim_mult
>      putStrLn "Examples1 finished"
</programlisting>


<para>
Simulating the Register Transfer Machine
</para>

<para>
On each clock cycle, the register transfer machine can read out two
registers (specified by the sa, sb addresses), calculate a data value,
and load that data value into reg[d] if the load control ld=1.  The
data value can be either the data input x, or the sum produced by the
adder, and the add control signal determines which value is chosen.
If add=1 then the adder's output is selected and otherwise x is used.
Here is some sample input data, along with comments that describe what
is going on.
</para>

<programlisting>
> rtm_input1 :: [[Int]]
> rtm_input1 =
> --      ld add d sa sb   x
> --      ~~~~~~~~~~~~~~~~~~~
>        [[1, 0, 3, 0, 0, 125], -- R3 :=   x   = 125. R0=  0 R0=  0
>         [1, 0, 6, 3, 0,  10], -- R6 :=   x   =  10. R3=125 R0=  0
>         [1, 1, 2, 3, 6,   0], -- R2 := R3+R6 = 135. R3=125 R6= 10
>         [1, 0, 1, 1, 2,  75], -- R1 :=   x   =  75. R1=  0 R2=135
>         [1, 1, 1, 1, 2,   0], -- R1 := R1+R2 = 210. R1= 75 R2=135
>         [0, 0, 0, 1, 2,   0], -- nop                R1=210 R2=135
>         [0, 0, 0, 0, 0,   0]] -- nop                R0=  0 R0=  0
</programlisting>

<para>
The simulation driver will print the input values for each clock
cycle, and then it will show the outputs produced by the register
transfer machine:
  -- reg[sa], the register addressed by sa
  -- reg[sb], the register addressed by sb
  -- the selected data value,
        which will either be reg[sa]+reg[sb] or x,
        and which *might* get loaded into a register
  -- the sum produced by the adder
       (this is the value of  reg[sa] + reg[sb]

You can run it by entering
</para>

<programlisting>
sim_rtm rtm_input1
</programlisting>

<para>
Here's the simulation driver, which you can ignore.  It just takes
care of formatting and number conversions.
</para>

<programlisting>
> sim_rtm input =
>   let n = 16  -- each register contains 16 bits
>       k =  4  -- there are 2^4 = 16 registers
>       ld  = getbit   input 0
>       add = getbit   input 1
>       d   = getbin k input 2
>       sa  = getbin k input 3
>       sb  = getbin k input 4
>       x   = getbin n input 5
>       (a,b,y,c,s) = rtm n k ld add d sa sb x
>       simoutput :: [Format Bool]
>       simoutput =
>         [string "Input: ",
>          bit ld, bit add, bindec 2 d, bindec 2 sa, bindec 2 sb,
>          bindec 4 x,
>          string "  Output: ",
>          bindec 4 a, bindec 4 b, bindec 4 y, bindec 4 s]
>   in do putStrLn "\nSimulate register transfer machine"
>         run input simoutput

</programlisting>

<para>
Simulating the Register Transfer Machine
</para>

<programlisting>
> sim_rtm2 =
>   let n = 30
>       k = 5
>       input =
> --      ld add d sa sb   x
> --      ~~~~~~~~~~~~~~~~~~~
>        [[1, 0, 3, 0, 0, 125], -- R3 :=   x   = 125. R0=  0 R0=  0
>         [1, 0, 6, 3, 0,  10], -- R6 :=   x   =  10. R3=125 R0=  0
>         [1, 1, 2, 3, 6,   0], -- R2 := R3+R6 = 135. R3=125 R6= 10
>         [1, 0, 1, 1, 2,  75], -- R1 :=   x   =  75. R1=  0 R2=135
>         [1, 1, 1, 1, 2,   0], -- R1 := R1+R2 = 210. R1= 75 R2=135
>         [0, 0, 0, 1, 2,   0], -- nop                R1=210 R2=135
>         [0, 0, 0, 0, 0,   0]]
>       ld  = getbit   input 0
>       add = getbit   input 1
>       d   = getbin k input 2
>       sa  = getbin k input 3
>       sb  = getbin k input 4
>       x   = getbin n input 5
>       (a,b,y,c,s) = rtm n k ld add d sa sb x
>       simoutput :: [Format Bool]
>       simoutput =
>         [string "Input: ",
>          bit ld, bit add, bindec 2 d, bindec 2 sa, bindec 2 sb,
>          bindec 4 x,
>          string "  Output: ",
>          bindec 4 a, bindec 4 b, bindec 4 y, bindec 4 s]
>   in do putStrLn "\nSimulate register transfer machine"
>         run input simoutput
</programlisting>

<para>
 A Simple CPU 
</para>

<para>
fragments
</para>


<para>
The truth table functions used so far default labels for the columns,
which can sometimes make the tables confusing.  There are alternative
versions of the functions that let you specify strings for the column
headings.  These functions have an underscore at the ends of their
names, and they take the appropriate number of String arguments.
</para>

<programlisting>
truthTable21_ "input1" "input2" "output" xor2
</programlisting>

<para>
4. Simulate a circuit in your working directory
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To test the circuit definition in your working directory, do the
following:

1. Launch the system by entering the shell command
      hydra

2. Load your module TestCirc, and a Hydra module named BoolModel, by
   entering after the prompt
      :load TestCirc BoolModel

3. Place these modules in scope by entering
      :module + MyCircuit BoolModel

4. Try a test simulation by entering
      truthTable31 my_circ

This should produce output similar to the following:

...........................................................................
[jtod@localhost ~/testinghydra]$ hydra
   ___         ___ _
  / _ \ /\  /\/ __(_)
 / /_\// /_/ / /  | |      GHC Interactive, version 6.2.1, for Haskell 98.
/ /_\\/ __  / /___| |      http://www.haskell.org/ghc/
\____/\/ /_/\____/|_|      Type :? for help.
 
Loading package base ... linking ... done.
Loading package haskell98 ... linking ... done.
Loading package haskell-src ... linking ... done.
Prelude> :load TestCirc BoolModel
Compiling Signal  ...

{... more messages appear ...}

*BoolModel> :module + MyCircuit BoolModel
*BoolModel MyCircuit> truthTable31 my_circ
    0 0 0 | 0
    0 0 1 | 1
    0 1 0 | 0
    0 1 1 | 1
    1 0 0 | 0
    1 0 1 | 1
    1 1 0 | 1
    1 1 1 | 1
*BoolModel MyCircuit>
...........................................................................
</para>


</sect1>


</chapter>

<chapter><title>Tu5pat.hs: Design patterns</title>

<para>
foo
</para>

<sect1><title>Design Patterns</title>

<sect2><title>Mapping</title>

<para>
Often we need to process a word by running each bit through a circuit.
For example, this circuit inverts each bit in a 4-bit word:
</para>

<para>
  <inlinemediaobject>
    <imageobject>
      <imagedata fileref="figures/xfig/map4inv.png" format="PNG" />
    </imageobject>
    <imageobject>
	<imagedata fileref="figures/xfig/map4inv.eps" format="EPS" />
    </imageobject>
    <textobject>
	<phrase>[y0,y1,y2,y3] = map f [x0,x1,x2,x3]</phrase>
    </textobject>
  </inlinemediaobject>
</para>

<para>
It is straightforward to design a circuit inv4 to do the job:
</para>

<programlisting>
inv4 [x0,x1,x2,x3] = [y0,y1,y2,y3]
  where y0 = inv x0
        y1 = inv x1
        y2 = inv x2
        y3 = inv x3
</programlisting>

<para>
Now the inv4 circuit can be used to define the output signals y0,
etc.:
</para>

<programlisting>
[y0,y1,y2,y3] = inv4 [x0,x1,x2,x3]
</programlisting>

<para>
The diagram can be simplified by treating the group of inverters as a
black box called inv4, which takes a 4-bit input and produces a 4-bit
output.  This was the diagram shows words rather than bits, making it
considerably more concise.
</para>

<para>
  <inlinemediaobject>
    <imageobject>
      <imagedata fileref="figures/xfig/map4invbox.png" format="PNG" />
    </imageobject>
    <imageobject>
	<imagedata fileref="figures/xfig/map4invbox.eps" format="EPS" />
    </imageobject>
    <textobject>
	<phrase>[y0,y1,y2,y3] = map f [x0,x1,x2,x3]</phrase>
    </textobject>
  </inlinemediaobject>
</para>

<para>
The inv4 circuit works just fine, but there are two disadvantages with
the way we defined it.
</para>

<itemizedlist>
<listitem>
<para>
We might also need an 8-bit version of the circuit, and perhaps yet
more versions at various word sizes.  All of these definitions will be
quite similar to the definition above of inv4, but we'll keep having
to define new ones.
</para>
</listitem>
<listitem>
<para>
Even worse, consider what happens at large word sizes.  If you write a
64-bit version, inv64, there will be 64 equations within the
definition.  This is tedious and unreliable. A typographical error in
any of the equation would be easy to make and hard to spot.
</para>
</listitem>
</itemizedlist>

<para>
When you see the 4-bit version of the circuit, the pattern becomes
obvious, and a human can easily design a version for an arbitrary word
size just by following the pattern.
</para>

<para>
Design patterns allow computers to understand and use regular
circuits, like the examples above.  Hydra provides a design pattern,
called <emphasis>map</emphasis>, for defining circuits that have the
same structure as inv4.  Instead of making an explicit definition of
the inv4 circuit, you can just replace an application of inv4 by the
expression <emphasis>map inv</emphasis>.  Thus an equation

<programlisting>
[y0,y1,y2,y3] = inv4 [x0,x1,x2,x3]
</programlisting>

can be rewritten,  replacing inv4 by map inv, as follows:

<programlisting>
[y0,y1,y2,y3] = map inv [x0,x1,x2,x3]
</programlisting>
</para>

<para>
The previous example shows how you can use map to avoid defining inv4.
If you still would like to have the inv4 circuit, however, you can
define it with the following equation:

<programlisting>
inv4 = map inv
</programlisting>

This equation says that "inv4" and "map inv" are the same, which
justifies the comment above that you can replace inv4 by map inv.
</para>

<para>
In general, the map pattern is used whenever a circuit has the
following structure, where f can denote any circuit that takes an
input and produces an output.
</para>

<para>
  <inlinemediaobject>
    <imageobject>
      <imagedata fileref="figures/xfig/map4.png" format="PNG" />
    </imageobject>
    <imageobject>
	<imagedata fileref="figures/xfig/map4.eps" format="EPS" />
    </imageobject>
    <textobject>
	<phrase>[y0,y1,y2,y3] = map f [x0,x1,x2,x3]</phrase>
    </textobject>
  </inlinemediaobject>
</para>

<para>
To generate the set of f-boxes, and the necessary wiring, you just
write map f.  This gives you a circuit that has an instance of the f
circuit for every element of the input list.
</para>

<para>
  <inlinemediaobject>
    <imageobject>
      <imagedata fileref="figures/xfig/map4box.png" format="PNG" />
    </imageobject>
    <imageobject>
	<imagedata fileref="figures/xfig/map4box.eps" format="EPS" />
    </imageobject>
    <textobject>
	<phrase>[y0,y1,y2,y3] = map f [x0,x1,x2,x3]</phrase>
    </textobject>
  </inlinemediaobject>
</para>

<para>
To invert all the bits of a 4-bit word, we can write:

<programlisting>
[y0,y1,y2,y3] = map inv [x0,x1,x2,x3]
</programlisting>
</para>

<para>
This works for any word size:
<programlisting>
[p,q] = map inv [x,y]
[a,b,c,d,e] = map inv [u,v,w,x,y]
</programlisting>

</para>

<para>
How does map know how many inverters to use?  The answer is that at
compile time, the map pattern inspects the input word and generates
an instance of the inverter for every element of the input word.  Thus
if we write

<programlisting>
[y0,y1,y2] = winv [x0,x1,x2]
</programlisting>

the map pattern sees that the input word contains three elements, so
it generates three inverters, does the necessary wiring, and defines
the three output signals.
</para>

<para>
A general word inverter can be defined using map:

<programlisting>
winv :: Signal a => [a] -> [a]
winv x = map inv x
</programlisting>

This winv is not a specific circuit; it is a
<emphasis>family</emphasis> of circuits, all with the same structure,
corresponding to every word size 0, 1, 2, ...  That is, winv can
invert a word of size n, for any natural number n.
</para>

<para>
Naturally, the map pattern can be used with any building block
circuit; it doesn't need to be an inverter.  We can amplify all the
signals in a word using buffers:
<programlisting>
[a',b',c',d'] = map buf [a,b,c,d]
</programlisting>
</para>




<programlisting>
map :: (a->b) -> [a] -> [b]
</programlisting>


<programlisting>
> map2 :: (a->b->c) -> [a] -> [b] -> [c]
</programlisting>

<para>
Explicitly Sized Map
</para>

<programlisting>
> mapn :: (a->b) -> Int -> [a] -> [b]
</programlisting>

<programlisting>
> reg :: Clocked a => Int -> a -> [a] -> [a]
> reg n ld x = mapn (reg1 ld) n x
</programlisting>

<programlisting>
> mux1w :: Signal a => a -> [a] -> [a] -> [a]
> mux1w c x y = map2 (mux1 c) x y
</programlisting>

</sect2>

<sect2><title>Bit Slice Organization</title>

<programlisting>
> bitslice2 :: [a] -> [a] -> [(a,a)]
> bitslice2 = zip
</programlisting>

<programlisting>
> unbitslice2 :: [(a,b)] -> ([a],[b])
> unbitslice2 [] = ([],[])
> unbitslice2 ((x,y):zs) =
>   let (xs,ys) = unbitslice2 zs
>   in (x:xs, y:ys)
</programlisting>

<programlisting>
> zipn :: Int -> [a] -> [b] -> [(a,b)]
> zipn n x y =
>   [(x!!i,y!!i) | i FROM- [0..n-1]]
</programlisting>

<programlisting>
> unzipn n xs =
>   ([fst (xs!!i) | i FROM- [0..n-1]],
>    [snd (xs!!i) | i FROM- [0..n-1]])
</programlisting>

</sect2>

<sect2><title>Folding</title>

<para>
z= foldl f a [x0, x1, x2, x3]
</para>

<para>
  <inlinemediaobject>
    <imageobject>
      <imagedata fileref="figures/xfig/foldl4.png" format="PNG" />
    </imageobject>
    <imageobject>
	<imagedata fileref="figures/xfig/foldl.eps" format="EPS" />
    </imageobject>
    <textobject>
	<phrase>[y0,y1,y2,y3] = map f [x0,x1,x2,x3]</phrase>
    </textobject>
  </inlinemediaobject>
</para>

<para>
The following figure shows the same circuit a little more abstractly,
treating the internal f boxes and wires as a black box circuit.  The
inputs are the word of x bits and the singleton a, and the output is
the singleton z, and the circuit itself is described as "foldl f".
</para>

<para>
  <inlinemediaobject>
    <imageobject>
      <imagedata fileref="figures/xfig/foldl4box.png" format="PNG" />
    </imageobject>
    <imageobject>
	<imagedata fileref="figures/xfig/foldl4box.eps" format="EPS" />
    </imageobject>
    <textobject>
	<phrase>[y0,y1,y2,y3] = map f [x0,x1,x2,x3]</phrase>
    </textobject>
  </inlinemediaobject>
</para>

<programlisting>
foldr :: (b->a->a) -> a -> [b] -> a
foldr f a [] = a
foldr f a (x:xs) = f x (foldr f a xs)
</programlisting>

<para>
z= foldr f a [x0, x1, x2, x3]
</para>

<para>
  <inlinemediaobject>
    <imageobject>
      <imagedata fileref="figures/xfig/foldr4.png" format="PNG" />
    </imageobject>
    <imageobject>
	<imagedata fileref="figures/xfig/foldr4.eps" format="EPS" />
    </imageobject>
    <textobject>
	<phrase>[y0,y1,y2,y3] = map f [x0,x1,x2,x3]</phrase>
    </textobject>
  </inlinemediaobject>
</para>

<para>
The following figure shows the same circuit a little more abstractly,
treating the internal f boxes and wires as a black box circuit.  The
inputs are the word of x bits and the singleton a, and the output is
the singleton z, and the circuit itself is described as "foldr f".
</para>

<para>
  <inlinemediaobject>
    <imageobject>
      <imagedata fileref="figures/xfig/foldr4box.png" format="PNG" />
    </imageobject>
    <imageobject>
	<imagedata fileref="figures/xfig/foldr4box.eps" format="EPS" />
    </imageobject>
    <textobject>
	<phrase>[y0,y1,y2,y3] = map f [x0,x1,x2,x3]</phrase>
    </textobject>
  </inlinemediaobject>
</para>

<para>
Binary comparitor
</para>

<programlisting>
> cmp1 :: Signal a => (a,a,a) -> (a,a) -> (a,a,a)
> cmp1 (lt,eq,gt) (x,y) =
>   (or2 lt (and3 eq (inv x) y),
>    and2 eq (inv (xor2 x y)),
>    or2 gt (and3 eq x (inv y))
>   )
</programlisting>

<programlisting>
> rippleCmp :: Signal a => [(a,a)] -> (a,a,a)
> rippleCmp = foldl cmp1 (zero,one,zero)
</programlisting>

</sect2>

<sect2><title>Scanning</title>

<programlisting>
> wscanr :: (b->a->a) -> a -> [b] -> [a]
> wscanr f a xs =
>   [foldr f a (drop (i+1) xs) | i FROM- [0 .. length xs -1]]
</programlisting>

<programlisting>
> ascanr ::  (b->a->a) -> a -> [b] -> (a,[a])
> ascanr f a [] = (a,[])
> ascanr f a (x:xs) =
>   let (a',xs') = ascanr f a xs
>       a'' = f x a'
>   in (a'', a':xs')
</programlisting>

<para>
Inclusive Scans

Mapping Scans


Bidirectional Scans

Shift register
</para>

<programlisting>
> sr :: (Signal a, Clocked a)
>   => (a,a) -> a -> a -> [a] -> (a,a,[a])
> sr op l r xs = mscan (srb' op) l r xs
>   where srb' a b c d = fanout3 (srb a b c d)
</programlisting>

</sect2>

<sect2><title>Tree Patterns</title>

<para>
Tree Expansion: Downsweep


Tree Reduction: Upsweep

And/Or over a word
</para>

<para>
Determine whether there exists a 1 in a word, or whether all the
bits are 0.  A tree fold can do this in log time, but for
simplicity this is just a linear time fold.
</para>

<programlisting>
> any1, all0 :: Signal a => [a] -> a
> any1 = foldl or2 zero
> all0 = foldl and2 one
</programlisting>

<programlisting>
> orw :: Signal a => [a] -> a
> orw = foldl or2 zero
</programlisting>

<para>

Bidirectional Tree Sweep
</para>

</sect2>

<sect2><title>Explicit Recursion</title>

<para>
See Section \ref{sec:register-file}, which uses a recursive pattern to
define the register file circuit.
</para>

</sect2>
</sect1>



</chapter>

<chapter><title>Tu6lib.hs: Modules and libraries</title>

<sect1><title>Organizing large specifications</title>
<para>
A Hydra file, like this one, begins with a statement that gives a name
to the module; this one is named Tutorial1.
</para>

<programlisting>
> module Tutorial1 where
</programlisting>

<para>
The file name should be Tutorial1.lhs, where Tutorial1 is the name of
the module.
</para>

<para>
After the "module" statement there should be one or more "import"
statements saying which other library modules need to be loaded.  The
first line, "import Hydra", loads all the Hydra software tools, and
the second one, "import CircuitLib", loads a collection of standard
basic circuits.  There are many other combinations of modules that can
be imported, depending on what you want to do; these will be explored
in subsequent tutorials.
</para>

<programlisting>
> import Hydra        -- The basic system
> import CircuitLib   -- Library of basic circuits

</programlisting>

<para>
Commands begin with :, and :load says to load a file.  (You can also
write it as :l, as in ":l Tutorial1").  The system will print a number
of messages as it loads the libraries, and then it will give another
prompt, which should look like this:
</para>

<programlisting>
Tutorial1> 
</programlisting>




<para>
Structure of a specification file
</para>

<para>
If a circuits has several inputs, just separate them by spaces.
For example, the two-input logical and gate can be simulated as follows.
</para>

<para>
A circuit with several inputs, like the two-input and gate
<emphasis>and2</emphasis>, and the three-input exclusive or gate
<emphasis>xor3</emphasis>, is handled the same way.  Just write the
inputs after the circuit, separated by spaces; don't put in any
extraneous punctuation.
</para
>
<para>
Using existing circuits
</para>

<para>
To use a black box circuit specification, you need to (1) load the
file, and the simulation model you want to use; and (2) add these
definitions to the set of definitions that are in scope.  For example,
the file <emphasis>Example1.hs</emphasis>, located in the
<emphasis>doc/examples</emphasis> directory, contains some simple
circuit definitions which we would like to simulate using the Boolean
model.
</para>

<para>
To run the examples, we need to compile and load both the circuit
definitions (Example1) and the Boolean simulation model (BoolModel).
This is done using the <emphasis>:load</emphasis> command.
Furthermore, the definitions in both of these files need to be brought
into scope so they can be used; that is done with the
<emphasis>:module</emphasis> command.  The complete commands to enter
are as follows:
</para>

<programlisting>:load Example1 BoolModel
:module + Example1 BoolModel
</programlisting>

<para>
Now the prompt will change to <emphasis>*BoolModel
Example1></emphasis>, which shows exactly which definitions will
actually be used.  Now the truth table for
<emphasis>circuit1</emphasis> can be generated by entering
<emphasis>truthTable31 circuit1</emphasis>.
</para>

<programlisting>
Prelude> :load Example1 BoolModel
Compiling ...
Ok, modules loaded: ...
*BoolModel> :module + Example1 BoolModel
*BoolModel Example1> truthTable31 circuit1
    0 0 0 | 1
    0 0 1 | 0
    0 1 0 | 0
    0 1 1 | 0
    1 0 0 | 1
    1 0 1 | 0
    1 1 0 | 1
    1 1 1 | 1
*BoolModel Example1>
</programlisting>

<para>
A variety of useful circuits are defined in the Hydra file
directories.  It is worth becoming familiar with them, both because it
can save time to reuse them, and also because they provide plenty of
examples of circuit designs.
</para>


<sect2><title>Files</title>

<para>
A Hydra file, like this one, begins with a statement that gives a name
to the module (this module is named Tutorial1).
</para>

<programlisting>
module LogicGates where
</programlisting>

<para>
After the "module" statement there should be one or more "import"
statements saying which other library modules need to be loaded.  The
first line, "import Hydra", loads all the Hydra software tools, and
the second one, "import StdCircuit", loads the standard library of
circuits provided by Hydra.  There are many other combinations of
modules that can be imported, depending on what you want to do, but
usually it's most convenient to import just these two.
</para>

<programlisting>
import Hydra
import CircuitLib
</programlisting>

<para>
Here's a definition of a new circuit, named `circ1'.
</para>

<programlisting>
circ1 :: Signal a => a -> a -> a
circ1 x y = and2 (inv x) y
</programlisting>

<para>
It can be tested by checking its truth table:
</para>

<programlisting>
truthTable21 circ1
</programlisting>

<para>
Commands begin with :, and :l says to load a file (you can also write
it as :load).  The Haskell interpreter will load various Hydra files,
and then give another prompt, which should look like
</para>

<programlisting>
Tutorial1> 
</programlisting>

<para>
This means you can do simulations using all the definitions contained
in this file, as well as the standard Hydra definitions (those are
available because of the import statements near the beginning of this
file).
</para>
</sect2>

<sect2><title>Importing modules</title>

<para>
foo
</para>
</sect2>

<sect2><title>The Hydra circuit library</title>

<para>
foo
</para>
</sect2>

</sect1>

<sect1><title>Basic combinational circuits</title>

<sect2><title>Constant signals</title>

<para>
There are two constant signal values, which are written as
<emphasis>zero</emphasis> and <emphasis>one</emphasis>.
</para>

<para>
For example, if you want to make the first input to an and3 gate a
signal named x, the second input a constant one, and the third input a
signal named y, you can write <programlisting>and3 x one
y</programlisting>.
</para>

<para>
Do <emphasis>not</emphasis> write 0 or 1 to denote a constant signal.
These are numbers, and numbers are used in Hydra to describe sizes of
circuits (for example, how many bits are in a word).  Numbers are
never used as signal values in Hydra.
</para>

<para>
It is possible to write False or True to denote constant signals, but
normally this is not a good idea.  The reason is that False and True
are usable only when the Bool model for signals is being used, and
that means that you are limited to performing simple untimed boolean
simulations.  Normally you will want to use a circuit specification
for several different purposes, and that will require using
alternative signal models that are incompatible with False and True.
In contrast, the constant signals, zero and one, are valid for all
signal models.
</para>

<para>
To summarize, always write constant signals as either
<emphasis>zero</emphasis> or <emphasis>one</emphasis>.
</para>

</sect2>

<sect2><title>Logic gates</title>

<para>
The commonly used logic gates are described in this section.  There
are two logic gates that take one input: the inverter and the buffer.
</para>

<para>
The most commonly used logic gates are shown in Tables
\ref{tab:1-input-gates} and \ref{tab:n-input-gates}.
</para>

<programlisting>
\begin{table}[htbp]
  \begin{center}
    \caption{Logic gates with one input}
    \label{tab:1-input-gates}
\begin{tabular}[c]{ll}
\textit{buf}    buffer: output = input \\
\textit{inv}    inverter: logical negation \\
\end{tabular}
  \end{center}
\end{table}

\begin{table}[htbp]
\begin{center}
\caption{Families of Logic Gates}
\label{tab:n-input-gates}
\begin{tabular}[c]{llll}
\textit{and2}   and3   and4   logical and \\
or2    or3    or4    inclusive or \\
xor2   xor3   xor4   exclusive or \\
nand2  nand3  nand4  not-and \\
nor2   nor3   nor4   not-or
\end{tabular}
\end{center}
\end{table}
</programlisting>

<para>
The simplest way to simulate a logic gate is to give it input signals
of type Bool, which has the values True and False.  Try the following
examples by entering each expression after the prompt and pressing
enter:
</para>

<programlisting>
  inv True
  inv False
  and2 False True
  and2 True True
</programlisting>

<para>
A convenient way to run such examples is to select (Copy) the text in
this file, and then paste it into the window where you're executing
Hydra.
</para>
</sect2>

<sect2><title>more</title>

<para>
The inverter logic gate, called <emphasis>inv</emphasis>, outputs the
logical negation of its input.
</para>

<programlisting>
*Tu01int> truthTable11 inv
    0 | 1
    1 | 0
*Tu01int>
</programlisting>

<para>
Recall that to provide inputs to a circuit, you apply it to the corresponding
values.  This is expressed by writing the name of the circuit,
followed by the input values, separated by spaces.  For example, to
say that in inverter is given the input of False, you write
<emphasis>inv False</emphasis>.  The result of this expression is the
output value produced by the circuit, and you can simulate the circuit
by entering the expression interactively.  For example, enter the
expression <emphasis>inv False</emphasis> and the result is:
</para>

<programlisting>
*Tu01int> inv True
False
*Tu01int> inv False
True
</programlisting>

<para>
The buffer, called <emphasis>buf</emphasis>, outputs the same value
that it receives on its input; it performs the identity function.
</para>

<programlisting>
*Tu01int> truthTable11 buf
    0 | 0
    1 | 1
*Tu01int>
</programlisting>

<para>
There are several logical and-gates in the standard Hydra libraries,
and their names reflect the number of inputs.  Thus
<emphasis>and2</emphasis> is the 2-input and gate,
<emphasis>and3</emphasis> takes three inputs, and
<emphasis>and4</emphasis> takes four inputs.  The truth tables for the
family of and gates are generated as follows:
</para>


<programlisting>
*Tu01int> truthTable21 and2
    0 0 | 0
    0 1 | 0
    1 0 | 0
    1 1 | 1
*Tu01int> truthTable31 and3
    0 0 0 | 0
    0 0 1 | 0
    0 1 0 | 0
    0 1 1 | 0
    1 0 0 | 0
    1 0 1 | 0
    1 1 0 | 0
    1 1 1 | 1
*Tu01int> truthTable41 and4
    0 0 0 0 | 0
    0 0 0 1 | 0
    0 0 1 0 | 0
    0 0 1 1 | 0
    0 1 0 0 | 0
    0 1 0 1 | 0
    0 1 1 0 | 0
    0 1 1 1 | 0
    1 0 0 0 | 0
    1 0 0 1 | 0
    1 0 1 0 | 0
    1 0 1 1 | 0
    1 1 0 0 | 0
    1 1 0 1 | 0
    1 1 1 0 | 0
    1 1 1 1 | 1
*Tu01int>
</programlisting>

<para>
There is, of course, a close mathematical relationship among the
various and gates, but it is important to recognise that they are
distinct hardware devices, and they are not interchangeable. Informal
terminology is commonly used for describing digital circuits.  For
example, many authors refer to an <emphasis>and gate</emphasis> as the
logic gate that outputs True if all its inputs are True, and they use
and gates with two inputs, three inputs, or however many are required,
all under the same name "and gate".  Nonetheless, the 2-input gate
<emphasis>and2</emphasis> and the 3-input gate
<emphasis>and2</emphasis> are different electronic components: they
have different interfaces (different numbers of ports that must be
connected to wires), and they have different internal structures.
Informal terminology may be adequate for describing circuits to
humans, who can be expected to figure out the ambiguities.  Precise
notation is better when writing formal circuit descriptions that will
be used by automated software tools, such as simulators.  Therefore
Hydra uses a unique name for every logic gate: thus the and gates with
two or three inputs are called <emphasis>and2</emphasis> and
<emphasis>and3</emphasis> respectively.
</para>

<para>
There is a family of logical inclusive or gates, called
<emphasis>or2</emphasis>, <emphasis>or2</emphasis>, and
<emphasis>or4</emphasis>, and a family of logical exclusive or gates,
called <emphasis>xor2</emphasis>, <emphasis>xor3</emphasis>, and
<emphasis>xor4</emphasis>.  Here are some examples:</para>

<programlisting>
*Tu01int> truthTable21 or2
    0 0 | 0
    0 1 | 1
    1 0 | 1
    1 1 | 1
*Tu01int> truthTable21 xor2
    0 0 | 0
    0 1 | 1
    1 0 | 1
    1 1 | 0
*Tu01int> truthTable31 xor3
    0 0 0 | 0
    0 0 1 | 1
    0 1 0 | 1
    0 1 1 | 0
    1 0 0 | 1
    1 0 1 | 0
    1 1 0 | 0
    1 1 1 | 1
*Tu01int>
</programlisting>

<para>
The standard logic components supported by Hydra are listed below.
The language is case-sensitive; that is, upper and lower case letters
are considered to be different.  Therefore you must use these names
exactly as written: write <emphasis>and2</emphasis>, never
<emphasis>And2</emphasis>.
</para>

<para>
There are two constant signals, called <emphasis>zero</emphasis> and
<emphasis>one</emphasis>.  When you're using the Boolean model,
<emphasis>False</emphasis> can be used in place of
<emphasis>zero</emphasis> and <emphasis>True</emphasis> can be used in
place of <emphasis>one</emphasis>.  The reason for making these
distictions will be discussed later.
</para>





<para>
Hydra provides many logic gates, which are listed below.
</para>


<itemizedlist>

  <listitem>
    <para>1-input logic gates</para>
    <itemizedlist>
      <listitem>
	<para>buf :: Signal a => a -> a.  A buffer amplifies the input
	signal but doesn't change it; the output has the same value as
	the input.
	</para>
      </listitem>
      <listitem>
	<para>inv :: Signal a => a -> a.  An inverter outputs the
	logical negation of its input.
	</para>
      </listitem>
    </itemizedlist>
  </listitem>
  <listitem>
    <para>Logical and gates
    </para>
    <itemizedlist>
      <listitem><para>and2 -- a 2-input and gate:</para></listitem>
      <listitem><para>and3 -- a 3-input and gate:</para></listitem>
      <listitem><para>and4 -- 4-input and gate:</para></listitem>
    </itemizedlist>
  </listitem>
  <listitem><para>Logical not-and gates</para>
  <itemizedlist>
    <listitem><para>nand2 -- a 2-input not-and gate:</para></listitem>
    <listitem><para>nand3 -- a 3-input not-and gate:</para></listitem>
    <listitem><para>nand4 -- 4-input not-and gate:</para></listitem>
  </itemizedlist>
  </listitem>
  <listitem><para>Logical inclusive or gates</para>
  <itemizedlist>
    <listitem><para>or2 -- a 2-input or gate:</para></listitem>
    <listitem><para>or3 -- a 3-input or gate:</para></listitem>
    <listitem><para>or4 -- 4-input or gate:</para></listitem>
  </itemizedlist>
  </listitem>
  <listitem><para>Logical inclusive not-or gates</para>
  <itemizedlist>
    <listitem><para>nor2 -- a 2-input not-or gate:</para></listitem>
    <listitem><para>nor3 -- a 3-input not-or gate:</para></listitem>
    <listitem><para>nor4 -- 4-input not-or gate:</para></listitem>
  </itemizedlist>
  </listitem>
  <listitem><para>Logical exclusive or gates</para>
  <itemizedlist>
    <listitem><para>xor2 -- a 2-input exclusive or gate:</para></listitem>
    <listitem><para>xor3 -- a 3-input exclusive or gate:</para></listitem>
    <listitem><para>xor4 -- 4-input exclusive or gate:</para></listitem>
  </itemizedlist>
  </listitem>
</itemizedlist>

<para>
It is important to note that gates with similar functions but
different numbers of inputs (e.g. or2, or3, or4) are considered to be
different components.  In physical hardware, they are different
circuits, with different numbers of wires connected to them.  You
can't just interchange one circuit with another that has a different
number of physical connections.  This is reflected in Hydra by giving
different names to distinct components.  In common usage, the or2, or3
and or4 components are often just called "or gates", but you have to
use the right one in a circuit specification.
</para>

</sect2>

<sect2><title>Fanout</title>

<para>
While designing combinational circuits, it is often necessary to make
one or more duplicate copies of a signal $x$.  This is called
\textit{fanout}, because a wire splits and ``fans out'' to several
destinations.
</para>

<para>
Fanout can be specified implicitly simply by using a signal in several
places.  For example, in the following definition the signal $x$ is
defined in one place, but used in several places, so the wire carrying
$x$ must fan out to each of the points where it is used.
</para>

<programlisting>
circ a = ...
  where x = ...
        y = ... x ...
        z = ... x ...
</programlisting>

<para>
The fanout is implicit because the specification does not directly
mention it.
</para>

<para>
Sometimes it is better to specify fanout explicitly.  There are many
reasons for this.  Excessive fanout may cause delays or capacitance
problems in the circuit.  Since these issues belong at the electronic
level of abstraction, they are not apparent when simulating a circuit
at the logical level.  Such problems can be controlled by specifying
fanout explicitly.  Furthermore, fanouts must sometimes be requested
explicitly in order to use a design pattern.
</para>

<para>
The following circuits take a signal $x$ and fan it out into a tuple
containing several copies of $x$.  These circuits are pure wiring
patterns; they contain no logic gates.
</para>

<programlisting>
> fanout2 :: a -> (a,a)
> fanout2 x = (x,x)

> fanout3 :: a -> (a,a,a)
> fanout3 x = (x,x,x)

> fanout4 :: a -> (a,a,a,a)
> fanout4 x = (x,x,x,x)
</programlisting>

<para>
When it is important to limit the degree of fanout, in order to avoid
problems at the electronic level, it is better to use buffered
fanouts.  These circuits are similar to the wiring patterns above, but
they use a buffer logic gate to bring the signal $x$ up to full
strength.
</para>

<programlisting>
> fanoutbuf2 :: Signal a => a -> (a,a)
> fanoutbuf2 x = (y,y)
>   where y = buf x

> fanoutbuf3 :: Signal a => a -> (a,a,a)
> fanoutbuf2 x = (y,y,y)
>   where y = buf x

> fanoutbuf4 :: Signal a => a -> (a,a,a,a)
> fanoutbuf2 x = (y,y,y,y)
>   where y = buf x
</programlisting>

<para>
The next problem is to generalise fanout, so that a bit $x$ is
duplicated in order to form a $k$-bit word, for arbitrary $k$.  This
is performed by the \textit{fanout} circuit, which is a pure wiring
pattern, and \textit{fanoutbuf}, which uses buffered fanouts.
Normally it is better to use \textit{fanoutbuf}.
</para>

<programlisting>
> fanout, fanoutbuf :: Signal a => Int -> a -> [a]
</programlisting>

<para>
For example, $\mathit{fanoutbuf}\ 6\ x$ produces a word whose value is
$[x,x,x,x]$, but it introduces buffers as needed to prevent any logic
gate from having to drive too many wires.
</para>

<para>
In RISC processors, the Boolean result $x$ of a comparison is usually
represented as an integer, where False is represented by 0 and True is
represented by 1.  In both cases, these will be $k$-bit binary
integers, so the rightmost bit should be the Boolean $x$, while all
the leading bits should be 0.  This task is performed by the
\textit{boolword} circuit, which uses a buffered fanout to produce the
leading zeros.
</para>

<programlisting>
> boolword :: Signal a => Int -> a -> [a]
> boolword n x = fanoutbuf (n-1) zero ++ [x]
</programlisting>

<para>
\section{Fanout}


\begin{itemize}
\item $\mathit{fanout2} :: a \rightarrow (a,a)$ \\
  $(x,y) = \mathit{fanout2}\ a$ \\
  Unbuffered 2-way fanout.  The wire carrying $a$ is split, putting
  the value onto both $x$ and $y$.
\item $\mathit{fanout3} :: a \rightarrow (a,a,a)$
\item $\mathit{fanout4} :: a \rightarrow (a,a,a,a)$
\item $\mathit{fanout} :: \mathit{Signal} a \Rightarrow Int
  \rightarrow a \rightarrow [a]$
\item $\mathit{fanoutbuf} :: \mathit{Signal} a \Rightarrow Int
  \rightarrow a \rightarrow [a]$ \\
  Duplicating a bit to form a word: fanoutbuf takes a wordsize n and a
  signal x, and produces a word of size n each of whose bits takes the
  value of x.
\item $\mathit{fanoutbuf2} :: \mathit{Signal} a \Rightarrow a
  \rightarrow (a,a)$
\item $\mathit{fanoutbuf3} :: \mathit{Signal} a \Rightarrow a
  \rightarrow (a,a,a)$
\item $\mathit{fanoutbuf4} :: Signal a \Rightarrow a \rightarrow
  (a,a,a,a)$
\end{itemize}

\section{Bit Slice Organization}
\label{sec:app-bit-slice}
\begin{itemize}
\item $bitslice2 :: [a] \rightarrow [a] \rightarrow [(a,a)]$
\item $zipn :: Int \rightarrow [a] \rightarrow [b] \rightarrow [(a,b)]$
\item $unzipn :: Int \rightarrow [(a,b)] \rightarrow ([a],[b])$
\item $unbitslice2 :: [(a,b)] \rightarrow ([a],[b])$
\end{itemize}
</para>

</sect2>

<sect2><title>Logic on words</title>

<para>
The following functions take a singleton (bit) signal, and replicate
it in order to form a pair, triple, or quadruple of signals.  Each of
the ouput signals is simply connected to the input.
</para>

<programlisting>
fanout2 :: a -> (a,a)
fanout3 :: a -> (a,a,a)
fanout4 :: a -> (a,a,a,a)
</programlisting>

<programlisting>
fanout :: Signal a => Int -> a -> [a]
</programlisting>


<para>
The following functions insert buffers to drive the output signals.
</para>

<programlisting>
fanoutbuf2 :: Signal a => a -> (a,a)
fanoutbuf3 :: Signal a => a -> (a,a,a)
fanoutbuf4 :: Signal a => a -> (a,a,a,a)
</programlisting>

<programlisting>
fanoutbuf :: Signal a => Int -> a -> [a]
</programlisting>

<programlisting>
winv :: Signal a => [a] -> [a]

any0, any1, all0, all1 :: Signal a => [a] -> a

bitslice2 :: [a] -> [a] -> [(a,a)]
unbitslice2 :: [(a,b)] -> ([a],[b])
zipn :: Int -> [a] -> [b] -> [(a,b)]
unzipn n xs =


boolword :: Signal a => Int -> a -> [a]
</programlisting>

</sect2>

<sect2><title>Multiplexors and demultiplexors</title>

<para>

</para>


<programlisting>
mux1 :: Signal a => a -> a -> a -> a
</programlisting>

<programlisting>
mux2 :: Signal a => (a,a) -> a -> a -> a -> a -> a
mux3 :: Signal a => (a,a,a) -> a -> a -> a -> a -> a-> a -> a -> a -> a
</programlisting>

<programlisting>
mux22 :: Signal a => (a,a) -> (a,a) -> (a,a) -> (a,a) -> (a,a) -> (a,a)
</programlisting>

<programlisting>
mux1w :: Signal a => a -> [a] -> [a] -> [a]
mux2w :: Signal a => (a) -> [a] -> [a] -> [a] -> [a] -> [a]
</programlisting>

<programlisting>
demux1 :: Signal a => a -> a -> (a,a)
demux2 :: Signal a => (a,a) -> a -> (a,a,a,a)

demux1w :: Signal a => [a] -> a -> [a]
demux2w :: Signal a => [a] -> a -> [a]
demux3w :: Signal a => [a] -> a -> [a]
demux4w :: Signal a => [a] -> a -> [a]
</programlisting>

<para>

\begin{itemize}
\item \textbf{mux1} \\
  Type: $\mathit{mux1} :: \mathit{Signal}\ a \Rightarrow a
  \rightarrow a \rightarrow a \rightarrow a$ \\
  Usage: $x = \mathit{mux1}\ \mathit{ctl}\ a\ b$ \\
  This is the basic combinational \textit{if--then--else} circuit.  If
  the control input $\mathit{ctl}$ is zero the the output is $a$;
  otherwise it is $b$.
  \begin{center}
    \begin{tabular}[c]{c|c}
      $\mathit{ctl}$  $x$ \\
      \hline
      $0$  $a$ \\
      $1$  $b$
    \end{tabular}
  \end{center}

\item \textbf{mux2} \\
  Type: $\mathit{mux2} :: \mathit{Signal}\ a \Rightarrow (a,a)
  \rightarrow a \rightarrow a \rightarrow a \rightarrow a \rightarrow a$ \\
  Usage: $ x = \mathit{mux2}\ (\mathit{ctl}_0,\mathit{ctl}_1)\ a\ b\ c\ d$ \\
  Uses the two bit control input $(\mathit{ctl_0},\mathit{ctl}_0)$ to
  select one of the four data inputs, as follows:
  \begin{center}
    \begin{tabular}[c]{c|c}
      $(\mathit{ctl}_0,\mathit{ctl}_1)$  $x$ \\
      \hline
      $(0,0)$  $a$ \\
      $(0,1)$  $b$ \\
      $(1,0)$  $c$ \\
      $(1,1)$  $d$
    \end{tabular}
  \end{center}
\item \textbf{mux22} \\
  Type: $\mathit{mux22} :: \mathit{Signal}\ a \Rightarrow (a,a)
  \rightarrow (a,a) \rightarrow (a,a) \rightarrow (a,a) \rightarrow
  (a,a) \rightarrow (a,a)$ \\
  Usage: $(x_0,x_1) = \mathit{mux22}\ (\mathit{ctl_0},\mathit{ctl}_0)
  \ (a_0,a_1)\ (b_0,b_1)\ (c_0,c_1)\ (d_0,d_1)$ \\
  Similar to $\mathit{mux2}$, except the data inputs are bit pairs
  rather than singleton bits.  The two bit control input
  $(\mathit{ctl_0},\mathit{ctl}_1)$ is used to select one of the four
  data inputs, as follows:
  \begin{center}
    \begin{tabular}[c]{c|c}
      $(\mathit{ctl}_0,\mathit{ctl}_1)$  $(x_0,x_1)$ \\
      \hline
      $(0,0)$  $(a_0,a_1)$ \\
      $(0,1)$  $(b_0,b_1)$ \\
      $(1,0)$  $(c_0,c_1)$ \\
      $(1,1)$  $(d_0,d_1)$
    \end{tabular}
  \end{center}
\item \textbf{muxw1} \\
  Type: $\mathit{muxw1} :: \mathit{Signal} a \Rightarrow [a]
  \rightarrow [a] \rightarrow a$ \\
  Usage: $x = \mathit{muxw1}\ \mathit{cs}\ \mathit{xs}$ \\
  This is a large generic multiplexor that uses a $k$-bit control
  input word $\mathit{ctl}$ to select the $i$th bit of the $2_k$-bit
  data input word $\mathit{xs}$, where $i$ is the binary value of
  $\mathit{ctl}$.
\item \textbf{mux1w} \\
  Type: $\mathit{mux1w} :: \mathit{Signal} a \Rightarrow a \rightarrow
  [a] \rightarrow [a] \rightarrow [a]$ \\
  Usage: $xs = mux1w ctl ys zs $\\
  A single control bit is used to select between two input words.  If
  $\mathit{ctl}$ is zero then the output word $\mathit{xs}$ has the
  same value as the 0th data input word $\mathit{ys}$; if
  $\mathit{ctl}$ is one then $\mathit{xs}$ is equal to $\mathit{zs}$.
  The word sizes of $\mathit{ys}$ and $\mathit{zs}$ must be the same,
  and this is also the word size of the output $\mathit{xs}$.
\item \textbf{mux2w} \\
  Type: $\mathit{mux2w} :: Signal a \Rightarrow (a,a) \rightarrow [a]
  \rightarrow [a] \rightarrow [a] \rightarrow [a] \rightarrow [a]$ \\
  Usage: $ $ \\
  Uses a two-bit control input $(\mathit{ctl}_0,\mathit{ctl}_1)$ to
  select and output the corresponding data input word.  All of the
  data input words must have the same word size, and this is the word
  size of the output.
\end{itemize}


\section{Demultiplexers}
\label{sec:demultiplexers}

\begin{itemize}
\item $\mathit{demux1} :: \mathit{Signal} a \Rightarrow a \rightarrow a
  \rightarrow (a,a)$
\item $\mathit{demux1w} :: \mathit{Signal} a \Rightarrow [a]
  \rightarrow a \rightarrow [a]$
\item $\mathit{demux2w} :: \mathit{Signal} a \Rightarrow [a]
  \rightarrow a \rightarrow [a]$
\item $\mathit{demux3w} :: \mathit{Signal} a \Rightarrow [a]
  \rightarrow a \rightarrow [a]$
\item $\mathit{demux4w} :: \mathit{Signal} a \Rightarrow [a]
  \rightarrow a \rightarrow [a]$
\end{itemize}

</para>

<programlisting>
> demux1 :: Signal a => a -> a -> (a,a)
> demux1 c x = (and2 (inv c) x, and2 c x)
</programlisting>

<programlisting>
> mux22 :: Signal a => (a,a) -> (a,a) -> (a,a)
>            -> (a,a) -> (a,a) -> (a,a)
> mux22 (a,b) (w0,w1) (x0,x1) (y0,y1) (z0,z1) =
>   (mux2 (a,b) w0 x0 y0 z0,
>    mux2 (a,b) w1 x1 y1 z1)
</programlisting>

</sect2>

<sect2><title>Combinational shifting</title>

<para>
shr Shift a word to the right (shr) or to the left (shl).  In both
cases, this is just a wiring pattern.  A 0 is brought in on one
side, and the bit on the other side is just thrown away.
</para>

<programlisting>
shl, shrr :: Signal a => [a] -> [a]
</programlisting>

<para>

\begin{itemize}
  
\item $\mathit{winv4}\ ::\ \mathit{Signal}\ a \Rightarrow [a]
  \rightarrow [a]$ \hfill\break $ys = inv4 xs$ \hfill\break A 4-bit
  word inverter.  The input \textit{xs} is a word $[x_0,x_1,x_2,x_3]$
  of signals, which must have four elements, and the output word
  \textit{ys} is the bitwise inversion of \textit{xs}.

\item $\textit{rippleAdd4}\ ::\ \textit{Signal}\ a\ \Rightarrow
     a \rightarrow [(a,a)] \rightarrow (a,[a]) $ \hfill\break
  Example: $(c',s)\ =\ \textit{rippleAdd4}\ c\ \textit{z}$ \hfill\break
  Example: $(c',[s_0, s_1, s_2, s_3)\ =\ \textit{rippleAdd4}\ c
    \ [(x_0,y_0), (x_1,y_1), (x_2,y_2), (x_3,y_3)]$ \hfill\break
  A 4-bit ripple carry adder.  The sum of the carry input $c$ and two
  four-bit words $x = [x_0, x_1, x_2, x_3]$ and $y = [y_0, y_1, y_2, y_3]$
  which are input in bit slice format.  The output consists of a carry
  output c' and a sum word $s = [s_0, s_1, s_2, s_3]$.  The circuit
  satisfies the specification
     \[\textit{bin}\ (c':s)\ =\ \textit{bin}\ x\ +\ \textit{bin}\ y\ 
     +\ \textit{bit}\ c\]

\end{itemize}
</para>

</sect2>

</sect1>

<sect1><title>Arithmetic</title>

<para>
foo
</para>




<sect2><title>Ripple Carry Adder</title>

<para>
Specification


Implementation

Simulation
</para>

<para>
Although the adder is a combinational circuit, it's easiest to test it
with a full-blown simulation driver that provides separate numbers to
add during each clock cycle.  Unless the wordsize is very small, the
adder has too many inputs for a truth table to be reasonable, and the
only way to test it is by providing a small subset of all the possible
inputs.  A simulation driver provides a systematic way to run a series
of tests over a sequence of clock cycles.
</para>

<para>
The simulation driver for and adder should let you write the input and
read the output in decimal notation.  There are three values to be
supplied for each clock cycle: the carry input $c$, and the two
numbers $x$ and $y$.  For each test case, the inputs will be written
as a list of three decimal numbersThese will be written in a list of
the form $[c, x, y]$.  The entire simulation input will be a list of
test cases which will be run in a succession of clock cycles.  An
example of the input is \textit{add\_input1}.
</para>

<programlisting>
> add_input1 :: [[Int]]

> add_input1 =
> --  c   x    y
> -- bit bin  bin
> -- ~~~~~~~~~~~~~
>   [[0,   2,   3],
>    [0,   1,   8],
>    [0,  10,   5],
>    [0,  11,   2],
>    [1,   4,   5]]
</programlisting>

<para>
An important point to notice is that a simulation driver is concerned
only with the \emph{type} of a circuit, not with its internal
structure.  This means that we could have a variety of different
circuits that implement the same specification, an that share the same
type.  It's a good idea to exploit this by generalising the simulation
driver, so that it takes a particular circuit implementation as an
argument.  If we go on to optimise the circuit, in order to make it
faster, the same driver (and the same input) can be used to test each
version.  The adder simulation driver will work for any circuit that
has the appropriate type.  Since simulation drivers operate through a
sequence of clock cycles, they require the synchronous model to be
used. This means that the signal type $a$ must be in the
\textit{Clocked} class.
</para>

<programlisting>
Clocked a => a -> [(a,a)] -> (a,[a])
</programlisting>

<para>
Since the ripple carry adder is a combinational circuit, it works with
all semantic models, so it has the more general type:
</para>

<programlisting>
Signal a => a -> [(a,a)] -> (a,[a])
</programlisting>

<para>
Since any clocked signal is a signal, there is no problem with doing a
synchronous simulation of a combinational circuit.
</para>

<para>
The simulation driver is called \textit{sim\_adder}, and it takes
three arguments: the adder circuit to be tested, its wordsize, and the
input data.  For example, in order to test the 4-bit ripple carry
adder with the input data above, you can enter the following
expression at the interactive prompt:
</para>

<programlisting>
sim_adder rippleAdd4 4 add_input1
</programlisting>

<para>
The simulation produces the following output:
</para>

<programlisting>
WordCombTest> sim_adder rippleAdd4 4 add_input1

..................................................
   Simulating ripple carry adder
      0.   ci=0 x=   2 y=   3   Output: 0   5
      1.   ci=0 x=   1 y=   8   Output: 0   9
      2.   ci=0 x=  10 y=   5   Output: 0  15
      3.   ci=0 x=  11 y=   2   Output: 0  13
      4.   ci=1 x=   4 y=   5   Output: 0  10
..................................................
</programlisting>

<para>
We can try similar experiments by using the general $n$-bit circuit
\textit{rippleAdd}, by varying the wordsize, and by using alternative
test data.  The following experiments can be entered interactively, or
they can be gathered together into a batch simulation file.
</para>

<programlisting>
sim_adder rippleAdd4  4 add_input1
sim_adder rippleAdd   4 add_input1
sim_adder rippleAdd  16 add_input1
</programlisting>

<para>
\emph{Note:  see module WordCombTest}
</para>

<para>
The adder has one circuit parameter, its wordsize, since our ripple
carry adders may be defined using design patterns that work for
arbitrary size!  Here we use 8-bit words.
</para>

<programlisting>
n = 8
</programlisting>

<para>
The heart of the simulation driver is an equation that uses the
circuit.  Here, we define the carry output co and the sum word s to be
the outputs of an adder with input words x and y; these are
represented in bit slice form as a single word z :: [(a,a)].
</para>

<programlisting>
(co,s) = rippleAdd ci z
</programlisting>

<para>
The bit slice word z is formed by the bitslice2 wiring pattern:
</para>

<programlisting>
z = bitslice2 x y
</programlisting>

<para>
We could also omit this equation, and write the circuit application as
</para>

<programlisting>
(co,s) = rippleAdd ci (bitslice2 x y)
</programlisting>

<para>
The inputs to the circuit can be provided interactively, but sometimes
it's more convenient to define a set of inputs as a constant
definition in the simulation module.  This allows us to run a
simulation repeatedly, without having to keep typing the same inputs
over and over again.  That approach will be taken here; later we will
introduce tools that support interactive simulations.
</para>

<para>
Now we need to use the tools for converting the test input to the
correct signal representations:
</para>

<programlisting>
ci = getbit   input 0 :: Stream Bool 
   x  = getbin n input 1
   y  = getbin n input 2
</programlisting>

<para>
The first equation says that ci is obtained from the 0'th column of
the test input, using a bit conversion (getbit).  The second equation
says that x comes from column 1 in the test input, and it's converted
using a binary conversion (getbin n), where n is the wordsize.  The
last equation converts y from column 2 of the input data.
</para>

<para>
The final step is to format the output.  First, we specify the
underlying signal representation that is being used:
</para>


<programlisting>
simoutput :: [Format Bool]
</programlisting>

<para>
This is necessary, because Hydra supports a large number of signal
representations, and it needs to know which one to use here.
</para>

<para>
Now we define the simulation output by formatting the various signals
that should be printed.  The format consists of a list of fields
separated by commas.  For every clock cycle, Hydra will print a line
comprising all these fields.  The field format specifications are

  string "abc"  prints the literal string on each line
  bit x         prints the value of the bit signal x, as 0 or 1
  bindec k x    converts the binary word x to a 4-digit decimal integer
  tcdec k x     converts the two's complement word x to a 4-digit
                decimal integer
</para>

<para>
The following format prints the adder's inputs and outputs, along with
some labels:
</para>

<programlisting>
simoutput =
      [bit ci,
       string " x= ", bindec 4 x, tcdec 4 x,
       string " y= ", bindec 4 y, tcdec 4 y,
       string " Output: ", bit co,
       string " sum= ", bindec 4 s, tcdec 4 s]
</programlisting>

<para>
Putting all the pieces together, here is the simulation driver for the
ripple carry adder:
</para>

<para>

Here is the complete definition of the simulation driver.
</para>

<programlisting>
sim_adder add_circuit n input =
  let (co,s) = add_circuit ci (bitslice2 x y)
      ci = getbit   input 0
      x  = getbin n input 1
      y  = getbin n input 2
      simoutput :: [Format Bool]
      simoutput =
        [string " ci=", bit ci,
         string " x= ", bindec 3 x,
         string " y= ", bindec 3 y,
         string "   Output: ", bit co, bindec 4 s]
  in do putStrLn "\nSimulating ripple carry adder"
        run input simoutput
</programlisting>

</sect2>

<sect2><title>Subtraction</title>


<para>
Two's complement addition and subtraction
</para>

<programlisting>
> addSub :: Signal a => a -> [(a,a)] -> (a,[a])
> addSub sub xy = rippleAdd sub (map f xy)
>   where f (x,y) = (x, xor2 sub y)
</programlisting>

</sect2>

<sect2><title>Binary ripple comparison</title>


<para>
Simulation Driver for Comparitor

The ripple comparitor for binary numbers can be simulated by entering
the following:
</para>

<programlisting>
sim_comparitor rippleCmp 16 cmp_input1
</programlisting>

<para>
Here is some test data for the comparitor...
</para>

<programlisting>
> cmp_input1 :: [[Int]]
> cmp_input1 =
>   [[2, 3],
>    [3, 2],
>    [3, 3],
>    [1, 8],
>    [8, 1],
>    [9, 9],
>    [0, 5],
>    [7, 5]]
</programlisting>

<para>
The simulation driver is similar to the adder driver.
</para>

<programlisting>
> sim_comparitor circuit n input =
>   let (lt,eq,gt) = circuit (bitslice2 x y)
>       x = getbin n input 0
>       y = getbin n input 1
>       simoutput :: [Format Bool]
>       simoutput =
>         [string " x= ", bindec 4 x,
>          string "   y= ", bindec 4 y,
>          string "  (lt,eq,gt) = ",
>          bit lt, bit eq, bit gt]
>   in do putStrLn "\nSimulating comparitor"
>         run input simoutput
</programlisting>


<programlisting>
halfAdd :: Signal a => a -> a -> (a,a)
bsum, bcarry :: Signal a => (a,a) -> a -> a
fullAdd :: Signal a => (a,a) -> a -> (a,a)
rippleAdd :: Signal a => a -> [(a,a)] -> (a,[a])
addSub :: Signal a => a -> [(a,a)] -> (a,[a])

cmp1 :: Signal a => (a,a,a) -> (a,a) -> (a,a,a)
rippleCmp :: Signal a => [(a,a)] -> (a,a,a)
</programlisting>

<para>
The following is defined in Hydra.Circuits.Arithmetic.TreeAdd
</para>

<programlisting>
> add5 :: Signal a => a -> [(a,a)] -> (a,[a])
</programlisting>


<para>
The following is defined in Hydra.Circuits.Arithmetic.Multiply
</para>

<programlisting>
multiply :: Clocked a => Int
  -> a -> [a] -> [a] -> (a,[a],[a],[a],[a])
</programlisting>

<para>
\begin{itemize}
\item $halfAdd :: Signal a \Rightarrow a \rightarrow a \rightarrow (a,a)$
\item $fullAdd :: Signal a \Rightarrow (a,a) \rightarrow a \rightarrow (a,a)$
\item $bsum, bcarry :: Signal a \Rightarrow (a,a) \rightarrow a \rightarrow a$
\item $rippleAdd4 :: Signal a \Rightarrow a \rightarrow [(a,a)] \rightarrow (a,[a])$
\item $rippleAdd :: Signal a \Rightarrow a \rightarrow [(a,a)] \rightarrow (a,[a])$
\item $addSub :: Signal a \Rightarrow a \rightarrow [(a,a)] \rightarrow (a,[a])$
\item $cmp1 :: Signal a \Rightarrow (a,a,a) \rightarrow (a,a) \rightarrow (a,a,a)$
\item $rippleCmp :: Signal a \Rightarrow [(a,a)] \rightarrow (a,a,a)$
\end{itemize}
</para>
</sect2>
</sect1>

<sect1><title>Registers</title>

<sect2><title>Basic registers</title>

<programlisting>
reg1 :: Clocked a => a -> a -> a
reg :: Clocked a => Int -> a -> [a] -> [a]
wlatch :: Clocked a => Int -> [a] -> [a]
</programlisting>

<programlisting>
sr :: (Signal a, Clocked a)
  => (a,a) -> a -> a -> [a] -> (a,a,[a])
</programlisting>

<programlisting>
regfile1 :: Clocked a => Int -> a -> [a] -> [a] -> [a] -> a -> (a,a)
</programlisting>

<programlisting>
regfile :: Clocked a => Int -> Int
  -> a -> [a] -> [a] -> [a] -> [a] -> ([a],[a])
</programlisting>

<para>
\section{Registers}
\label{sec:registers}

\begin{itemize}
\item $reg1 :: Clocked a \Rightarrow a \rightarrow a \rightarrow a $
\item $reg :: Clocked a \Rightarrow Int \rightarrow a \rightarrow [a] \rightarrow [a]$
\item $srb :: Clocked a \Rightarrow (a,a) \rightarrow a \rightarrow a \rightarrow a \rightarrow a$ \\
  Meaning of op: 0 -- no state change 1 -- load input word x 2 --
  shift right 3 -- shift left
\item $sr :: (Signal a, Clocked a)$
\item $ sr4_v1 :: Clocked a \Rightarrow (a,a) \rightarrow a \rightarrow a \rightarrow [a] \rightarrow [a]$
\item $regfile1 :: Clocked a \Rightarrow Int \rightarrow a \rightarrow
  [a] \rightarrow [a] \rightarrow [a] \rightarrow a \rightarrow (a,a)$
\item $reg4 :: Clocked a \Rightarrow a \rightarrow [a] \rightarrow [a]$
\item $regfile :: Clocked a \Rightarrow Int \rightarrow Int
  \rightarrow a \rightarrow [a] \rightarrow [a] \rightarrow [a]
  \rightarrow [a] \rightarrow ([a],[a])$
\end{itemize}
</para>

</sect2>

<sect2><title>Shift Registers</title>

<programlisting>
> sr4_v1 :: Clocked a => (a,a) -> a -> a -> [a] -> [a]
> sr4_v1 op l r [x0,x1,x2,x3] = [a,b,c,d]
>   where
>      a = srb op l b x0
>      b = srb op a c x1
>      c = srb op b d x2
>      d = srb op c r x3
</programlisting>

<programlisting>
> sr4_v2 :: Clocked a => (a,a) -> a -> a -> [a] -> [a]
> sr4_v2 op l r [x0,x1,x2,x3] = [a,b,c,d]
>   where
>      (opa,opb,opc,opd) = fanout4 op
>      a = srb opa l b x0
>      b = srb opb a c x1
>      c = srb opc b d x2
>      d = srb opd c r x3
</programlisting>

<programlisting>
> sr4_v3 :: Clocked a => (a,a) -> a -> a -> [a] -> [a]
> sr4_v3 op l r [x0,x1,x2,x3] = [a,b,c,d]
>   where
>      f = srb op
>      a = f l b x0
>      b = f a c x1
>      c = f b d x2
>      d = f c r x3
</programlisting>

<para>
\begin{itemize}
\item Design a general shift register as follows:
  \begin{itemize}
  \item There are $n$ bit positions, each with one bit of state.
  \item There is an $n$-bit word input $a = [a_0, \ldots, a_{n-1}]$.
  \item There are two data inputs $l$ and $r$; $l$ is the left input
    (it comes into the leftmost position $0$), and $r$ is the right
    input (it comes into the rightmost position $n-1$).
  \item There is a two-bit control input $[c_0,c_1]$.  For
    convenience, we will refer to the four possible values of the
    control input as 0, 1, 2, and 3.
  \item The circuit has three outputs: an $n$-bit word which is the
    contents of the $n$ states; the left output (which is the value of
    bit 0) and the right output (which is the value of bit $n-1$).
    Notice that Bit 0 actually appears twice in the output, once as
    $l'$ and again as the 0'th bit of the output word; similarly Bit
    $n-1$ appears twice, once as $r'$ and also as bit $n-1$ of the
    output.
  \item At each clock tick, the behaviour is as follows:
\begin{center}
  \begin{tabular}{|l|l|l|} \hline
    $c$    \emph{action}  \emph{behaviour} \\ \hline
    0    clear   $x_i := 0$ for $0 \leq i LT n$ \\
    1    load    $x_i := a_i$ for $0 \leq i LT n$ \\
    2    shift left $x_i := x_{i+1}$ for $0 \leq i \leq n-2$,
            $x_{n-1} := r$  \\
    3    shift right $x_i := x_{i-1}$ for $1 \leq i \leq n-1$,
            $x_0 := l$\\
    \hline
  \end{tabular}
\end{center}
\item \textbf{Hint:} \emph{Figure out what's going on in each bit
    position, and design a circuit---you could call it
    \texttt{srb}---that implements an arbitrary position in the
    circuit.  Then design the entire circuit as a row of shift
    register bits, connnected together in an appropriate way.  If you
    like, you may simply design a version of the circuit at a specific
    wordsize, say 4 bits, but the most elegant approach is to use a
    combinator.}
\end{itemize}
\end{itemize}
</para>

<programlisting>
> srb :: Clocked a => (a,a) -> a -> a -> a -> a
> srb op l r x = y
>   where y = dff (mux2 op y x l r)
</programlisting>

<programlisting>
> sr4 :: Clocked a => (a,a) -> a -> a -> [a] -> [a]
> sr4 op l r [x0,x1,x2,x3] = [a,b,c,d]
>   where
>      a = srb op l b x0
>      b = srb op a c x1
>      c = srb op b d x2
>      d = srb op c r x3
</programlisting>

<para>
We can define the shift register circuit more generally with the
mscanr combinator; note that in this simulation, we use the general
circuit "sr" rather than the restricted 4-bit sr4.  The test data
is identical to that used above, and you can check that the circuit
defined in this more general way has the same behaviour on this
test data.
</para>

<programlisting>
sim_gen_sr_4 =
  let input =
--      op  l  r  x        op    produce  state
--      ~~~~~~~~~~~       ~~~~~~~~~~~~~~~~~~~~~
       [[1, 0, 0, 9],  -- load     1001    0000
        [0, 0, 0, 3],  -- nop      1001    1001
        [2, 1, 0, 4],  -- right 1  1100    1001
        [2, 0, 0, 2],  -- right 0  0110    1100
        [3, 0, 1, 7],  -- left  1  1101    0110
        [1, 0, 0, 5],  -- load     0101    1101
        [0, 0, 0, 0]]  -- nop      0101    0101
      op = getbit2  input 0
      l =  getbit   input 1
      r =  getbit   input 2
      x =  getbin 4 input 3
      (op0,op1) = op
      (p,q,y) = sr op l r x
      simoutput :: [Format Bool]
      simoutput = [string "Input: ",
              bit op0, bit op1, string " ",
              bit l, string " ", bit r, string " ", bits x,
              string "    Output: ",
              bit p, bit q, string " ", bits y]
  in do putStrLn "\nSimulate n-bit shift register, size 4"
        run input simoutput
</programlisting>

<para>
Here is a similar example, but where the word size is increased to
8.  Notice that all we had to do to change the wordsize was to
change the number of bits in x; the general mscanr combinator
automatically accommodates itself to the new word size!
</para>

<programlisting>
sim_gen_sr_8 =
  let input =
--      op  l  r  x        op        state
--      ~~~~~~~~~~~       ~~~~~~~~~~~~~~~~~~~~~
       [[1, 0, 0, 75],  -- load     0000 0000
        [0, 0, 0,  3],  -- nop      0100 1011
        [2, 1, 0,  4],  -- right 1  0100 1011
        [2, 0, 0,  2],  -- right 0  1010 0101
        [3, 0, 1,  7],  -- left  1  0101 0010
        [1, 0, 0,  5],  -- load     1010 0101
        [0, 0, 0,  0]]  -- nop      0000 0101
      op = getbit2  input 0
      l =  getbit   input 1
      r =  getbit   input 2
      x =  getbin 8 input 3  -- 8 bit words!
      (op0,op1) = op
      (p,q,y) = sr op l r x
      simoutput :: [Format Bool]
      simoutput = [string "Input: ",
              bit op0, bit op1, string " ",
              bit l, string " ", bit r, string " ", bits x,
              string "    Output: ",
              bit p, bit q, string " ", bits y]
  in run input simoutput
</programlisting>

<para>
We can define the shift register circuit more generally with the
mscanr combinator; note that in this simulation, we use the general
circuit "sr" rather than the restricted 4-bit sr4.  The test data
is identical to that used above, and you can check that the circuit
defined in this more general way has the same behaviour on this
test data.
</para>

<programlisting>
sim_gen_sr_4 =
  let input =
--      op  l  r  x        op    produce  state
--      ~~~~~~~~~~~       ~~~~~~~~~~~~~~~~~~~~~
       [[1, 0, 0, 9],  -- load     1001    0000
        [0, 0, 0, 3],  -- nop      1001    1001
        [2, 1, 0, 4],  -- right 1  1100    1001
        [2, 0, 0, 2],  -- right 0  0110    1100
        [3, 0, 1, 7],  -- left  1  1101    0110
        [1, 0, 0, 5],  -- load     0101    1101
        [0, 0, 0, 0]]  -- nop      0101    0101
      op = getbit2  input 0
      l =  getbit   input 1
      r =  getbit   input 2
      x =  getbin 4 input 3
      (op0,op1) = op
      (p,q,y) = sr op l r x
      simoutput :: [Format Bool]
      simoutput = [string "Input: ",
              bit op0, bit op1, string " ",
              bit l, string " ", bit r, string " ", bits x,
              string "    Output: ",
              bit p, bit q, string " ", bits y]
  in do putStrLn "\nSimulate n-bit shift register, size 4"
        run input simoutput
</programlisting>

<para>
Here is a similar example, but where the word size is increased to
8.  Notice that all we had to do to change the wordsize was to
change the number of bits in x; the general mscanr combinator
automatically accommodates itself to the new word size!
</para>

<programlisting>
sim_gen_sr_8 =
  let input =
--      op  l  r  x        op        state
--      ~~~~~~~~~~~       ~~~~~~~~~~~~~~~~~~~~~
       [[1, 0, 0, 75],  -- load     0000 0000
        [0, 0, 0,  3],  -- nop      0100 1011
        [2, 1, 0,  4],  -- right 1  0100 1011
        [2, 0, 0,  2],  -- right 0  1010 0101
        [3, 0, 1,  7],  -- left  1  0101 0010
        [1, 0, 0,  5],  -- load     1010 0101
        [0, 0, 0,  0]]  -- nop      0000 0101
      op = getbit2  input 0
      l =  getbit   input 1
      r =  getbit   input 2
      x =  getbin 8 input 3  -- 8 bit words!
      (op0,op1) = op
      (p,q,y) = sr op l r x
      simoutput :: [Format Bool]
      simoutput = [string "Input: ",
              bit op0, bit op1, string " ",
              bit l, string " ", bit r, string " ", bits x,
              string "    Output: ",
              bit p, bit q, string " ", bits y]
  in run input simoutput
</programlisting>
</sect2>

<sect2><title>Bidirectional Shift Registers</title>

<para>
The bidirectional shift register takes an operation code that
determines the behavior:
</para>

<para>
\begin{tabular}{ll}
  0  no state change \\
  1  load input word x \\
  2  shift right \\
  3  shift left \\
\end{tabular}
</para>

<para>
The following test data contains comments showing the expected output.
This is a useful technique for documenting a circuit, and it provides
a good permanent test case.
</para>

<programlisting>
sr4_input :: [[Int]]
sr4_input =
--      op  l  r  x        op    produce  state
--      ~~~~~~~~~~~       ~~~~~~~~~~~~~~~~~~~~~
       [[1, 0, 0, 9],  -- load     1001    0000
        [0, 0, 0, 3],  -- nop      1001    1001
        [2, 1, 0, 4],  -- right 1  1100    1001
        [2, 0, 0, 2],  -- right 0  0110    1100
        [3, 0, 1, 7],  -- left  1  1101    0110
        [1, 0, 0, 5],  -- load     0101    1101
        [0, 0, 0, 0]]  -- nop      0101    0101
</programlisting>

<para>
Here is a simulation driver intended specifically for the 4-bit
version of the circuit.
</para>

<programlisting>
sim_sr4 input =
  let op = getbit2  input 0
      l =  getbit   input 1
      r =  getbit   input 2
      x =  getbin 4 input 3
      (op0,op1) = op
      y = sr4 op l r x
      simoutput :: [Format Bool]
      simoutput = [string "Input: ",
              bit op0, bit op1, string " ",
              bit l, string " ", bit r, string " ", bits x,
              string "    Output: ", bits y]
  in do putStrLn "\nSimulate 4-bit shift register"
        run input simoutput
</programlisting>

</sect2>

<sect2><title>Memory</title>

<programlisting>
mem1 :: (Signal a, Clocked a) => Int
  -> a -> [a] -> [a] -> a -> a

memw :: Clocked a => Int -> Int -> a -> [a] -> [a] -> [a]

mem1a :: Clocked a => Int -> a -> [a] -> a -> a
</programlisting>


<para>
\item $mem1 :: (Signal a, Clocked a) \Rightarrow Int \rightarrow a
  \rightarrow [a] \rightarrow [a] \rightarrow a \rightarrow a$

\item $mem1a :: Clocked a \Rightarrow Int \rightarrow a \rightarrow [a] \rightarrow a \rightarrow a$

\item $memw :: Clocked a \Rightarrow Int \rightarrow Int \rightarrow a
  \rightarrow [a] \rightarrow [a] \rightarrow [a]$
</para>

<programlisting>
> mem1
>   :: (Signal a, Clocked a)
>   => Int
>   -> a -> [a] -> [a] -> a -> a

> mem1 0 ld d sa x =
>   reg1 ld x

> mem1 (k+1) ld (d:ds) (sa:sas) x = a
>   where
>     (ld0,ld1) = demux1 d ld
>     a0 = mem1 k ld0 ds sas x
>     a1 = mem1 k ld1 ds sas x
>     a = mux1 sa a0 a1
</programlisting>

</sect2>

</sect1>

</chapter>


</book>


